<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>你可能不了解的 Java 知识之 @Contended</title>
    <url>/2020/06/27/java-ann-contended/</url>
    <content><![CDATA[<p>Java 8 根据 JDK 第 142 号增强提案（<a href="http://openjdk.java.net/jeps/142" target="_blank" rel="noopener">JEP142</a>）引入了一个特殊的注解 <code>@sun.misc.Contended</code> （Java 9 之后该注解移到了 <code>jdk.internal.vm.annotation</code> 包下，详情见 <a href="https://www.javaspecialists.eu/archive/Issue249.html" target="_blank" rel="noopener">链接</a>），主要是来减少 <strong>伪共享（False Sharing）</strong>造成的性能损失，本文将介绍一下该注解的作用及使用场景。</p>
<a id="more"></a>


<h2 id="缓存行（Cache-Line）"><a href="#缓存行（Cache-Line）" class="headerlink" title="缓存行（Cache Line）"></a>缓存行（Cache Line）</h2><p>大家都知道为了提升读取数据的速度，CPU 和主内存之间一般都有高速缓存，缓存行则可以理解为高速缓存的最小存储单位（如最常见的缓存行大小是64个字节），当 CPU 从高速缓存中读取不到数据时，则会从主内存中读取和缓存行大小相同的数据到高速缓存中，假如缓存行是 64 字节，如果访问一个 long（long 在内存中占用 8 字节）数组，当数组中的一个值被加载到高速缓存中，它会额外加载另外 7 个。</p>
<p><img src="/images/ann-contended/cache-line.png" alt="Cache Line"></p>
<hr>
<h2 id="伪共享（False-Sharing）"><a href="#伪共享（False-Sharing）" class="headerlink" title="伪共享（False Sharing）"></a>伪共享（False Sharing）</h2><p>缓存行的设计是为了提升 CPU 读取数据的速率，但如果多个线程共享同一个缓存行，任何一个线程修改缓存行的任意一条数据都会造成整个缓存行的失效，这种情况下缓存行反而会降低 CPU 读取数据的速率，如下图：</p>
<p><img src="/images/ann-contended/false-sharing.png" alt="False Sharing"></p>
<hr>
<h2 id="Contended"><a href="#Contended" class="headerlink" title="@Contended"></a>@Contended</h2><p>为了解决伪共享造成的性能损耗，通常可以采取 <strong>字节填充</strong> 的策略，如下面的一段代码新增了 6 个 long 类型的填充数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里的 CacheLine 的大小是 64 字节，但填充的数据只有 48 个字节，</span></span><br><span class="line"><span class="comment"> * 加上原有的数据也只有 56 字节，其原因是 Java 对象头还占据了 8 个字节</span></span><br><span class="line"><span class="comment"> * 所以填充 48 个字节正好是一个 CacheLine 的大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaddingObject</span></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value = <span class="number">0L</span>;    <span class="comment">// 实际数据</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">long</span> p1, p2, p3, p4, p5, p6; <span class="comment">// 填充</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>PaddingObject 类中需要保存一个 long 类型的 value 值，如果多线程操作同一个 CacheLine 中的 PaddingObject 对象，便无法完全发挥出 CPU Cache 的优势（想象一下你定义了一个 PaddingObject[] 数组，数组元素在内存中连续，却由于伪共享导致无法使用 CPU Cache 带来的沮丧）。</p>
</blockquote>
<p>当然 Java8 之后给我们提供了一种更加优雅的解决方案，无需担心 JDK 的无效字段优化，无需担心 CacheLine 在不同 CPU 下的大小究竟是不是 64 字节，其原理是在使用此注解的对象或字段的前后各增加 128 字节大小的 padding，使用 2 倍于大多数硬件缓存行的大小来避免相邻扇区预取导致的伪共享冲突。</p>
<p>不过需要注意的是，@Contended 注解会增加目标实例大小，要谨慎使用。默认情况下，除了 JDK 内部的类，JVM 会忽略该注解。要应用代码支持的话，要设置 <code>-XX:-RestrictContended</code>（RestrictContended 默认是打开的，意味仅限 JDK 内部的类使用该注解），当然，也可以使用 <code>–XX:(+/-)EnableContended</code> 来控制开启和关闭该注解的功能，如果关闭了该注解，可以减少 Thread 和 ConcurrentHashMap 类的大小，但也可能会带来性能的降低。</p>
<hr>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>java 8 之后，ConcurrentHashMap 用 basecount 和 countercell 数组来计算 size 的值，一般往 Map 中 put 元素时，会先对 baseCount 做 CAS 自增操作，如果并发导致 baseCount CAS 失败了使用 counterCells，所以可以看出 countercell 数组的元素在并发情况下会被多个线程频繁读写，为了避免伪共享造成的性能损耗，JDK 在代码实现时使用了 @sun.misc.Contended 标记了 CounterCell 类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ---------------- Counter support -------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A padded cell for distributing counts.  Adapted from LongAdder</span></span><br><span class="line"><span class="comment"> * and Striped64.  See their internal docs for explanation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@sun</span>.misc.Contended <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CounterCell</span> </span>&#123;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">long</span> value;</span><br><span class="line">  CounterCell(<span class="keyword">long</span> x) &#123;value = x;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h3><p>Exchanger 是为了实现不同线程之间安全交换数据的工具，Exchanger 定义的 Node 节点对象就是实现数据交换时在内存槽位中存储的数据模型，用于交换的数据其实也是期望能充分利用缓存行来提升性能，所以 JDK 用 <code>@Contended</code> 修饰了 Node 从而将整个槽位与其他数据存储分隔开来，从而避免了伪共享问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Nodes hold partially exchanged data, plus other per-thread</span></span><br><span class="line"><span class="comment">  * bookkeeping. Padded via <span class="doctag">@Contended</span> to reduce memory contention.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="meta">@sun</span>.misc.Contended <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index;              <span class="comment">// Arena index</span></span><br><span class="line">    <span class="keyword">int</span> bound;              <span class="comment">// Last recorded value of Exchanger.bound</span></span><br><span class="line">    <span class="keyword">int</span> collides;           <span class="comment">// Number of CAS failures at current bound</span></span><br><span class="line">    <span class="keyword">int</span> hash;               <span class="comment">// Pseudo-random for spins</span></span><br><span class="line">    Object item;            <span class="comment">// This thread's current item</span></span><br><span class="line">    <span class="keyword">volatile</span> Object match;  <span class="comment">// Item provided by releasing thread</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread parked; <span class="comment">// Set to this thread when parked, else null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h3><p>Thread 在 Java8 后新增了如下 3 个变量，这 3 个变量也仅在 <code>java.util.concurrent.ThreadLocalRandom</code> 中用到，用作生成随机数的种子，为了防止这 3 个变量的更新导致缓存出现伪共享的问题，JDK 将这三个变量都加上了 <code>@Contended</code> 注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The following three initially uninitialized fields are exclusively</span></span><br><span class="line"><span class="comment">// managed by class java.util.concurrent.ThreadLocalRandom. These</span></span><br><span class="line"><span class="comment">// fields are used to build the high-performance PRNGs in the</span></span><br><span class="line"><span class="comment">// concurrent code, and we can not risk accidental false sharing.</span></span><br><span class="line"><span class="comment">// Hence, the fields are isolated with @Contended.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** The current seed for a ThreadLocalRandom */</span></span><br><span class="line"><span class="meta">@sun</span>.misc.Contended(<span class="string">"tlr"</span>)</span><br><span class="line"><span class="keyword">long</span> threadLocalRandomSeed;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Probe hash value; nonzero if threadLocalRandomSeed initialized */</span></span><br><span class="line"><span class="meta">@sun</span>.misc.Contended(<span class="string">"tlr"</span>)</span><br><span class="line"><span class="keyword">int</span> threadLocalRandomProbe;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Secondary seed isolated from public ThreadLocalRandom sequence */</span></span><br><span class="line"><span class="meta">@sun</span>.misc.Contended(<span class="string">"tlr"</span>)</span><br><span class="line"><span class="keyword">int</span> threadLocalRandomSecondarySeed;</span><br></pre></td></tr></table></figure>

<h3 id="UidGenerator"><a href="#UidGenerator" class="headerlink" title="UidGenerator"></a>UidGenerator</h3><p>百度的 <a href="https://github.com/baidu/uid-generator/blob/master/README.zh_cn.md" target="_blank" rel="noopener">snowflake</a> 实现，其中 PaddedAtomicLong 对象引用 8 字节，使用了 6 个 long 变量 48 字节进行填充，以及一个 long 型的值，一共 64 字节。使用了 sumPaddingToPreventOptimization 方法规避编译器或 GC 优化没使用的变量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Represents a padded &#123;<span class="doctag">@link</span> AtomicLong&#125; to prevent the FalseSharing problem&lt;p&gt;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * The CPU cache line commonly be 64 bytes, here is a sample of cache line after padding:&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 64 bytes = 8 bytes (object reference) + 6 * 8 bytes (padded long) + 8 bytes (a long value)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yutianbao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaddedAtomicLong</span> <span class="keyword">extends</span> <span class="title">AtomicLong</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3415778863941386253L</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Padded 6 long (48 bytes) */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">long</span> p1, p2, p3, p4, p5, p6 = <span class="number">7L</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Constructors from &#123;<span class="doctag">@link</span> AtomicLong&#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PaddedAtomicLong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PaddedAtomicLong</span><span class="params">(<span class="keyword">long</span> initialValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialValue);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * To prevent GC optimizations for cleaning unused padded references</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sumPaddingToPreventOptimization</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p1 + p2 + p3 + p4 + p5 + p6;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RingBuffer"><a href="#RingBuffer" class="headerlink" title="RingBuffer"></a>RingBuffer</h3><p>来源于一款优秀的开源框架 <a href="https://github.com/LMAX-Exchange/disruptor" target="_blank" rel="noopener">Disruptor</a> 中的一个数据结构 RingBuffer：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RingBufferPad</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">long</span> p1, p2, p3, p4, p5, p6, p7;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RingBufferFields</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">RingBufferPad</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BUFFER_PAD;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> REF_ARRAY_BASE;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REF_ELEMENT_SHIFT;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe UNSAFE = Util.getUnsafe();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 省略 n 行代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<p>Java 多线程编程实战指南（核心篇）<br><a href="http://jingege.me/2016/05/31/sharing-false-and-contented/" target="_blank" rel="noopener">译文:@Contended和伪共享</a><br><a href="https://www.cnkirito.moe/cache-line/" target="_blank" rel="noopener">JAVA 拾遗 — CPU Cache 与缓存行</a><br><a href="https://www.jianshu.com/p/c3c108c3dcfd" target="_blank" rel="noopener">Java8使用@sun.misc.Contended避免伪共享</a><br><a href="http://www.createarttechnology.com/blog/article/49" target="_blank" rel="noopener">伪共享简介</a><br><a href="https://zhuanlan.zhihu.com/p/40627259" target="_blank" rel="noopener">ConcurrentHashMap 的size方法原理分析</a><br><a href="https://blog.csdn.net/qq_41693150/article/details/106081105" target="_blank" rel="noopener">Java并发包中ThreadLocalRandom类原理剖析</a><br><a href="https://alidg.me/blog/2020/4/24/thread-local-random" target="_blank" rel="noopener">Thread Local Randoms in Java</a><br><a href="https://www.jdon.com/54038" target="_blank" rel="noopener">抢拍神器的关键：优化提升Java线程局部随机数ThreadLocalRandom高并发技巧</a><br><a href="https://www.cnblogs.com/txmfz/p/10097806.html" target="_blank" rel="noopener">Java并发包同步工具之Exchanger</a></p>
</blockquote>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JAVA8</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析常用的概率数据结构（Probabilistic Data Structures）</title>
    <url>/2020/05/26/probabilistic_data_structures/</url>
    <content><![CDATA[<p>概率数据结构（Probabilistic data structures）在大数据的场景中会经常被使用，其基本的思想是基于概率及数理统计相关的知识，在满足合适的空间及时间复杂度下得到一个可接受的近似答案，常见的概率数据结构有：<strong>Bloom filter</strong>、<strong>Count–min sketch</strong>、<strong>HyperLogLog</strong>、<strong>MinHash</strong>、<strong>SimHash</strong>等。</p>
<a id="more"></a>

<h2 id="Bloom-filter"><a href="#Bloom-filter" class="headerlink" title="Bloom filter"></a>Bloom filter</h2><p>布隆过滤器（Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的 <code>二进制向量(位图)</code> 和一系列 <code>随机映射函数（哈希函数）</code>。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是 <code>空间效率</code> 和 <code>查询时间</code> 都远远超过一般的算法，缺点是有一定的<code>误识别率</code>和 <code>删除困难</code>。</p>
<blockquote>
<p>基于布隆过滤器计算一个元素不存在则该元素一定不存在，但若是计算一个元素存在则该元素仅仅是可能存在</p>
</blockquote>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul>
<li><p>添加元素<br>当需要添加元素时，我们需要使用多个哈希函数进行运算生成不同的哈希值，且根据生成的哈希值将二进制数组对应的 bit 位置为 1。</p>
<p>如下图，当插入字符串 “Bloom”时，对该字符串使用三种哈希函数进行计算所得到的哈希值分别为 1, 3, 7，则对应的 bit 位被设置为了 1：<br><img src="/images/bloom-filter-01.png" alt="Bloom Filter"></p>
<p>当插入第二个字符串 “Filter”，同样，我们使用相同的哈希函数进行运算，假设哈希值分别为 2,4,7，那么二进制数组则会变为:<br><img src="/images/bloom-filter-02.png" alt="Bloom Filter"><br>因为在插入第一个字符串时，哈希值为 7 的 bit 位置已经被置为 1，因此不需要更改，只需要将 bit 位为 2, 4 置为 1 即可。</p>
</li>
<li><p>查询元素<br>查询某个元素是否存在，只需要使用相同的哈希函数进行运算，然后判断对应的 bit 位是否全部为 1，若是则元素可能存在，否则元素不存在。</p>
<p>下图中，由于第二个哈希函数计算的哈希值对应第 5 bit，该 bit 的值 为 0，所以可以断定改元素一定不存在：<br><img src="/images/bloom-filter-03.png" alt="Bloom Filter"></p>
<p>下图中，三个哈希函数计算的哈希值对应的 bit 全部为 1，可以认为元素是可能存在的：<br><img src="/images/bloom-filter-04.png" alt="Bloom Filter"></p>
</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul>
<li><p>自己实现<br>算法原理很简单，不过需要自己考虑哈希函数的选型和评估误判率</p>
</li>
<li><p>Guava<br>通过调用 <a href="https://github.com/google/guava/blob/master/android/guava/src/com/google/common/hash/BloomFilter.java" target="_blank" rel="noopener"><code>BloomFilter</code></a> 类中的静态函数创建， 传递一个 Funnel 对象以及一个代表预期插入数量整数。同样来自于 Guava 11 中的 Funnel 对象，用于将数据发送给一个接收器（Sink）。 下面的例子是一个默认的实现，有着 3% 的误报率。<br>Guava 提供的 <a href="https://github.com/google/guava/blob/master/android/guava/src/com/google/common/hash/Funnels.java" target="_blank" rel="noopener">Funnels</a> 类拥有 5 个静态方法（byteArrayFunnel、unencodedCharsFunnel、stringFunnel、integerFunnel、longFunnel）提供了将 byte 数组、CharSequence、Integer、Long 插入到过滤器的 Funnel 接口的实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Creating the BloomFilter</span></span><br><span class="line">BloomFilter bloomFilter = BloomFilter.create(Funnels.byteArrayFunnel(), <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Putting elements into the filter</span></span><br><span class="line"><span class="comment">// A BigInteger representing a key of some sort</span></span><br><span class="line">bloomFilter.put(bigInteger.toByteArray());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Testing for element in set</span></span><br><span class="line"><span class="keyword">boolean</span> mayBeContained = bloomFilter.mayContain(bitIntegerII.toByteArray());</span><br></pre></td></tr></table></figure>
</li>
<li><p>redis<br>redis 在 4.0 版本以后可通过插件的形式添加布隆过滤器，添加插件的方式见：<a href="https://github.com/RedisBloom/RedisBloom" target="_blank" rel="noopener">RedisBloom</a>，使用方法如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Create a new bloom filter by adding a new item:</span></span><br><span class="line">&gt; BF.ADD newFilter foo</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># Find out whether an item exists in the filter:</span></span><br><span class="line">&gt; BF.EXISTS newFilter foo</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">&gt; BF.EXISTS newFilter bar</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>标准的 Bloom Filter 是一种比较简单的数据结构，只支持插入和查找两种操作，若需要删除操作则可以使用 <code>Counting Bloom Filter</code>，其原理可以参见：<a href="https://cloud.tencent.com/developer/article/1136056" target="_blank" rel="noopener">Counting Bloom Filter 的原理和实现</a>。</p>
<hr>
<h2 id="Count–min-sketch"><a href="#Count–min-sketch" class="headerlink" title="Count–min sketch"></a>Count–min sketch</h2><p>Count–min sketch 用作数据流中事件的频率表，可以随时计算出数据流中某个元素出现的频率，该数据结构在一些高性能的 LFU 算法中有着重要的应用，如：<a href="https://arxiv.org/pdf/1512.00727.pdf" target="_blank" rel="noopener">W-TinyLFU</a> 等。</p>
<h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>Count–min sketch 的内部数据结构是一个二维数组 $count$，宽度 $w$，深度 $d$，此外还需要 $d$ 个两两独立的哈希函数 $h_1…h_d$，更新的时候，用这些哈希函数算出 $d$ 个不同的哈希值，然后把对应的行的值加上 $c$。<br><img src="/images/countmin-sketch-01.png" alt="Count–min sketch"></p>
<blockquote>
<p>这里取值是有讲究的：$w = \lceil \frac{e}{ε} \rceil$，$d = \lceil ln\frac{1}{δ} \rceil$，其中 $ε$ 和 $δ$ 表示在 $1 - δ$ 的概率下，总误差（所有元素查询误差的之和）小于 $ε$ 。</p>
</blockquote>
<p>当要查询某个元素的频率时，返回这个元素在不同哈希函数中的计数值中的最小值即可。</p>
<hr>
<h2 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h2><p>HyperLogLog 主要用于基数计数(cardinality counting)，即统计一个集合中不重复的元素个数，其特点是可以用非常小的空间对大量的数据进行基数计数。</p>
<p>举个例子，我们知道 bitmap 空间的利用率已经很高了，如果要统计 1 亿个数据的基数值，大约需要内存： $100000000/8/1024/1024 \approx 12M$，而 HyperLogLog 只需要不到 1K 内存就能做到。</p>
<p>当然要达到如此神奇结果还是需要代价的，HyperLogLog 统计的数据会有一定的误差，一般来说基数统计的误差越小，需要的内存空间也越大。</p>
<h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>HyperLogLog 实现原理基于 $n$ 次伯努利过程，想读懂算法的原理需要一定的概率论基础，感兴趣的同学可以阅读 《<a href="http://www.rainybowe.com/blog/2017/07/13/%E7%A5%9E%E5%A5%87%E7%9A%84HyperLogLog%E7%AE%97%E6%B3%95/index.html" target="_blank" rel="noopener">神奇的HyperLogLog算法</a>》 进一步学习，国外也有大牛通过动画方式 <a href="http://content.research.neustar.biz/blog/hll.html" target="_blank" rel="noopener">HLL Demo</a> 详细展示了 HyperLogLog 的计算过程。</p>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><ul>
<li><p>redis<br>redis 在 2.8.9 版本后原生实现了 HyperLogLog，只需要 12K 内存，在标准误差 0.81% 的前提下，能够统计 $2^{64}$​​ 个数据。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt; PFADD runoobkey <span class="string">"redis"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">&gt; PFADD runoobkey <span class="string">"mongodb"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">&gt; PFADD runoobkey <span class="string">"mysql"</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">&gt; PFCOUNT runoobkey</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure></li>
<li><p>druid<br>作为一个实时 OLAP 框架，druid 也使用 HyperLogLog 评估基数，一般有两种选择：</p>
<ul>
<li>Cardinality aggregator：只在查询时优化，不减少存储容量，效率比存储时预聚合的 HyperUnique aggregator 低<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"type"</span>: <span class="string">"cardinality"</span>,</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"&lt;output_name&gt;"</span>,</span><br><span class="line">  <span class="string">"fields"</span>: [ &lt;dimension1&gt;, &lt;dimension2&gt;, ... ],</span><br><span class="line">  <span class="string">"byRow"</span>: &lt;<span class="literal">false</span> | <span class="literal">true</span>&gt; <span class="comment"># (optional, defaults to false),</span></span><br><span class="line">  <span class="string">"round"</span>: &lt;<span class="literal">false</span> | <span class="literal">true</span>&gt; <span class="comment"># (optional, defaults to false)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>HyperUnique aggregator：在摄取时进行预计算，效率更高<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"type"</span> : <span class="string">"hyperUnique"</span>,</span><br><span class="line">  <span class="string">"name"</span> : &lt;output_name&gt;,</span><br><span class="line">  <span class="string">"fieldName"</span> : &lt;metric_name&gt;,</span><br><span class="line">  <span class="string">"isInputHyperUnique"</span> : <span class="literal">false</span>,</span><br><span class="line">  <span class="string">"round"</span> : <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>详情可移步<a href="http://druid.apache.org/docs/latest/querying/hll-old.html" target="_blank" rel="noopener">官网</a></p>
</li>
</ul>
<hr>
<h2 id="MinHash"><a href="#MinHash" class="headerlink" title="MinHash"></a>MinHash</h2><p>在数据挖掘中，一个最基本的问题就是比较两个集合的相似度。通常通过遍历这两个集合中的所有元素，统计这两个集合中相同元素的个数，来表示集合的相似度；这一步也可以看成特征向量间相似度的计算（欧氏距离，余弦相似度）。当这两个集合里的元素数量异常大（特征空间维数很大），同时又有很多个集合需要判断两两间的相似度时，传统方法会变得十分耗时，MinHash 可以用来解决该问题。</p>
<h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><ul>
<li><p>Jaccard 相似度<br><strong>Jaccard 相似度</strong> 是用来描述两个集合间的相似度的，假设有两个集合A、B，其计算公式如下：<br>$$Jaccard(A, B) = \frac{A \cap B}{A \cup B}$$<br>该公式表示 A 与 B 交集的元素个数除以 A 与 B 并集的元素个数。</p>
</li>
<li><p>k-Shingle<br>假如把一整篇文章看成一个长的字符串，那么 <strong>k-shingle</strong> 就是这篇文档中长度为 $k$ 的任意字符子串。</p>
<blockquote>
<p>例如：现在有一篇很短的文章，内容为 abcdabd，令 $k = 2$，那么这篇文章中所有的 2-shingle 组成的集合为 {ab,bc,cd,da,bd}。</p>
</blockquote>
<p>当 $k$ 的选择较小时，可以推测大部分长度为 $k$ 的字符串会出现在大部分的文档中，最终导致有很多 Jaccard 相似度很高的文档。比如在极端情况下 $k = 1$，大部分文档中都有很常见的字符，而其它字符相对较少，因此，几乎所有的 web 网页之间都有较高的 Jaccard 相似度。</p>
<p>$k$ 值的选择依赖于文档的典型长度以及典型的字符表大小，一般来说，$k$ 应该选择得足够大，以保证任意给定的 shingle 出现在任意文档中的概率最低。这里其实已经发现一个问题，<code>k-Shingle 会占用较大的内存空间</code>。</p>
<blockquote>
<p>假设 $k = 4$，那么每个 shingle 中就会有 4 个字符，存在内存中就至少需要 4 个字节，以这种方式存下一篇文章的所有 shingle，需要的内存空间大概是原文档大小的 4 倍。</p>
</blockquote>
</li>
<li><p>特征向量<br>原始的 shingle 集合不利于计算机去分析，所以需要把集合替换成规模小很多的 “<strong>特征</strong>“ 集合（one-hot 编码），这样就可以通过比较两篇文章的特征集合的相似度，就能够估计 shingle 集合的相似度。</p>
<p><strong>特征向量</strong> 一列就对应一个集合，所有的行加起来就是所有集合元素的全集，如果集合中有某个元素，则矩阵中的对应位置为 1，否则为 0。</p>
<blockquote>
<p>假设现在有 4 个集合：$S_1$，$S_2$，$S_3$，$S_4$，其中：$S_1 =  \left \{a, d \right \}$, $S_2 = \left \{c \right \}$, $S_3 = \left \{b, d, e \right \}$, $S_4 = \left \{a, c, d \right \}$，全集为：$U = \left \{a, b, c, d, e \right \}$，则 4 个集合的特征向量为：</p>
<table>
<thead>
<tr>
<th></th>
<th>$S_1$</th>
<th>$S_2$</th>
<th>$S_3$</th>
<th>$S_4$</th>
</tr>
</thead>
<tbody><tr>
<td>a</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>b</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>c</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>d</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>e</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
</tbody></table>
</blockquote>
</li>
<li><p>最小哈希函数<br>对海量文本而言，K-shingle 算法得到的特征向量是超高维的，导致该算法非常巨大的时间复杂度和空间复杂度。Minhash 算法设计了一种最小哈希函数，将原始超高维的稀疏向量转化为低维的稠密向量，降低了计算的空间复杂度。同时，对转换后的稠密向量进行分段索引，缩小潜在相似文本范围，降低了计算的时间复杂度。</p>
<p><strong>最小哈希函数</strong>：对一个列向量按行进行随机排列，重排后第一个非零元素的行号就是最小哈希函数值。直观上来说，<strong><code>如果两个文本完全重复，那么不论如何重排，两个文本对应的最小哈希函数值都应该是一样的</code></strong>。</p>
<blockquote>
<p>例如对原特征向量进行一次按行重排后得到的矩阵实例如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>$S_1$</th>
<th>$S_2$</th>
<th>$S_3$</th>
<th>$S_4$</th>
</tr>
</thead>
<tbody><tr>
<td>b</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>e</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>a</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>d</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>c</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
</tbody></table>
</blockquote>
<blockquote>
<p>对于列 $S_1$，从这一列的第一行往下走，直到遇到第一个 1，所在的行号则为这一列的最小哈希值，即：$h_{min}(S_1) = 2$，其它列最小哈希依次为 $h_{min}(S_2) = 4$，$h_{min}(S_3) = 0$，$h_{min}(S_4) = 2$</p>
</blockquote>
<p>上述的按行重排会重复 $N$ 次，最终会得到一个 $N$ 维的 Minhash 特征向量。</p>
<p>当一个特征向量很大时（假设有上亿行），那么对其进行行打乱是非常耗时，更要命的是还要进行多次行打乱，为了解决这个问题，可以通过一些<code>随机哈希函数</code>来模拟行打乱的效果。具体做法如下（假设有 $M$ 个集合，上面的例子中 $M$ = 4）:</p>
<ul>
<li>选择 $N$ 个随机哈希函数，假设为：$h_1$、$h_2$ … $h_n$</li>
<li>初始一个 $N$ 行（每一行对应一个随机哈希函数）$ M$ 列的最小哈希特征向量，值全部为 $inf$（无穷大），即：<table>
<thead>
<tr>
<th></th>
<th>$S_1$</th>
<th>…</th>
<th>$S_i$</th>
<th>…</th>
<th>$S_M$</th>
</tr>
</thead>
<tbody><tr>
<td>$h_1$</td>
<td>inf</td>
<td></td>
<td>inf</td>
<td></td>
<td>inf</td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>$h_j$</td>
<td>inf</td>
<td></td>
<td>inf</td>
<td></td>
<td>inf</td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>$h_N$</td>
<td>inf</td>
<td></td>
<td>inf</td>
<td></td>
<td>inf</td>
</tr>
</tbody></table>
</li>
<li>遍历原特征向量每一行，当第 $x$ 行 $y$ 列值为 0 时，跳过；值为 1 时，分别计算 $h_1(x)$、$h_2(x)$ … $h_N(x)$，将计算的 $N$ 个哈希值和最小哈希特征向量矩阵的第 $y$ 列原始值比较，如果哈希值小则替换原来值，否则保持原来值不变。</li>
</ul>
</li>
</ul>
<h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><ul>
<li>Java 版本 <a href="https://github.com/codelibs/minhash" target="_blank" rel="noopener">minhash</a></li>
<li>Python 版本 <a href="https://github.com/ekzhu/datasketch" target="_blank" rel="noopener">datasketch</a></li>
</ul>
<hr>
<h2 id="SimHash"><a href="#SimHash" class="headerlink" title="SimHash"></a>SimHash</h2><p>SimHash 是 google 用来处理海量文本去重的算法。SimHash 可以将一个文档转换成一个 64 位的字节，暂且称之为 <strong>特征值</strong>，然后判断重复只需要判断他们的特征值的距离是不是 &lt; n（根据经验这个 n 一般取值为 3），就可以判断两个文档是否相似。</p>
<h3 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h3><p>SimHash 特征值的生成图解如下：<br><img src="/images/simhash.jpg" alt="SimHash"><br>大致的计算流程为：</p>
<ul>
<li>将 Doc 进行关键词抽取(其中包括分词和计算权重)，抽取出 $n$ 个（feature，weight）对，记为：<br>$$feature\_weight\_pairs = [fw_1, fw_2, … , fw_n]$$<br>其中：$fw_i = (feature_i,weight_i)$</li>
<li>计算每个 feature 的哈希值，记为 ${H_f}_i = hash(feature_i)$，此时假设哈希函数生成的位数 $bits\_count = 6$<br>$$hash\_weight\_pairs =\begin{bmatrix}<br>({H_f}_1, weight_1), \\<br>({H_f}_2, weight_2), \\<br>… \\<br>({H_f}_n, weight_n)<br>\end{bmatrix}$$</li>
<li>然后对 $hash\_weight\_pairs$ 进行位的纵向累加，如果该位是 1，则 +weight，如果是 0，则 -weight，最后生成 $bits\_count$ 个数字，如图所示是 [13, 108, -22, -5, -32, 55]</li>
<li>[13,108,-22,-5,-32,55] -&gt; 110001，即正 1 负 0</li>
</ul>
<p>上图展示了计算文本特征值的计算方法，当判断两个文本是否相似还需要计算特征值的距离，一般采用的计算方法为计算它们的 <a href="https://blog.csdn.net/lskyne/article/details/8652404" target="_blank" rel="noopener">汉明距离</a>（Hamming distanc），这里不在具体阐述了。</p>
<h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><ul>
<li>C++ 版本 <a href="https://github.com/yanyiwu/simhash" target="_blank" rel="noopener">simhash</a></li>
<li>Golang 版本 <a href="https://github.com/yanyiwu/gosimhash" target="_blank" rel="noopener">gosimhash</a></li>
<li>Java 版本 <a href="https://github.com/xlturing/Simhash4J" target="_blank" rel="noopener">Simhash4J</a></li>
</ul>
<h3 id="和-Minhash-对比"><a href="#和-Minhash-对比" class="headerlink" title="和 Minhash 对比"></a>和 Minhash 对比</h3><table>
<thead>
<tr>
<th>步骤</th>
<th>Minhash</th>
<th>Simhash</th>
</tr>
</thead>
<tbody><tr>
<td>清洗文本</td>
<td>去标点、空格、特殊字符等</td>
<td>去标点、空格、特殊字符等</td>
</tr>
<tr>
<td>分隔词组</td>
<td>指定长度的滑动窗口取 Shingle 作为词组</td>
<td>分词结果作为词组</td>
</tr>
<tr>
<td>分隔词库</td>
<td>所有文本的互异词组的集合构成词库</td>
<td>无</td>
</tr>
<tr>
<td>提取特征值</td>
<td>基于词库计算文本的 one-hot 编码，再对文本的 one-hot 编码向量随机排列，取首个非零元素的下标，重复 N 次，得到 N 维向量作为文本特征</td>
<td>统计各词组词频，将各词组哈希为指定长度的01向量，将 0 改为 -1，按位与对应的词频相乘，再将所有词组的相乘结果按位相加，大于 0 映射为 1，否则映射为 0，得到的 01 向量作为文本特征</td>
</tr>
<tr>
<td>建立索引</td>
<td>将文本特征值分段，已各段为索引，指向具有该特征的文本 ID</td>
<td>将文本特征值分段，已各段为索引，指向具有该特征的文本 ID</td>
</tr>
<tr>
<td>生成候选</td>
<td>至少具有同一段相同特征的文本对作为候选</td>
<td>至少具有同一段相同特征的文本对作为候选</td>
</tr>
<tr>
<td>计算距离</td>
<td>计算后端文本对的同位元素相等概率，大于阈值认为是重复文本对</td>
<td>计算文本对的汉明距离，小于阈值认为是重复文本对</td>
</tr>
</tbody></table>
<ul>
<li>运行速度：Simhash &gt; Minhash</li>
<li>准确率：Minhash &gt; Simhash</li>
<li>召回率：Simhash &gt; Minhash</li>
</ul>
<p>工程应用上，海量文本用 Simhash，短文本用 Minhash</p>
<hr>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<p><a href="https://en.wikipedia.org/wiki/Category:Probabilistic_data_structures" target="_blank" rel="noopener">Probabilistic data structures</a><br><a href="https://zhuanlan.zhihu.com/p/72378274" target="_blank" rel="noopener">数学之美：布隆过滤器</a><br><a href="https://cloud.tencent.com/developer/article/1136056" target="_blank" rel="noopener">Counting Bloom Filter 的原理和实现</a><br><a href="https://www.cnblogs.com/cbkj-xd/p/12863619.html" target="_blank" rel="noopener">布隆过滤器(Bloom Filter)</a><br><a href="https://www.oschina.net/translate/guava-bloomfilter?print" target="_blank" rel="noopener">Google Guava 中的布隆过滤</a><br><a href="https://zhuanlan.zhihu.com/p/84688298" target="_blank" rel="noopener">Count-Min Sketch</a><br><a href="http://www.rainybowe.com/blog/2017/07/13/%E7%A5%9E%E5%A5%87%E7%9A%84HyperLogLog%E7%AE%97%E6%B3%95/index.html" target="_blank" rel="noopener">神奇的HyperLogLog算法</a><br><a href="https://www.jianshu.com/p/535c537a5766" target="_blank" rel="noopener">2018-11-15-MinHash原理</a><br><a href="http://yanyiwu.com/work/2014/01/30/simhash-shi-xian-xiang-jie.html" target="_blank" rel="noopener">simhash算法原理及实现</a><br><a href="https://zhuanlan.zhihu.com/p/43640234" target="_blank" rel="noopener">文本去重算法：Minhash/Simhash/Klongsent</a><br><a href="https://www.cnblogs.com/bourneli/archive/2013/04/04/2999767.html" target="_blank" rel="noopener">利用Minhash和LSH寻找相似的集合</a></p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>概率</tag>
      </tags>
  </entry>
  <entry>
    <title>工作中常用的加密算法介绍</title>
    <url>/2020/05/04/encrypt-algo/</url>
    <content><![CDATA[<p>作为一个开发者，我们总会接触到诸如 <code>接口鉴权</code>、<code>https</code>、<code>数字签名</code>、<code>数字证书</code> 甚至近两年特别火的话题 - <code>区块链</code> 等，这里面的核心技术便是密码学相关的知识，本文将介绍我们在工作中经常用到的四类加密算法：<code>密码散列函数</code>（Cryptographic Hash Function）、<code>消息认证码</code>（Message Authentication Codes, MACs）、<code>对称加密算法</code>（Symmetric Key Algorithms）、<code>非对称加密</code>（Asymmetric Key Algorithms）、<code>认证加密</code>（Authenticated Encryption, AE）。</p>
<a id="more"></a>

<hr>
<h2 id="一些基本概念介绍"><a href="#一些基本概念介绍" class="headerlink" title="一些基本概念介绍"></a>一些基本概念介绍</h2><h3 id="☞-机密性（confidentiality）-防泄露"><a href="#☞-机密性（confidentiality）-防泄露" class="headerlink" title="☞ 机密性（confidentiality）- 防泄露"></a>☞ 机密性（confidentiality）- 防泄露</h3><p>一提到加密，大家的直观感受就是保证明文数据没办法被直接解读，这个就是机密性，为了实现机密性，密码算法都需需要密钥。</p>
<h3 id="☞-完整性（integrity）-防篡改"><a href="#☞-完整性（integrity）-防篡改" class="headerlink" title="☞ 完整性（integrity）- 防篡改"></a>☞ 完整性（integrity）- 防篡改</h3><p>为了防止有人对数据进行了修改，一般使用的技术包括：<code>密码散列函数</code>、<code>消息认证码</code>、<code>数字签名</code>等。</p>
<h3 id="☞-真实性（authenticity）-防伪装"><a href="#☞-真实性（authenticity）-防伪装" class="headerlink" title="☞ 真实性（authenticity）- 防伪装"></a>☞ 真实性（authenticity）- 防伪装</h3><p>为了防止伪装以保证数据发送方的身份，一般使用的技术包括：<code>消息认证码</code>、<code>数字签名</code>等。</p>
<h3 id="☞-不可否认性（Non-repudiation）-防否认"><a href="#☞-不可否认性（Non-repudiation）-防否认" class="headerlink" title="☞ 不可否认性（Non-repudiation）- 防否认"></a>☞ 不可否认性（Non-repudiation）- 防否认</h3><p>确认数据只能来自指定的发送方，其他人无法伪造，一般使用的技术包括：<code>数字签名</code>等。</p>
<h3 id="☞-加密方式分类"><a href="#☞-加密方式分类" class="headerlink" title="☞ 加密方式分类"></a>☞ 加密方式分类</h3><table width="307.65" border="0" cellpadding="0" cellspacing="0" style='width:307.65pt;border-collapse:collapse;table-layout:fixed;'>
   <col width="112.50" style='mso-width-source:userset;mso-width-alt:4800;'/>
   <col width="109.15" style='mso-width-source:userset;mso-width-alt:4657;'/>
   <tr height="29" style='height:29.00pt;mso-height-source:userset;mso-height-alt:580;'>
    <td class="xl65" width="112.50" style='width:112.50pt;border:.5pt solid windowtext;font-weight: bold;' x:str>按密钥特征分类</td>
    <td class="xl66" width="109.15" style='width:109.15pt;border:.5pt solid windowtext;font-weight: bold;' x:str>按照加密方式分类</td>
   </tr>
   <tr height="21" style='height:21.00pt;mso-height-source:userset;mso-height-alt:420;'>
    <td class="xl67" rowspan="2" style='border:.5pt solid windowtext;' x:str>对称加密</td>
    <td class="xl67" style='border:.5pt solid windowtext;' x:str>流密码</td>
   </tr>
   <tr height="18" style='height:18.00pt;mso-height-source:userset;mso-height-alt:360;'>
    <td class="xl68" rowspan="3" style='border:.5pt solid windowtext;' x:str>分组密码</td>
   </tr>
   <tr height="13.60" style='height:13.60pt;'>
    <td class="xl67" rowspan="2" style='border:.5pt solid windowtext;border-bottom:.5pt solid windowtext' x:str>非对称加密</td>
   </tr>
  </table>

<blockquote>
<p>注：<strong>分组密码</strong>（<a href="https://en.wikipedia.org/wiki/Block_cipher" target="_blank" rel="noopener">Block Cipher Algorithms</a>），只能加密固定长度的分组，若要加密变长数据，则数据必须先被划分为一些单独的密码块；<br><strong>流密码</strong>（<a href="https://en.wikipedia.org/wiki/Stream_cipher" target="_blank" rel="noopener">Stream Cipher Algorithms</a>），是一种对称加密算法（也就是说非对称加密均为分组密码），加密时候，先由种子密钥生成一个密钥流，加密和解密双方使用相同伪随机加密数据流（pseudo-random stream）作为密钥，明文数据每次与密钥数据流顺次对应加密，得到密文数据流。实践中数据通常是一个位（bit）并用异或（xor）操作加密。</p>
</blockquote>
<h3 id="☞-分组密码工作模式"><a href="#☞-分组密码工作模式" class="headerlink" title="☞ 分组密码工作模式"></a>☞ 分组密码工作模式</h3><p>分组密码 <code>工作模式</code> 描述了如何重复加密比较长的多个数据块，工作模式为许多国家和国内的标准认证实体所定义，其中最有影响力的来源是美国的NIST。</p>
<p>常见的保证机密性的工作模式有：</p>
<ul>
<li><strong>ECB</strong>：Electronic CodeBook mode（电子密码模式）</li>
<li><strong>CBC</strong>：Cipher Block Chaining mode（密码分组链接模式）</li>
<li><strong>CFB</strong>：Cipher FeedBack mode（密文反馈模式）</li>
<li><strong>OFB</strong>：Output FeedBack mode（输出反馈模式）</li>
<li><strong>CTR</strong>：CounTeR mode（计数器模式）</li>
</ul>
<p>保证完整性和真实性常见的工作模式有：</p>
<ul>
<li><strong>HMAC</strong>：2002 年被标准化，<a href="https://csrc.nist.gov/csrc/media/publications/fips/198/archive/2002-03-06/documents/fips-198a.pdf" target="_blank" rel="noopener">FIPS 198</a></li>
<li><strong>CMAC</strong>：2005 年被标准化，<a href="https://csrc.nist.gov/publications/detail/sp/800-38b/archive/2005-05-01" target="_blank" rel="noopener">SP 800-38B</a></li>
<li><strong>GMAC</strong>：2007 年被标准化，<a href="https://csrc.nist.gov/publications/detail/sp/800-38d/final" target="_blank" rel="noopener">SP 800-38D</a></li>
</ul>
<p>常见的认证加密（AE）模式有：</p>
<ul>
<li><strong>CCM</strong>：2004 年被标准化，<a href="https://csrc.nist.gov/publications/detail/sp/800-38c/final" target="_blank" rel="noopener">SP 800-38C</a></li>
<li><strong>GCM</strong>：2007 年被标准化，<a href="https://csrc.nist.gov/publications/detail/sp/800-38d/final" target="_blank" rel="noopener">SP 800-38D</a></li>
<li><strong>CWC</strong>：</li>
<li><strong>EAX</strong>：</li>
<li><strong>IAPM</strong>：</li>
<li><strong>OCB</strong>：</li>
</ul>
<h3 id="☞-分组密码填充方式分类"><a href="#☞-分组密码填充方式分类" class="headerlink" title="☞ 分组密码填充方式分类"></a>☞ 分组密码填充方式分类</h3><p>分组密码中，需要将明文按指定大小进行分组，由于明文并非指定大小的整数倍，因此在明文的最后一个分组需要通过 <code>填充方式</code> 将其填充至加密算法所要求的分组大小后进行加密，常见的填充方式有：</p>
<ul>
<li><strong>NoPadding</strong>：不填充，在此填充下原始数据必须是分组大小的整数倍，非整数倍时无法使用该模式</li>
<li><strong>PKCS5Padding / PKCS7Padding</strong>：填充至符合块大小的整数倍，填充值为填充数量数</li>
<li><strong>ISO10126Padding</strong>：填充至符合块大小的整数倍，填充值最后一个字节为填充的数量数，其他字节随机处理</li>
<li><strong>ISO7816-4Padding</strong>：填充至符合块大小的整数倍，填充值第一个字节为 0x80，其他字节填 0</li>
<li><strong>ZeroBytePadding</strong>：填充至符合块大小的整数倍，填充值为 0</li>
<li><strong>X923Padding</strong>：填充至符合块大小的整数倍，填充值最后一个字节为填充的数量数，其他字节填 0</li>
<li><strong>TBCPadding（Trailing-Bit-Compliment）</strong>：填充至符合块大小的整数倍，原文最后一位为 “1”时填充 0x00，最后一位为 “0” 时填充 “0xFF”</li>
<li><strong>PKCS1Padding</strong>：该填充模式是 RSA 加密中使用的，详见 <a href="https://tools.ietf.org/html/rfc2313" target="_blank" rel="noopener">RFC2313</a></li>
</ul>
<hr>
<p>这里介绍一下 CTR 计数器模式，在计数器模式下，我们不再对密文进行加密，而是对一个逐次累加的计数器进行加密，用加密后的比特序列与明文分组进行 XOR得到密文。过程如下图：</p>
<p><img src="/images/encrypt/ctr.png" alt="CTR"></p>
<hr>
<h2 id="密码散列函数"><a href="#密码散列函数" class="headerlink" title="密码散列函数"></a>密码散列函数</h2><p>密码散列函数是一种可以将任意的数据映射为某一固定长度的字符串（一般称为消息摘要，Message Digest，或哈希值，Hash Value）的函数，改函数具有如下的特点：</p>
<ul>
<li>确定性，同样的数据计算的 hash 值是固定的</li>
<li>给定原数据可以很快计算出 hash 值</li>
<li>无法根据 hash 值计算出原数据</li>
<li>两个不同的原数据只有极低的几率会产生相同的 hash 值</li>
<li>对原数据进行很小的更改会导致 hash 值发生改变，同时新的 hash 值看起来与旧的 hash 值不相关</li>
</ul>
<p>密码散列函数有着丰富的应用场景，如：<code>数字签名</code>（digital signatures）、<code>消息认证码</code>（message authentication codes, MACs）、<code>区块链</code>（Block Chain）等，同时还可以用作普通的哈希函数，为哈希表中的数据建立索引、进行指纹识别、检测重复数据或唯一标识文件等。</p>
<p>常用算法有：MD5、SHA-1、RIPEMD-160、bcrypt、Whirlpool、SHA-2、SHA-3、BLAKE2、BLAKE3、SM3 等</p>
<h3 id="☞-MD5"><a href="#☞-MD5" class="headerlink" title="☞ MD5"></a>☞ MD5</h3><p>英文全称是 Message Digest Algorithm MD5，译为 <code>消息摘要算法第五版</code>，在 <a href="https://tools.ietf.org/html/rfc1321" target="_blank" rel="noopener">RFC 1321</a> 中被标准化，MD5 广泛使用在为文件传输提供一定的可靠性，在很多系统中也作为保护密码的一种方式，但这种方式已经不建议使用了，密码的保护还是建议采用更为安全的 bcrypt 算法。</p>
<h3 id="☞-SHA-1"><a href="#☞-SHA-1" class="headerlink" title="☞ SHA-1"></a>☞ SHA-1</h3><p>英文全称是 Secure Hash Algorithm 1，译为 <code>安全散列算法1</code>，该算法由美国国家安全局设计，并由美国国家标准技术研究所（NIST）发布为联邦数据处理标准（FIPS）[1995年]。SHA-1 可以生成一个被称为消息摘要的 160 位（20字节）散列值，散列值通常的呈现形式为 40 个十六进制数。</p>
<p>2005 年，密码分析人员发现了对 SHA-1 的有效攻击方法，这表明该算法可能不够安全，不能继续使用，自 2010 年以来，许多组织建议用 SHA-2 或 SHA-3 来替换 SHA-1</p>
<h3 id="☞-SHA-2"><a href="#☞-SHA-2" class="headerlink" title="☞ SHA-2"></a>☞ SHA-2</h3><p>英文全称是 Secure Hash Algorithm 2，译为 <code>安全散列算法2</code>，同样是由美国国家安全局设计，并由美国国家标准技术研究所（NIST）发布为联邦数据处理标准（FIPS）[2001年]。</p>
<p>根据摘要长度，SHA-2 衍生出来的算法有：SHA-224、SHA-256、SHA-384、SHA-512、SHA-512/224、SHA-512/256。</p>
<h3 id="☞-SHA-3"><a href="#☞-SHA-3" class="headerlink" title="☞ SHA-3"></a>☞ SHA-3</h3><p>英文全称是 Secure Hash Algorithm 3，译为 <code>安全散列算法3</code>，之前名为 Keccak 算法，SHA-3 在 2015 年 8 月 5 日由 NIST 通过 <a href="https://www.federalregister.gov/documents/2015/08/05/2015-19181/announcing-approval-of-federal-information-processing-standard-fips-202-sha-3-standard" target="_blank" rel="noopener">FIPS 202</a> 正式发表。SHA-3 当前并未大规模取代 SHA-2，因为 SHA-2 当前没有出现明显的弱点。由于对 MD5、SHA-0 和 SHA-1 出现成功的破解，NIST 感觉需要一个与之前算法不同的，可替换的加密散列算法，也就是现在的 SHA-3。</p>
<h3 id="☞-SM3"><a href="#☞-SM3" class="headerlink" title="☞ SM3"></a>☞ SM3</h3><p>SM3 是中国政府采用的一种密码散列函数标准，由 <code>国家密码管理</code> 局于 2010 年 12 月 17 日发布。相关标准为 <a href="http://www.oscca.gov.cn/sca/xxgk/2010-12/17/content_1002389.shtml" target="_blank" rel="noopener">“GM/T 0004-2012 《SM3密码杂凑算法》”</a>，其安全性及效率与 SHA-256 相当。</p>
<hr>
<h2 id="消息认证码"><a href="#消息认证码" class="headerlink" title="消息认证码"></a>消息认证码</h2><p>在开放的计算和通信世界中，我们会使用不可靠的媒介传输和存储信息，而对信息 <code>完整性</code> 和 <code>真实性</code> 的校验在某些情景下就十分重要。基于密钥作完整性校验的方法常称为消息认证码 (Message Authentication Code, MAC)，通常 MAC 在共享密钥的双方之间，校验相互传递的信息。</p>
<p>同密码散列函数相比，消息摘要只能保证消息的完整性，如果第三方修改了数据，然后进行散列，并一块发给接收方，接收方并不能察觉到数据被篡改的。<code>MAC 算法则能够保证消息的真实性，数据的发送方和接收方拥有相同的密钥，通过加密策略保证数据不会被第三方篡改</code>。</p>
<p>MAC 有很多实现方式，比较常用的是 基于 Hash 算法的 MAC，即 <code>HMAC</code>；基于分组密码的实现，比如 OMAC、CBC-MAC、PMAC、<a href="https://en.wikipedia.org/wiki/Galois/Counter_Mode" target="_blank" rel="noopener"><code>GMAC</code></a> 、<a href="https://en.wikipedia.org/wiki/Poly1305" target="_blank" rel="noopener"><code>Poly1305</code></a>。本文只介绍一下 HMAC、GCM 和 Poly1305 算法。</p>
<blockquote>
<p>注：在后面会介绍基于流密码 <a href="https://en.wikipedia.org/wiki/Salsa20" target="_blank" rel="noopener">ChaCha20</a> 和 Poly1305 实现的一种认证加密算法 <code>ChaCha20-Poly1305</code>（<a href="https://tools.ietf.org/html/rfc7539" target="_blank" rel="noopener">RFC7539</a>）。</p>
</blockquote>
<h3 id="☞-HMAC-RCF2104"><a href="#☞-HMAC-RCF2104" class="headerlink" title="☞ HMAC(RCF2104)"></a>☞ HMAC(<a href="https://tools.ietf.org/html/rfc2104" target="_blank" rel="noopener">RCF2104</a>)</h3><p>基于加密 Hash 算法实现，任何加密 Hash 比如 MD5、SHA1、SHA256、SHA512 等，都可以用来实现 HMAC 算法，其相应的算法称为 HMAC-MD5、HMAC-SHA1、HMAC-SHA256、HMAC-SHA512。HMAC 计算公式为：</p>
<p>$$ HMAC(K，M) = H(K \oplus opad ∣ H( K \oplus ipad ∣ M)) $$</p>
<p>其中：</p>
<ul>
<li>K 是密钥，长度可为 64 字节，若小于该长度，在密钥后面用 <code>0</code> 补齐</li>
<li>M 是消息内容</li>
<li>H 表示 Hash 函数</li>
<li>opad 和 ipad 分别是由若干个 0x5c 和 0x36 组成的字符串</li>
<li>$\oplus$ 表示异或运算</li>
<li>∣ 表示连接操作</li>
</ul>
<p>以 <code>HMAC-MD5</code> 为例，其计算流程如下：</p>
<blockquote>
<ol>
<li>在密钥 key 后面添加 0 来创建一个长为 64 字节的字符串 (str)，如果 key 超过 64 字节则使用 key 的 md5 代替 key，再在后面加 0 补齐 64 字节</li>
<li>将上一步生成的字符串 (str) 与 ipad(0x36) 做异或运算，形成结果字符串 (istr)</li>
<li>将消息内容 M 附加到第 2 步的结果字符串 (istr) 的末尾；</li>
<li>做 md5 运算于第 3 步生成的数据流(istr)；</li>
<li>将第 1 步生成的字符串 (str) 与 opad(0x5c) 做异或运算，形成结果字符串 (ostr)；</li>
<li>再将第 4 步的结果 (istr) 附加到第五步的结果字符串 (ostr) 的末尾；</li>
<li>做 md5 运算于第 6 步生成的数据流 (ostr)，输出最终结果 </li>
</ol>
</blockquote>
<p>Java 中计算 HMAC-MD5 如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">HMACMD5</span><span class="params">(String s, String keyString)</span> </span>&#123;</span><br><span class="line">  String res = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    SecretKeySpec key = <span class="keyword">new</span> SecretKeySpec((keyString).getBytes(<span class="string">"UTF-8"</span>), <span class="string">"HmacMD5"</span>);</span><br><span class="line">    Mac mac = Mac.getInstance(<span class="string">"HmacMD5"</span>);</span><br><span class="line">    mac.init(key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] bytes = mac.doFinal(s.getBytes(<span class="string">"ASCII"</span>));</span><br><span class="line"></span><br><span class="line">    StringBuffer hash = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bytes.length; i++) &#123;</span><br><span class="line">      String hex = Integer.toHexString(<span class="number">0xFF</span> &amp;  bytes[i]);</span><br><span class="line">      <span class="keyword">if</span> (hex.length() == <span class="number">1</span>) &#123;</span><br><span class="line">          hash.append(<span class="string">'0'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      hash.append(hex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res = hash.toString();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">  &#125; <span class="keyword">catch</span>(InvalidKeyException e)&#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure>

<h3 id="☞-GMAC"><a href="#☞-GMAC" class="headerlink" title="☞ GMAC"></a>☞ GMAC</h3><p>GMAC 是利用伽罗华域（Galois Field，GF，有限域）乘法运算来计算消息的 MAC 值。假设秘钥长度为 128bits, 当密文大于 128bits 时，需要将密文按 128bits 进行分组。应用流程如下图：</p>
<p><img src="/images/encrypt/gmac.png" alt="GMAC"></p>
<p>其中，Mh 表示将输入与秘钥 h 在有限域 $GF(2^{128})$ 上做乘法。</p>
<p>GMAC 是 </p>
<h3 id="☞-Poly1305"><a href="#☞-Poly1305" class="headerlink" title="☞ Poly1305"></a>☞ Poly1305</h3><p>Poly1305 是 D. J. Bernstein 设计的一种 MAC 算法，它需要一个 32 字节的一次性密钥和一条消息以产生用于认证消息的 16 字节的标签。最初的设计是基于 AES 加密算法实现，Google 在 2014 年选择了 Poly1305 和 ChaCha20 对称加密算法（也是 Bernstein 提出的，大牛就是大牛）替换了 TLS/SSL 中的 RC4 算法，这种设计最终也成为了 RFC 标准：<a href="https://tools.ietf.org/html/rfc7539" target="_blank" rel="noopener">RFC7539</a>。</p>
<p>Poly1305-AES 的算法实现可以参考：<a href="http://cr.yp.to/mac.html" target="_blank" rel="noopener">http://cr.yp.to/mac.html</a>，该网站提供了基于 C++、Python、Perl 语言的实现源码。</p>
<hr>
<h2 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h2><p>对称加密算法是应用较早的加密算法，技术成熟，其特点计算加密和解密使用相同的密钥，主要的算法有 DES、3DES、AES、RC4 和 Salsa20/Chacha20 、SM1、SM4、SM7、祖冲之算法(ZUC) 等，其中 DES、3DES、AES、SM1、SM4、SM7 属于分组密码，RC4、Salsa20/Chacha20、祖冲之算法(ZUC) 属于流密码。</p>
<h3 id="☞-DES-3DES"><a href="#☞-DES-3DES" class="headerlink" title="☞ DES/3DES"></a>☞ DES/3DES</h3><p>DES 全称为 Data Encryption Standard，即数据加密标准，1977 年被美国联邦政府的国家标准局确定为联邦资料处理标准（FIPS）。3DES 是对 DES 的一种改良算法，针对 DES 算法密钥短，迭代次数少的缺点做了改进。但是 3DES 算法速度慢，密钥计算时间长，加密效率不高，实际使用也不多。</p>
<p>JDK 仅支持 56 位的密钥长度（出口限制），对称加密系列算法的特点是：密钥长度越高安全性越高，因此 JDK 本身自带的 DES 和 3DES 算法仅适合学术和一般场景使用，Bouncy Castle 提供了 64 位密钥长度的支持。</p>
<h3 id="☞-AES"><a href="#☞-AES" class="headerlink" title="☞ AES"></a>☞ AES</h3><p>AES 全称 Advanced Encryption Standard，即高级加密标准，由美国国家标准与技术研究院（NIST）于 2001 年 11 月 26 日发布为联邦数据处理标准（FIPS），这个标准用来替代原先的DES，已经被多方分析且广为全世界所使用。</p>
<p>AES 的密钥长度为 128、192 或者 256 位，分组长度 128 位，由于进口管制限制，JDK 默认是不允许 256 位密钥的 AES 加解密的，解决方法就下载官方JCE无限制强度加密策略文件，覆盖即可。</p>
<p>JDK6的下载地址：<br><a href="http://www.oracle.com/technetwork/java/javase/downloads/jce-6-download-429243.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/jce-6-download-429243.html</a></p>
<p>JDK7的下载地址：<br><a href="http://www.oracle.com/technetwork/java/javase/downloads/jce-7-download-432124.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/jce-7-download-432124.html</a></p>
<p>JDK8的下载地址：<br><a href="http://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html</a></p>
<p>但从 Java 1.8.0_151 和 1.8.0_152 开始，为 JVM 启用无限制强度管辖策略有了一种更简单的方法：在 jre/lib/security 文件夹中查找文件 java.security，现在用文本编辑器打开 java.security，并找到定义 java 安全性属性 crypto.policy 的行，它可以有两个值l imited 或 unlimited - 默认值是 limited。将其设置为：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">crypto.policy=unlimited</span><br></pre></td></tr></table></figure>

<h3 id="☞-SM1-SM4-SM7"><a href="#☞-SM1-SM4-SM7" class="headerlink" title="☞ SM1/SM4/SM7"></a>☞ SM1/SM4/SM7</h3><p>均为国家商用密码管理办公室制定的对称分组加密标准，其中：</p>
<p>SM1 算法是分组密码算法，分组长度为 128 位，密钥长度都为 128 比特，算法安全保密强度及相关软硬件实现性能与 AES 相当，算法不公开，仅以IP 核的形式存在于芯片中。</p>
<p>SM4 用于无线局域网产品。该算法的分组长度为 128 位，密钥长度为 128 比特。加密算法与密钥扩展算法都采用 32 轮非线性迭代结构。解密算法与加密算法的结构相同，只是轮密钥的使用顺序相反，解密轮密钥是加密轮密钥的逆序。详情可参考：<a href="http://www.sca.gov.cn/sca/c100061/201611/1002423/files/330480f731f64e1ea75138211ea0dc27.pdf" target="_blank" rel="noopener">无线局域网产品使用的 SMS4 密码算法</a>。</p>
<p>SM7 分组长度为 128 比特，密钥长度为 128 比特。SM7 适用于非接触式 IC 卡，应用包括身份识别类应用(门禁卡、工作证、参赛证)，票务类应用(大型赛事门票、展会门票)，支付与通卡类应用（积分消费卡、校园一卡通、企业一卡通等）。</p>
<p>SM1、SM7 算法不公开，调用该算法时，需要通过加密芯片的接口进行调用。</p>
<h3 id="☞-chacha20"><a href="#☞-chacha20" class="headerlink" title="☞ chacha20"></a>☞ chacha20</h3><p>基于 <a href="https://zh.wikipedia.org/wiki/Salsa20" target="_blank" rel="noopener">Salsa20</a> 算法，Salsa20 是一种流加密算法，由丹尼尔·J·伯恩斯坦设计，它创建在基于 add-rotate-xor（ARX）操作的伪随机函数之上（32位模加、异或和循环移位操作），Salsa20 映射一个 256 位密钥、一个 64位 nonce 以及一个 64 位流位置到一个 512 位的输出（也存在一个 128 位密钥的版本），这使 Salsa20 具有了不同寻常的优势，用户可以在恒定时间内寻求输出流中的任何位置。</p>
<p>在 2008 年，丹尼尔·J·伯恩斯坦发布了一个密切相关的 “ChaCha” 密码家族，其目的是增加每一轮的扩散以实现相同或稍微提升的性能。</p>
<p>Google 选择了伯恩斯坦设计的，带 Poly1305 消息认证码的 ChaCha20，作为 OpenSSL 中 RC4 的替代品，用以完成互联网的安全通信。不久之后，Google 在 TLS 中采用它，ChaCha20 和 Poly1305 算法也以 <a href="mailto:chacha20-poly1305@openssh.com">chacha20-poly1305@openssh.com</a> 成为 OpenSSH 中的一个新密码包。在没有 AES 指令集的低端 CPU 上，ChaCha20 的性能较 AES 高。</p>
<h3 id="☞-ZUC-祖冲之算法"><a href="#☞-ZUC-祖冲之算法" class="headerlink" title="☞ ZUC 祖冲之算法"></a>☞ ZUC 祖冲之算法</h3><p>祖冲之序列密码算法是中国自主研究的流密码算法,是运用于移动通信 4G 网络中的国际标准密码算法,该算法包括祖冲之算法(ZUC)、加密算法(128-EEA3)和完整性算法(128-EIA3)三个部分。目前已有对ZUC算法的优化实现，有专门针对 128-EEA3 和 128-EIA3 的硬件实现与优化。</p>
<hr>
<h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><p>全称 Asymmetric cryptography，是密码学的一种算法，它需要两个密钥，一个是 <code>公开密钥</code>，另一个是 <code>私有密钥</code>；公钥用作加密，私钥则用作解密。使用公钥把明文加密后所得的密文，只能用相对应的私钥才能解密并得到原本的明文，最初用来加密的公钥不能用作解密。基于公开密钥加密的特性，它还能提供 <code>数字签名</code> 的功能，使电子文件可以得到如同在纸本文件上亲笔签署的效果。</p>
<p>常见的公钥加密算法有：RSA、ECC、SM2、双线性映射、SM9等。</p>
<h3 id="☞-RSA"><a href="#☞-RSA" class="headerlink" title="☞ RSA"></a>☞ RSA</h3><p>RSA 是由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）在 1977 年一起提出的，RSA就是三个人名字首字母。RSA 的安全性是基于 <code>对大质数进行因式分解过于困难保证的</code>，因而 RSA 的密钥一般非常长，目前来说 1024 位的RSA密钥基本安全，2048 位的密钥极其安全。</p>
<h3 id="☞-ECC"><a href="#☞-ECC" class="headerlink" title="☞ ECC"></a>☞ ECC</h3><p>全称 Elliptic Curves Cryptography，即椭圆曲线密码，是一种基于椭圆曲线数学的公开密钥加密算法，关于椭圆曲线的理论知识可以阅读《椭圆曲线密码学导论》。ECC 的主要优势是它相比 RSA 加密算法使用较小的密钥长度并提供相当等级的安全性。</p>
<h3 id="☞-SM2"><a href="#☞-SM2" class="headerlink" title="☞ SM2"></a>☞ SM2</h3><p>SM2 是国家密码管理局于 2010 年 12 月 17 日发布的椭圆曲线公钥密码算法，加密强度为 256 位，是一种椭圆曲线算法，相关标准为 <a href="http://www.oscca.gov.cn/sca/xxgk/2012-11/22/content_1002397.shtml" target="_blank" rel="noopener">“《SM2椭圆曲线公钥密码算法》</a>“。</p>
<h3 id="☞-双线性映射"><a href="#☞-双线性映射" class="headerlink" title="☞ 双线性映射"></a>☞ 双线性映射</h3><p>全称 Bilinear Pairing，可以实现 <code>基于身份的加密方案</code>（Identity Based Encryption, IBE），IBE 的公钥不是从公钥证书中获得，而是直接用标志自己身份信息的任意长度字符串作为公钥，比如姓名、邮箱地址、IP地址等，与传统的公钥密码体制相比，基于身份的加密体制不需要专门的认证机构，减少了证书分发与管理的复杂性。</p>
<h3 id="☞-SM9"><a href="#☞-SM9" class="headerlink" title="☞ SM9"></a>☞ SM9</h3><p>SM9 是由国密局发布的一种 IBE 算法，SM9 是基于 256 位的 BN 椭圆曲线的，使用有限域 $ \mathbb{F}_{p^2} $ 和素域 $ \mathbb{F}_p $ ，双线性对使用 R-ate。</p>
<hr>
<h2 id="认证加密"><a href="#认证加密" class="headerlink" title="认证加密"></a>认证加密</h2><p>认证加密（Authenticated Encryption, AE）是一种加密形式，它能同时保证数据的 <code>机密性</code>、<code>完整性</code>和 <code>真实性</code>。在实际中推荐使用的是它的一个变体 - <code>关联数据的认证加密</code>（Authenticated Encryption with Associated Data, <code>AEAD</code>），除了拥有 AE 的特性，它还可以提供对未加密的 <code>关联数据</code>（Associated Data）的完整性保证。</p>
<p>AEAD 产生的原因很简单，单纯的对称加密算法，其解密步骤是无法确认密钥是否正确的，也就是说，加密后的数据可以用任何密钥执行解密运算，得到一组疑似原始数据。</p>
<p>为了构造更加安全的算法，密码学领域一开始使用了组合密码的形式，即通过 <code>加密</code> 实现 <code>机密性</code>，通过 <code>MAC</code> 进行消息认证以保证消息的 <code>完整性</code> 和 <code>真实性</code>，基于该思路产生了以下几种方案：</p>
<ul>
<li>EtM (Encryption then MAC)</li>
<li>E&amp;M (Encryption and MAC)</li>
<li>MtE (MAC then Encryption)</li>
</ul>
<p>通过这种组合的方式也引入和很多的安全漏洞，2008 年密码学界逐渐提出了「用一个算法在内部同时实现加密和认证」的想法，也就是 AEAD，常用的 AEAD 算法有：<code>AES128/256_GCM</code>、AES128/256_EAX、AES128/256_CTR_HMAC_SHA256、<code>CHACHA20_POLY1305</code> 等</p>
<h3 id="☞-AES-GCM-vs-CHACHA20-POLY1305"><a href="#☞-AES-GCM-vs-CHACHA20-POLY1305" class="headerlink" title="☞ AES-GCM vs CHACHA20_POLY1305"></a>☞ AES-GCM vs CHACHA20_POLY1305</h3><p>对于 AES 这样的块加密算法来说，在某些硬件上运行的非常快，比如现在的服务器和台式机都有 <code>AES-NI</code> 加速指令。而如果没有加速指令，纯粹通过软件运行，性能是很低的。</p>
<p>而流密码算法刚好反过来，软件实现性能更高，大部分移动设备（比如手机）由于没有 AES-NI 支持，运行 AES 加密是很缓慢的。大部分观点认为，在移动设备上（没有 AES-NI 指令），ChaCha20-Poly1305 算法的性能是 AES-128-GCM 的三倍；当然在台式机和服务器上，AES-128-GCM 性能比 ChaCha20-Poly1305 更高。</p>
<hr>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<p><a href="https://en.wikipedia.org/wiki/Cryptographic_hash_function" target="_blank" rel="noopener">Cryptographic hash function</a><br><a href="https://zh.wikipedia.org/wiki/%E8%A8%8A%E6%81%AF%E9%91%91%E5%88%A5%E7%A2%BC" target="_blank" rel="noopener">消息认证码</a><br><a href="https://blog.csdn.net/l243224118/article/details/83932434" target="_blank" rel="noopener">消息认证码(MAC)解读</a><br><a href="http://www.flydean.com/hmac/" target="_blank" rel="noopener">HMAC算法及其应用</a><br><a href="https://blog.csdn.net/mutourend/article/details/100578436" target="_blank" rel="noopener">密码学中的AEAD(authenticated encryption with associated data)</a><br><a href="https://www.jianshu.com/p/4ca48cfeb4f4" target="_blank" rel="noopener">Java 11的新加密算法ChaCha20-Poly1305</a><br><a href="https://www.jianshu.com/p/9e46908750de" target="_blank" rel="noopener">HTTP协议-19.对称加密与非对称加密、数字签名与证书</a><br><a href="https://docs.aws.amazon.com/crypto/latest/userguide/cryptography-concepts.html" target="_blank" rel="noopener">Cryptography concepts</a><br><a href="https://www.jianshu.com/p/16e1cbc0b7a9" target="_blank" rel="noopener">分组密码算法的填充模式</a><br><a href="https://www.cnblogs.com/davidwang456/p/8386933.html" target="_blank" rel="noopener">分组密码的工作模式–wiki</a><br><a href="https://www.jianshu.com/p/dd5050c676d2" target="_blank" rel="noopener">DES/3DES算法 – 算法介绍</a><br><a href="https://www.jianshu.com/p/8c3657a1769f" target="_blank" rel="noopener">【易错概念】国密算法SM1（SCB2）、SM2、SM3、SM4、SM7、SM9、ZUC</a></p>
</blockquote>
]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>加密</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA 11</title>
    <url>/2020/04/25/java11/</url>
    <content><![CDATA[<p>Oracle 在 2014 年 3 月发布了 Java 8 正式版，5 年之后的 2018年 9 月，Java 11 正式版也和广大的 java 开发者见面，作为 Java8 后的首个长期支持版本，Java 11 也逐渐得到了开发者的青睐。根据 <a href="https://blog.newrelic.com/technology/state-of-java/" target="_blank" rel="noopener">New Relic</a> 发布的数据显示，截至 2020 年 3 月，Java 8 的使用量高达 <code>84.48%</code>，Java 11 则是 <code>11.11%</code>。</p>
<p>尽管普及程度还远远达不到 Java 8 的标准，但 Java 11 带来的各方面提升还是非常具有吸引力的，本文也将介绍在 Java 8 基础上 Java 11 都带了哪些新特性和性能提升。</p>
<a id="more"></a>

<hr>
<h2 id="为什么关注-Java-11"><a href="#为什么关注-Java-11" class="headerlink" title="为什么关注 Java 11"></a>为什么关注 Java 11</h2><p>从今天 Java 8 的普及程度我们大概可以预测 Java 11 的前景，作为 Java8 后的首个长期支持版本，技术支持时间直到 2023 年 9 月份，补丁和扩展支持直到 2026 年 9 月份（详情见：<a href="https://www.oracle.com/java/technologies/java-se-support-roadmap.html" target="_blank" rel="noopener">Oracle Java SE Support Roadmap</a>）。</p>
<p><img src="/images/jdk11/roadmap.png" alt="java-roadmap"></p>
<hr>
<h2 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h2><p>11 和 8 之间还经历了 2 个版本，虽然不是长期支持的版本，但还是要简单介绍一下。在介绍新特性之前我们先了解两个概念：</p>
<ul>
<li><strong>JSR</strong>：Java Specification Requests，Java 规范请求，由 JCP（Java Community Process，由社会各界 Java 组成的社区）成员向委员会提交的 Java 发展议案，经过一系列流程后，如果通过最终会体现在未来的 Java 中</li>
<li><strong>JEP</strong>：JDK Enhancement Proposal，JDK 增强提案，目的在于鼓励 OpenJDK 提交者贡献点子和扩展以改进 OpenJDK 生态圈，详情可以在 <a href="https://openjdk.java.net/jeps/1" target="_blank" rel="noopener">官网</a> 查看</li>
</ul>
<h3 id="Java-9"><a href="#Java-9" class="headerlink" title="Java 9"></a>Java 9</h3><p>经过 4 次跳票，历经曲折的 Java 9 终于终于在 2017 年 9 月 21 日发布（距离上个版本足足3年半时间），Java 9 提供了超过 150 项新功能特性，包括备受期待的<code>模块化系统</code>、<code>可交互的 REPL 工具：jshell</code>，<code>JDK 编译工具</code>，<code>Java 公共 API 和私有代码</code>，以及<code>安全增强</code>、<code>扩展提升</code>、<code>性能管理改善</code>等，它的新特性来自于 100 余项 JEP 和 40 余项 JSR。主要的特性（<a href="https://www.jcp.org/en/jsr/detail?id=379" target="_blank" rel="noopener">JSR 379</a>）如下：</p>
<ul>
<li>Platform<ul>
<li><a href="http://openjdk.java.net/jeps/220" target="_blank" rel="noopener">Modular Run-Time Images</a></li>
<li><a href="http://openjdk.java.net/jeps/261" target="_blank" rel="noopener">Module System</a><a href="https://jcp.org/en/jsr/detail?id=376" target="_blank" rel="noopener">(JSR 376)</a></li>
<li><a href="http://openjdk.java.net/jeps/238" target="_blank" rel="noopener">Multi-Release JAR Files</a></li>
<li><a href="http://openjdk.java.net/jeps/223" target="_blank" rel="noopener">New Version-String Scheme</a></li>
<li><a href="http://openjdk.java.net/jeps/200" target="_blank" rel="noopener">The Modular JDK</a></li>
</ul>
</li>
<li>Language<ul>
<li><a href="http://openjdk.java.net/jeps/211" target="_blank" rel="noopener">Elide Deprecation Warnings on Import Statements</a></li>
<li><a href="http://openjdk.java.net/jeps/286" target="_blank" rel="noopener">Local-Variable Type Inference</a></li>
<li><a href="http://openjdk.java.net/jeps/213" target="_blank" rel="noopener">Milling Project Coin</a></li>
</ul>
</li>
<li>Core Libraries<ul>
<li><a href="http://openjdk.java.net/jeps/269" target="_blank" rel="noopener">Convenience Factory Methods for Collections</a></li>
<li><a href="http://openjdk.java.net/jeps/277" target="_blank" rel="noopener">Enhanced Deprecation</a></li>
<li><a href="http://openjdk.java.net/jeps/274" target="_blank" rel="noopener">Enhanced Method Handles</a></li>
<li><a href="http://openjdk.java.net/jeps/264" target="_blank" rel="noopener">Platform Logging API and Service</a></li>
<li><a href="http://openjdk.java.net/jeps/102" target="_blank" rel="noopener">Process API Updates</a></li>
<li><a href="http://openjdk.java.net/jeps/285" target="_blank" rel="noopener">Spin-Wait Hints</a></li>
<li><a href="http://openjdk.java.net/jeps/193" target="_blank" rel="noopener">Variable Handles</a></li>
</ul>
</li>
<li>Networking<ul>
<li><a href="http://openjdk.java.net/jeps/110" target="_blank" rel="noopener">HTTP/2 Client</a></li>
</ul>
</li>
<li>Security<ul>
<li><a href="http://openjdk.java.net/jeps/229" target="_blank" rel="noopener">Create PKCS12 Keystores by Default</a></li>
<li><a href="http://openjdk.java.net/jeps/273" target="_blank" rel="noopener">DRBG-Based SecureRandom Implementations</a></li>
<li><a href="http://openjdk.java.net/jeps/219" target="_blank" rel="noopener">Datagram Transport Layer Security (DTLS)</a></li>
<li><a href="http://openjdk.java.net/jeps/249" target="_blank" rel="noopener">OCSP Stapling for TLS</a></li>
<li><a href="http://openjdk.java.net/jeps/244" target="_blank" rel="noopener">TLS Application-Layer Protocol Negotiation</a></li>
</ul>
</li>
<li>Client Libraries<ul>
<li><a href="http://openjdk.java.net/jeps/289" target="_blank" rel="noopener">Deprecate the Applet API</a></li>
<li><a href="http://openjdk.java.net/jeps/251" target="_blank" rel="noopener">Multi-Resolution Images</a></li>
<li><a href="http://openjdk.java.net/jeps/272" target="_blank" rel="noopener">Platform-Specific Desktop Features</a></li>
<li><a href="http://openjdk.java.net/jeps/262" target="_blank" rel="noopener">TIFF Image I/O</a></li>
</ul>
</li>
<li>XML<ul>
<li><a href="http://openjdk.java.net/jeps/268" target="_blank" rel="noopener">XML Catalogs</a></li>
</ul>
</li>
</ul>
<h3 id="Java-10"><a href="#Java-10" class="headerlink" title="Java 10"></a>Java 10</h3><p>在 Java9 之后，为了更快地迭代以及跟进社区反馈，Java 的版本发布周期变更为每六个月一次，并且承诺不会跳票。新的发布周期也会严格遵循时间点，将在每年的 3 月份和 9 月份发布。不负众望，Java 10 在 2018 年 3 月 14 如期和大家见面了。虽然只有短短的 6 个月，Java 10 还是带来了 109 项新的特性（<a href="https://www.jcp.org/en/jsr/detail?id=383" target="_blank" rel="noopener">JSR 383</a>），其中备受关注的是 <a href="https://openjdk.java.net/projects/jdk/10/" target="_blank" rel="noopener">12 个 JEP 特性增强提议</a>：</p>
<ul>
<li><a href="https://openjdk.java.net/jeps/286" target="_blank" rel="noopener">Local-Variable Type Inference</a></li>
<li><a href="https://openjdk.java.net/jeps/296" target="_blank" rel="noopener">Consolidate the JDK Forest into a Single Repository</a></li>
<li><a href="https://openjdk.java.net/jeps/304" target="_blank" rel="noopener">Garbage-Collector Interface</a></li>
<li><a href="https://openjdk.java.net/jeps/307" target="_blank" rel="noopener">Parallel Full GC for G1</a></li>
<li><a href="https://openjdk.java.net/jeps/310" target="_blank" rel="noopener">Application Class-Data Sharing</a></li>
<li><a href="https://openjdk.java.net/jeps/312" target="_blank" rel="noopener">Thread-Local Handshakes</a></li>
<li><a href="https://openjdk.java.net/jeps/313" target="_blank" rel="noopener">Remove the Native-Header Generation Tool (javah)</a></li>
<li><a href="https://openjdk.java.net/jeps/314" target="_blank" rel="noopener">Additional Unicode Language-Tag Extensions</a></li>
<li><a href="https://openjdk.java.net/jeps/316" target="_blank" rel="noopener">Heap Allocation on Alternative Memory Devices</a></li>
<li><a href="https://openjdk.java.net/jeps/317" target="_blank" rel="noopener">Experimental Java-Based JIT Compiler</a></li>
<li><a href="https://openjdk.java.net/jeps/319" target="_blank" rel="noopener">Root Certificates</a></li>
<li><a href="https://openjdk.java.net/jeps/322" target="_blank" rel="noopener">Time-Based Release Versioning</a></li>
</ul>
<h3 id="Java-11"><a href="#Java-11" class="headerlink" title="Java 11"></a>Java 11</h3><p>2018 年 9 月，收个长期支持版本发布，也就是今天的主角 Java 11，该版本带来了 90 项新的特性（<a href="https://www.jcp.org/en/jsr/detail?id=384" target="_blank" rel="noopener">JSR 384</a>），其中备受关注的还是 <a href="https://openjdk.java.net/projects/jdk/11/" target="_blank" rel="noopener">17 个 JEP 特性增强提议</a>：</p>
<ul>
<li><a href="https://openjdk.java.net/jeps/181" target="_blank" rel="noopener">Nest-Based Access Control</a></li>
<li><a href="https://openjdk.java.net/jeps/309" target="_blank" rel="noopener">Dynamic Class-File Constants</a></li>
<li><a href="https://openjdk.java.net/jeps/315" target="_blank" rel="noopener">Improve Aarch64 Intrinsics</a></li>
<li><a href="https://openjdk.java.net/jeps/318" target="_blank" rel="noopener">Epsilon: A No-Op Garbage Collector</a></li>
<li><a href="https://openjdk.java.net/jeps/320" target="_blank" rel="noopener">Remove the Java EE and CORBA Modules</a></li>
<li><a href="https://openjdk.java.net/jeps/321" target="_blank" rel="noopener">HTTP Client (Standard)</a></li>
<li><a href="https://openjdk.java.net/jeps/323" target="_blank" rel="noopener">Local-Variable Syntax for Lambda Parameters</a></li>
<li><a href="https://openjdk.java.net/jeps/324" target="_blank" rel="noopener">Key Agreement with Curve25519 and Curve448</a></li>
<li><a href="https://openjdk.java.net/jeps/327" target="_blank" rel="noopener">Unicode 10</a></li>
<li><a href="https://openjdk.java.net/jeps/328" target="_blank" rel="noopener">Flight Recorder</a></li>
<li><a href="https://openjdk.java.net/jeps/329" target="_blank" rel="noopener">ChaCha20 and Poly1305 Cryptographic Algorithms</a></li>
<li><a href="https://openjdk.java.net/jeps/330" target="_blank" rel="noopener">Launch Single-File Source-Code Programs</a></li>
<li><a href="https://openjdk.java.net/jeps/331" target="_blank" rel="noopener">Low-Overhead Heap Profiling</a></li>
<li><a href="https://openjdk.java.net/jeps/332" target="_blank" rel="noopener">Transport Layer Security (TLS) 1.3</a></li>
<li><a href="https://openjdk.java.net/jeps/333" target="_blank" rel="noopener">ZGC: A Scalable Low-Latency Garbage Collector(Experimental)</a></li>
<li><a href="https://openjdk.java.net/jeps/335" target="_blank" rel="noopener">Deprecate the Nashorn JavaScript Engine</a></li>
<li><a href="https://openjdk.java.net/jeps/336" target="_blank" rel="noopener">Deprecate the Pack200 Tools and API</a></li>
</ul>
<hr>
<h2 id="Java-8-升级到-Java-11-带来的改变"><a href="#Java-8-升级到-Java-11-带来的改变" class="headerlink" title="Java 8 升级到 Java 11 带来的改变"></a>Java 8 升级到 Java 11 带来的改变</h2><p>基于开源规划调度引擎 OptaPlanner 官网发布的 <a href="https://www.optaplanner.org/blog/2019/01/17/HowMuchFasterIsJava11.html" target="_blank" rel="noopener">Java 11 GC 性能基准测试报告</a> 显示，平均而言，仅通过切换到 Java 11 就有 16％ 的性能提升，这种提升可能是因为 Java 10 中引入了 <a href="https://openjdk.java.net/jeps/307" target="_blank" rel="noopener">JEP 307: Parallel Full GC for G1</a>。</p>
<p>那么主要有哪些改进的特性呢：</p>
<h3 id="本地变量类型推断"><a href="#本地变量类型推断" class="headerlink" title="本地变量类型推断"></a>本地变量类型推断</h3><blockquote>
<p>@since 9</p>
</blockquote>
<p>变量类型推断就是左边的类型直接使用 var 定义，而不用写具体的类型，编译器能根据右边的表达式自动推断类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> javastack = <span class="string">"javastack"</span>;</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String javastack = <span class="string">"javastack"</span>;</span><br></pre></td></tr></table></figure>

<h3 id="紧凑型的字符串"><a href="#紧凑型的字符串" class="headerlink" title="紧凑型的字符串"></a>紧凑型的字符串</h3><blockquote>
<p>@since 9</p>
</blockquote>
<p>从 Java 9 开始 String 数据承载由 char[] 改为 byte[] 紧凑的字符串，在很多时候只包含 Latin-1 里的字符，这些字符可节省一半内存。</p>
<h3 id="增强-api"><a href="#增强-api" class="headerlink" title="增强 api"></a>增强 api</h3><ul>
<li><p>字符串增强 </p>
<blockquote>
<p>@since 11</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断字符串是否为空白</span></span><br><span class="line"><span class="string">" "</span>.isBlank(); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 去除首尾空白</span></span><br><span class="line"><span class="string">" Javastack "</span>.strip(); <span class="comment">// "Javastack"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 去除尾部空格</span></span><br><span class="line"><span class="string">" Javastack "</span>.stripTrailing(); <span class="comment">// " Javastack"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 去除首部空格</span></span><br><span class="line"><span class="string">" Javastack "</span>.stripLeading(); <span class="comment">// "Javastack "</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 复制字符串</span></span><br><span class="line"><span class="string">"Java"</span>.repeat(<span class="number">3</span>);<span class="comment">// "JavaJavaJava"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 行数统计</span></span><br><span class="line"><span class="string">"A\nB\nC"</span>.lines().count(); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></li>
<li><p>集合增强</p>
<blockquote>
<p>@since 9</p>
</blockquote>
<p>从Java 9 开始，jdk 里面就为集合（List、Set、Map）增加了 of（since 9）和 copyOf（since 10）方法。它们用来创建不可变集合。</p>
<p>示例 1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> list = List.of(<span class="string">"Java"</span>, <span class="string">"Python"</span>, <span class="string">"C"</span>);</span><br><span class="line"><span class="keyword">var</span> copy = List.copyOf(list);</span><br><span class="line">System.out.println(list == copy);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"><span class="keyword">var</span> copy = List.copyOf(list);</span><br><span class="line">System.out.println(list == copy);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用 of 和 copyOf 创建的集合为不可变集合，不能进行添加、删除、替换、排序等操作，不然会报 java.lang.UnsupportedOperationException 异常；使用 Set.of() 不能出现重复元素、Map.of()不能出现重复 key，否则会报 java.lang.IllegalArgumentException。</p>
</blockquote>
</li>
<li><p>Stream 增强</p>
<blockquote>
<p>@since 9</p>
</blockquote>
<p>Stream 是Java 8 中的特性，在 Java 9 中为其新增了 4 个方法</p>
<ul>
<li>ofNullable(T t)<br>此方法可以接收null来创建一个空流<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以前</span></span><br><span class="line">Stream.of(<span class="keyword">null</span>); <span class="comment">//报错</span></span><br><span class="line"><span class="comment">// 现在</span></span><br><span class="line">Stream.ofNullable(<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure></li>
<li>takeWhile(Predicate&lt;? super T&gt; predicate)<br>此方法根据 Predicate 接口来判断如果为 true 就取出 来生成一个新的流，只要碰到 false 就终止，不管后边的元素是否符合条件。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;Integer&gt; integerStream = Stream.of(<span class="number">6</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">15</span>, <span class="number">20</span>);</span><br><span class="line">Stream&lt;Integer&gt; takeWhile = integerStream.takeWhile(t -&gt; t % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line">takeWhile.forEach(System.out::println); <span class="comment">// 6,10</span></span><br></pre></td></tr></table></figure></li>
<li>dropWhile(Predicate&lt;? super T&gt; predicate)<br>此方法根据 Predicate 接口来判断如果为 true 就丢弃来生成一个新的流，只要碰到 false 就终止，不管后边的元素是否符合条件。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;Integer&gt; integerStream = Stream.of(<span class="number">6</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">15</span>, <span class="number">20</span>);</span><br><span class="line">Stream&lt;Integer&gt; takeWhile = integerStream.dropWhile(t -&gt; t % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line">takeWhile.forEach(System.out::println); <span class="comment">//11,15,20</span></span><br></pre></td></tr></table></figure></li>
<li>iterate 重载<br>以前使用 iterate 方法生成无限流需要配合 limit 进行截断<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;Integer&gt; limit = Stream.iterate(<span class="number">1</span>, i -&gt; i + <span class="number">1</span>).limit(<span class="number">5</span>);</span><br><span class="line">limit.forEach(System.out::println); <span class="comment">//1,2,3,4,5</span></span><br></pre></td></tr></table></figure>
现在重载后这个方法增加了个判断参数<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;Integer&gt; iterate = Stream.iterate(<span class="number">1</span>, i -&gt; i &lt;= <span class="number">5</span>, i -&gt; i + <span class="number">1</span>);</span><br><span class="line">iterate.forEach(System.out::println); <span class="comment">//1,2,3,4,5</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Optional 增强</p>
<blockquote>
<p>@since 9</p>
</blockquote>
<ul>
<li>stream()<br>如果为空返回一个空流，如果不为空将Optional的值转成一个流。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回Optional值的流</span></span><br><span class="line">Stream&lt;String&gt; stream = Optional.of(<span class="string">"Java 11"</span>).stream();</span><br><span class="line">stream.forEach(System.out::println); <span class="comment">// Java 11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回空流</span></span><br><span class="line">Stream&lt;Object&gt; stream = Optional.ofNullable(<span class="keyword">null</span>).stream();</span><br><span class="line">stream.forEach(System.out::println); <span class="comment">//</span></span><br></pre></td></tr></table></figure></li>
<li>ifPresentOrElse(Consumer&lt;? super T&gt; action, Runnable emptyAction)<br>如果一个 Optional 包含值，则对其包含的值调用函数 action，即 action.accept(value)，这与 ifPresent 一致；与 ifPresent 方法的区别在于，ifPresentOrElse 还有第二个参数 emptyAction —— 如果 Optional 不包含值，那么 ifPresentOrElse 便会调用 emptyAction，即 emptyAction.run()。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;Integer&gt; optional = Optional.of(<span class="number">1</span>);</span><br><span class="line">optional.ifPresentOrElse( x -&gt; System.out.println(<span class="string">"Value: "</span> + x),() -&gt;</span><br><span class="line">System.out.println(<span class="string">"Not Present."</span>)); <span class="comment">//Value: 1</span></span><br><span class="line"></span><br><span class="line">optional = Optional.empty();</span><br><span class="line">optional.ifPresentOrElse( x -&gt; System.out.println(<span class="string">"Value: "</span> + x),() -&gt;</span><br><span class="line">System.out.println(<span class="string">"Not Present."</span>)); <span class="comment">//Not Present.</span></span><br></pre></td></tr></table></figure></li>
<li>or(Supplier&lt;? extends Optional&lt;? extends T&gt;&gt; supplier)<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;String&gt; optional1 = Optional.of(<span class="string">"Java"</span>);</span><br><span class="line">Supplier&lt;Optional&lt;String&gt;&gt; supplierString = () -&gt; Optional.of(<span class="string">"Not Present"</span>);</span><br><span class="line">optional1 = optional1.or( supplierString);</span><br><span class="line">optional1.ifPresent( x -&gt; System.out.println(<span class="string">"Value: "</span> + x)); <span class="comment">//Value: Java</span></span><br><span class="line">optional1 = Optional.empty();</span><br><span class="line">optional1 = optional1.or( supplierString);</span><br><span class="line">optional1.ifPresent( x -&gt; System.out.println(<span class="string">"Value: "</span> + x)); <span class="comment">//Value: Not Present</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>InputStream 增强 </p>
<blockquote>
<p>@since 9</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String lxs = <span class="string">"java"</span>;</span><br><span class="line"><span class="keyword">try</span> (<span class="keyword">var</span> inputStream = <span class="keyword">new</span> ByteArrayInputStream(lxs.getBytes());</span><br><span class="line">  <span class="keyword">var</span> outputStream = <span class="keyword">new</span> ByteArrayOutputStream()) &#123;</span><br><span class="line">  inputStream.transferTo(outputStream);</span><br><span class="line">  System.out.println(outputStream); <span class="comment">// java</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>HTTP Client API</p>
<blockquote>
<p>@since 11</p>
</blockquote>
<p>支持同步和异步两种方式，下面是两种方式的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">var</span> request = HttpRequest.newBuilder()</span><br><span class="line">.uri(URI.create(<span class="string">"https://www.58.com/"</span>))</span><br><span class="line">.build();</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">var</span> client = HttpClient.newHttpClient();</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 同步</span></span><br><span class="line"> HttpResponse&lt;String&gt; response = client.send(request, HttpResponse.BodyHandlers.ofString());</span><br><span class="line"> System.out.println(response.body());</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 异步</span></span><br><span class="line"> CompletableFuture&lt;HttpResponse&lt;String&gt;&gt; sendAsync = client.sendAsync(request, HttpResponse.BodyHandlers.ofString());</span><br><span class="line"> <span class="comment">//这里会阻塞</span></span><br><span class="line"> HttpResponse&lt;String&gt; response1 = sendAsync.get();</span><br><span class="line"> System.out.println(response1.body());</span><br></pre></td></tr></table></figure>
</li>
<li><p>完全支持Linux容器（包括docker）</p>
<blockquote>
<p>@since 10</p>
</blockquote>
<p>许多运行在 Java 虚拟机中的应用程序（包括 Apache Spark 和 Kafka 等数据服务以及传统的企业应用程序）都可以在 Docker 容器中运行。但是在 Docker 容器中运行 Java 应用程序一直存在一个问题，那就是在容器中运行 JVM 程序在设置内存大小和 CPU 使用率后，会导致应用程序的性能下降。这是因为 Java 应用程序没有意识到它正在容器中运行。随着 Java 10 的发布，这个问题总算得以解决，JVM 现在可以识别由容器控制组（cgroups）设置的约束。可以在容器中使用内存和 CPU 约束来直接管理 Java 应用程序，其中包括：</p>
<ul>
<li>遵守容器中设置的内存限制</li>
<li>在容器中设置可用的CPU</li>
<li>在容器中设置CPU约束</li>
</ul>
</li>
<li><p>移除内容</p>
<ul>
<li>com.sun.awt.AWTUtilities。</li>
<li>sun.misc.Unsafe.defineClass 使用java.lang.invoke.MethodHandles.Lookup.defineClass来替代。</li>
<li>Thread.destroy() 以及 Thread.stop(Throwable) 方法。</li>
<li>sun.nio.ch.disableSystemWideOverlappingFileLockCheck 属性。</li>
<li>sun.locale.formatasdefault 属性。</li>
<li>jdk snmp 模块。</li>
<li>javafx，openjdk 是从 java10 版本就移除了，oracle java10 还尚未移除 javafx ，而 java11 版本将 javafx 也移除了。</li>
<li>Java Mission Control，从 JDK 中移除之后，需要自己单独下载。</li>
<li>Root Certificates ：Baltimore Cybertrust Code Signing CA，SECOM ，AOL and Swisscom。</li>
<li>在 java11 中将 java9 标记废弃的 Java EE 及 CORBA模 块移除掉。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="Java-11-收费吗？"><a href="#Java-11-收费吗？" class="headerlink" title="Java 11 收费吗？"></a>Java 11 收费吗？</h2><p>最后说一个大家比较关心的问题，Java 11 收费吗？</p>
<p>我们都知道，Oracle 在 Java 8 的时候开启了 JDK 的收费模式，具体来说 Oracle 将继续提供 JDK 8 免费的公共更新和自动更新，支持个人用户到 2020 年 12 月底，支持商业用户到 2019 年 1 月；换句话说如果想 Oracle 后续继续为你提供 JDK 8 的支持，那么则需要付费。</p>
<p>Oracle JDK 从 11 之后使用了 <code>OTN 协议</code>（即 Oracle Technology Network License Agreement），简单的说就是可以私用，商用需要付费。不过 Oracle 在发布 JDK 时会同时发布两个不同版本，分别为 <code>Oracle JDK</code> 和 <code>OpenJDK</code>, 这两个版本除了所附带的许可文件不一样（OpenJDK 支持 GPL 协议），刚发布的版本几乎完全相同。至于更新计划可以看下图：</p>
<p><img src="/images/jdk11/JavaReleaseSystematik.jpg" alt="JavaReleaseSystematik"></p>
<p>针对 OpenJDK 11 来说，应该有 JDK 11.0.0，然后是两个安全补丁 11.0.1 和 11.0.2，如果需要继续使用 Oracle 的 OpenJDK 构建和安全补丁，那么须在发布后的一个月内迁移到 JDK 12。</p>
<p><img src="/images/jdk11/java-roadmap.png" alt="java-roadmap"></p>
<p><em>PS: 不得不吐槽一下 Oracle 确实很坑，希望 Java 不会在他手上没落；以前一直以为微软很封闭，现在真的是刮目相看</em></p>
<p>除了 OpenJDK 外，还有很多开源 JDK 产品：</p>
<ul>
<li><a href="http://adoptopenjdk.net/" target="_blank" rel="noopener">AdoptOpenJDK</a></li>
<li><a href="https://developers.redhat.com/products/openjdk/download" target="_blank" rel="noopener">Red Hat OpenJDK</a></li>
<li><a href="https://zulu.org/" target="_blank" rel="noopener">Azul Zulu</a></li>
<li><a href="https://sap.github.io/SapMachine/" target="_blank" rel="noopener">SAP</a></li>
</ul>
<hr>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<p><a href="https://www.toutiao.com/i6796064802574696963/?tt_from=weixin&utm_campaign=client_share&wxshare_count=1&timestamp=1587818043&app=news_article&utm_source=weixin&utm_medium=toutiao_android&req_id=20200425203402010130037138445BA3E5&group_id=6796064802574696963" target="_blank" rel="noopener">「是时候升级Java11了」 JDK11优势和JDK选择</a><br><a href="https://www.jianshu.com/p/548c8ece1c95" target="_blank" rel="noopener">Java8及新版本许可证及收费？</a><br><a href="https://yq.aliyun.com/articles/645952" target="_blank" rel="noopener">JDK 11 是发布了，但收费吗？</a><br><a href="https://www.promatis.de/en/2018/09/30/what-is-behind-the-new-license-model-of-oracle-java/" target="_blank" rel="noopener">What is behind the new license model of Oracle Java?</a><br><a href="http://www.360doc.com/content/18/1123/15/48481448_796736124.shtml" target="_blank" rel="noopener">java9新特性（简述十大新特性）</a><br><a href="https://www.oschina.net/translate/109-new-features-in-jdk-10" target="_blank" rel="noopener">JDK 10 的 109 项新特性（译）</a><br><a href="https://cn.azul.com/90-new-features-and-apis-in-jdk-11/" target="_blank" rel="noopener">90 New Features (and APIs) in JDK 11</a><br><a href="https://www.jianshu.com/p/6e08454cc8ac" target="_blank" rel="noopener">Java11正式发布，要不要升级请看这里！</a><br><a href="https://www.oschina.net/news/103704/how-much-faster-is-java-11" target="_blank" rel="noopener">Java 11 究竟比 8 快了多少？看看这个基准测试</a></p>
</blockquote>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>Nested-Loop Join，Hash Join，Sort Merge Join</title>
    <url>/2020/03/31/Nested_Loop-Hash_Join-Merge_Join/</url>
    <content><![CDATA[<p>我们都知道 MySQL 8 中推出了一种新的算法 Hash Join，大家对这个新特性也都非常的兴奋，那究竟什么是 Hash Join 呢，它比现在 MySQL 使用的 Nested-Loop Join 有什么优势呢，下面我们将介绍一下数据库中常用的三个 join 算法（Nested-Loop Join、Hash Join、Sort Merge Join）以及它们之前的区别和联系。</p>
<a id="more"></a>

<h2 id="Nested-Loop-Join"><a href="#Nested-Loop-Join" class="headerlink" title="Nested-Loop Join"></a>Nested-Loop Join</h2><p>Nested-Loop 是通过两层循环，用第一张表做 Outter Loop，第二张表做 Inner Loop，Outter Loop 的每一条记录跟 Inner Loop 的记录作比较，符合条件的就输出。Nested-Loop Join 又有 3 种细分的算法：</p>
<h3 id="Simple-Nested-Loop-Join（SNLJ）"><a href="#Simple-Nested-Loop-Join（SNLJ）" class="headerlink" title="Simple Nested-Loop Join（SNLJ）"></a>Simple Nested-Loop Join（SNLJ）</h3><p>SNLJ 就是两层循环全量扫描连接的两张表，得到符合条件的两条记录则输出，这也就是让两张表做笛卡尔积，比较次数是 R * S，是比较暴力的算法，会比较耗时。</p>
<p><img src="/images/join/snlj.webp" alt="snlj"></p>
<h3 id="Index-Nested-Loop-Join（INLJ）"><a href="#Index-Nested-Loop-Join（INLJ）" class="headerlink" title="Index Nested-Loop Join（INLJ）"></a>Index Nested-Loop Join（INLJ）</h3><p>INLJ 是在 SNLJ 的基础上做了优化，通过连接条件确定可用的索引，在 Inner Loop 中扫描索引而不去扫描数据本身，从而提高 Inner Loop 的效率。<br>而 INLJ 也有缺点，就是如果扫描的索引是非聚簇索引，并且需要访问非索引的数据，会产生一个回表读取数据的操作，这就多了一次随机的 I/O 操作。</p>
<p><img src="/images/join/inlj.webp" alt="inlj"></p>
<h3 id="Block-Nested-Loop-Join（BNLJ）"><a href="#Block-Nested-Loop-Join（BNLJ）" class="headerlink" title="Block Nested-Loop Join（BNLJ）"></a>Block Nested-Loop Join（BNLJ）</h3><p>一般情况下，MySQL 优化器在索引可用的情况下，会优先选择使用 INLJ 算法，但是在无索引可用或者判断 full scan 可能比使用索引更快的情况下，还是不会选择使用过于粗暴的 SNLJ 算法。<br>这里就出现了 BNLJ 算法了，BNLJ 在 SNLJ 的基础上使用了 <code>join buffer</code>，会提前读取 Inner Loop 所需要的记录到 buffer 中，以提高 Inner Loop 的效率。</p>
<p><img src="/images/join/bnlj.webp" alt="bnlj"></p>
<hr>
<h2 id="Sort-Merge-Join"><a href="#Sort-Merge-Join" class="headerlink" title="Sort Merge Join"></a>Sort Merge Join</h2><p>Sort Merge Join 又叫 Merge Join，简单说来就是将 Join 的两个表，首先根据连接属性进行排序，然后进行一次扫描归并, 进而就可以得出最后的结果。从改算法的特性可以看出，该算法最大的消耗在于对内外表数据进行排序，而当连接列为索引列时，我们可以利用索引的有序性避免排序带来的消耗。</p>
<hr>
<h2 id="Hash-Join"><a href="#Hash-Join" class="headerlink" title="Hash Join"></a>Hash Join</h2><p>Hash Join 可以在被驱动表没有索引的情况下进行快速的连接并查询，优化器使用两个表中较小（相对较小）的表利用 Join Key 在内存中建立散列表，然后扫描较大的表并探测散列表，找出与 Hash 表匹配的行。这种方式适用于较小的表完全可以放于内存中的情况，这样总成本就是访问两个表的成本之和。但是在表很大的情况下并不能完全放入内存，这时优化器会将它分割成若干不同的分区，不能放入内存的部分就把该分区写入磁盘的临时段，此时要求有较大的临时段从而尽量提高 I/O 的性能。它能够很好的工作于没有索引的大表和并行查询的环境中，并提供最好的性能。Hash Join 只能应用于等值连接(如WHERE A.COL3 = B.COL4)，这是由 Hash 的特点决定的。</p>
<p>详细的执行过程见：<a href="https://www.jianshu.com/p/29eeb3ec4bc2" target="_blank" rel="noopener">技术分享 | Hash join in MySQL 8</a></p>
<hr>
<h2 id="几种-JOIN-算法对比"><a href="#几种-JOIN-算法对比" class="headerlink" title="几种 JOIN 算法对比"></a>几种 JOIN 算法对比</h2><table>
<thead>
<tr>
<th>join 算法</th>
<th>Nested-Loop Join</th>
<th>Merge Join</th>
<th>Hash Join</th>
</tr>
</thead>
<tbody><tr>
<td>使用条件</td>
<td>任何条件</td>
<td>等值或非等值连接(&gt;，&lt;，=，&gt;=，&lt;=)，‘&lt;&gt;’除外</td>
<td>等值连接（=）</td>
</tr>
<tr>
<td>相关资源</td>
<td>CPU、磁盘I/O</td>
<td>内存、临时空间</td>
<td>内存、临时空间</td>
</tr>
<tr>
<td>特点</td>
<td>当有高选择性索引或进行限制性搜索时效率比较高，能够快速返回第一次的搜索结果</td>
<td>当缺乏索引或者索引条件模糊时，Merge Join 比 Nested Loop 有效。非等值连接时，Merge Join比 Hash Join 更有效</td>
<td>当缺乏索引或者索引条件模糊时，Hash Join 比 Nested Loop 有效。通常比 Merge Join 快。在数据仓库环境下，如果表的纪录数多，效率高</td>
</tr>
<tr>
<td>缺点</td>
<td>当索引丢失或者查询条件限制不够时，效率很低；当表的纪录数多时，效率低</td>
<td>所有的表都需要排序。它为最优化的吞吐量而设计，并且在结果没有全部找到前不返回数据</td>
<td>建立哈希表需要大量内存，第一次的结果返回较慢</td>
</tr>
</tbody></table>
<hr>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<p><a href="http://www.jasongj.com/2015/03/07/Join1/" target="_blank" rel="noopener">http://www.jasongj.com/2015/03/07/Join1/</a><br><a href="https://www.jianshu.com/p/741a6d4efc44" target="_blank" rel="noopener">https://www.jianshu.com/p/741a6d4efc44</a><br><a href="https://zhuanlan.zhihu.com/p/41535500" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/41535500</a><br><a href="https://zhuanlan.zhihu.com/p/94065716" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/94065716</a><br><a href="https://www.jianshu.com/p/d128fef9e747" target="_blank" rel="noopener">https://www.jianshu.com/p/d128fef9e747</a></p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Nested-Loop Join</tag>
        <tag>Hash Join</tag>
        <tag>Sort Merge Join</tag>
      </tags>
  </entry>
  <entry>
    <title>B树，B+树及LSM树对比</title>
    <url>/2020/03/22/btree_b+tree_lsm/</url>
    <content><![CDATA[<p>对开发人员来说熟悉数据库是一项非常重要的技能，为了保证数据库的性能 B树、B+树、LSM树广泛应用在了各种数据库产品中。<code>B树</code>和<code>B+树</code>一般应用于文件存储系统以及数据库系统中，如我们非常常见的 Mysql InnoDB 引擎就是采用了B+树实现的索引结构；<code>LSM树</code>则在诸如 <a href="http://hbase.apache.org/" target="_blank" rel="noopener">Apache HBase</a>、<a href="https://cassandra.apache.org/" target="_blank" rel="noopener">Apache Cassandra</a>、<a href="https://blog.csdn.net/baijiwei/article/details/80506121" target="_blank" rel="noopener">MongoDB 的 Wired Tiger 存储引擎</a>、<a href="https://blog.csdn.net/Double2hao/article/details/90107904" target="_blank" rel="noopener">LevelDB</a>、<a href="https://rocksdb.org.cn/" target="_blank" rel="noopener">RocksDB</a>、<a href="https://pingcap.com/index.html" target="_blank" rel="noopener">TiDB</a> 等产品中都有应用。</p>
<a id="more"></a>

<hr>
<h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><p>全称 Balance-tree（平衡多路查找树），<code>平衡</code> 的意思是左边和右边分布均匀；<code>多路</code>的意思是相对于二叉树而言的，二叉树就是二路查找树，查找时只有两条路，而 B树 有多条路，即父节点有多个子节点。</p>
<p>B树是为磁盘或其它直接存取的辅助存储设备而设计的一种平衡搜索树，它类似于红黑树，但它在降低磁盘 I/O 操作上更好。</p>
<h3 id="结构特点"><a href="#结构特点" class="headerlink" title="结构特点"></a>结构特点</h3><p>名词介绍</p>
<blockquote>
<ul>
<li><strong>阶</strong>：一棵 m 阶 B-tree，每个结点至多可以拥有 m 个子结点，即遍观整棵树，子节点最多的个数是 m，那么这棵树就是 m 阶树。</li>
<li><strong>度</strong>：树的度就是树的高度，即树的层数。</li>
</ul>
</blockquote>
<h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul>
<li>根节点至少有两个子节点</li>
<li>每个中间节点都包含 k-1 个数据和 k 个孩子，其中 m/2 &lt;= k &lt;= m</li>
<li>每个叶子节点都包含 k-1 个数据，其中 m/2 &lt;= k &lt;= m</li>
<li>所有的叶子结点都位于同一层</li>
<li>每个节点中的数据都按照从小到大的顺序排列，每个数据左子树中的所有数据都小于它，而右子树中的所有数据都大于它</li>
</ul>
<p><img src="/images/20200322/B-tree.png" alt="b-tree"></p>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p>
<ul>
<li>使用层次化的索引来最小化磁盘读取</li>
<li>使用不完全填充的块来加速插入和删除</li>
<li>通过优雅的遍历算法来保持索引平衡</li>
</ul>
<p>缺点：</p>
<ul>
<li>每个节点中既要存索引信息，又要存其对应的数据，如果数据很大，那么当树的体量很大时，每次读到内存中的树的信息就会不太够</li>
<li>B树遍历整个树的过程和二叉树本质上是一样的，B树相对二叉树虽然提高了磁盘IO性能，但并没有解决遍历元素效率低下的问题</li>
</ul>
<hr>
<h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p>B树的变体，它把所有的数据都存储在叶节点中，中间节点只存放 <code>关键字</code> 和 <code>子节点指针</code>，因此最大化了中间节点的分支因子，所以B+树的遍历也更加高效(<code>B树需要以中序的方式遍历节点，而B+树只需把所有叶子节点串成链表就可以从头到尾遍历</code>)。</p>
<h3 id="结构特点-1"><a href="#结构特点-1" class="headerlink" title="结构特点"></a>结构特点</h3><p>一棵 B+ 树需要满足以下条件：</p>
<ul>
<li>节点的子树数和关键字数相同</li>
<li>节点的关键字表示的是子树中的最大数，在子树中同样含有这个数据</li>
<li>叶子节点包含了全部数据，同时符合左小右大的顺序</li>
</ul>
<p><img src="/images/20200322/Bplustree.png" alt="Bplustree"></p>
<h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p>
<ul>
<li>中间节点不包含数据，同样大小的磁盘页可以容纳更多的节点元素，这就意味着在数据量相同的情况下，B+树更加的矮胖，因此IO的次数也就较少</li>
<li>B+树查询必须查找到叶子节点，每一次查找都是稳定的</li>
<li>所有叶子节点形成有序链表，便于范围查询，远远高于B树</li>
</ul>
<p>缺点：<br>在一些情况下会产生大量的随机IO，如</p>
<ul>
<li>主键不是有序递增的，导致每次插入数据产生大量的数据迁移和空间碎片</li>
<li>使主键是有序递增的，大量写请求的分布仍是随机的</li>
</ul>
<hr>
<h2 id="LSM-树"><a href="#LSM-树" class="headerlink" title="LSM 树"></a>LSM 树</h2><p>即日志结构合并树(Log-Structured Merge-Tree)，传统关系型数据库使用b树或一些变体作为存储结构，能高效进行查找。但保存在磁盘中时它也有一个明显的缺陷，那就是逻辑上相离很近但物理却可能相隔很远，这就可能造成大量的磁盘随机读写。随机读写比顺序读写慢很多，为了提升IO性能，我们需要一种能将随机操作变为顺序操作的机制，于是便有了 LSM 树。<code>LSM 树能让我们进行顺序写磁盘，从而大幅提升写操作，作为代价的是牺牲了一些读性能</code>。</p>
<h3 id="结构特点-2"><a href="#结构特点-2" class="headerlink" title="结构特点"></a>结构特点</h3><p>LSM 树使用两部分类树的数据结构存储数据，并同时提供查询。其中一部分数据结构（C0）存于内存中（memtable），<code>负责接受新的数据插入、更新及查询的请求，并直接在内存中对数据进行排序</code>；另一部分数据结构（C1）存于硬盘上，由 C0 写入磁盘（sstable）而成，<code>主要提供读的操作，特点是有序且不会被修改</code>；LSM 树会使用日志文件（commit log）来为<code>数据恢复</code>提供保障。</p>
<img src="/images/20200322/LSM.jpg" width="300px" align=center>

<p>三类数据结构的协作顺序是：<code>所有新插入和更新操作先被记录到 commit log，最后达到一定条件时会从 memtable 写入 sstable，并抛弃相关的 log 数据</code>；</p>
<h3 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h3><p>这种数据结构的特点：非常适合数据的快速写入，但不利于读，因此 LSM 树采用了以下策略：</p>
<ul>
<li>定期将硬盘上小的 sstable 合并（Merge）成大的 sstable，以减少 sstable 数量，合并时也会将重复的操作或合并或更新去重</li>
<li>对每个 sstable 使用布隆过滤器（Bloom filter），以加速对数据在该 sstable 的存在性进行判定，从而减少数据查询的总时间</li>
</ul>
<p>WTable 为58同城基于 RocksDB 实现的一个高性能 Key Value 存储平台，针对 LSM 树的 Compaction 问题做了一些优化，详情可以阅读《<a href="https://tech.58.com/#/article?id=27" target="_blank" rel="noopener">58同城RocksDB使用技巧之分布式存储扩容演进</a>》。</p>
<p>字节跳动内部大量的数据库产品（如图数据库、NewSQL 等）都构建在 RocksDB 之上，也对 RocksDB 存储引擎做了几方面的改进，详情可以阅读《<a href="https://www.toutiao.com/i6806261982442816013/?tt_from=weixin&utm_campaign=client_share&wxshare_count=1&timestamp=1585061583&app=news_article&utm_source=weixin&utm_medium=toutiao_android&req_id=202003242253030101300371380A1BEEC8&group_id=6806261982442816013" target="_blank" rel="noopener">字节跳动在 RocksDB 存储引擎上的改进实践</a>》。</p>
<hr>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<p><a href="https://www.zhihu.com/question/19887265" target="_blank" rel="noopener">https://www.zhihu.com/question/19887265</a><br><a href="https://www.jianshu.com/p/3fb899684392" target="_blank" rel="noopener">https://www.jianshu.com/p/3fb899684392</a><br><a href="https://blog.csdn.net/u010916338/article/details/86134334" target="_blank" rel="noopener">https://blog.csdn.net/u010916338/article/details/86134334</a><br><a href="https://zh.wikipedia.org/wiki/B%E6%A0%91" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/B%E6%A0%91</a><br><a href="https://zh.wikipedia.org/wiki/B%2B%E6%A0%91" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/B%2B%E6%A0%91</a><br><a href="https://www.cnblogs.com/nullzx/p/8729425.html" target="_blank" rel="noopener">https://www.cnblogs.com/nullzx/p/8729425.html</a><br><a href="https://blog.csdn.net/yangguosb/article/details/81903583" target="_blank" rel="noopener">https://blog.csdn.net/yangguosb/article/details/81903583</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>B树</tag>
        <tag>B+树</tag>
        <tag>LSM树</tag>
      </tags>
  </entry>
  <entry>
    <title>程序猫炸炸</title>
    <url>/2020/03/19/zhazha_read_code/</url>
    <content><![CDATA[<p>炸炸化身程序猫，这是要给我找 BUG 吗 😂</p>
<a id="more"></a>

<div id="dplayer0" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px; height:450px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"autoplay":true,"video":{"url":"/video/zhazha_video_01.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script>]]></content>
      <categories>
        <category>炸炸</category>
      </categories>
      <tags>
        <tag>炸炸</tag>
        <tag>视频</tag>
      </tags>
  </entry>
  <entry>
    <title>Chrome 80 带来的 Cookie 新策略 SameSite 是什么？</title>
    <url>/2020/03/11/chrome_samesite/</url>
    <content><![CDATA[<p>2020年2月4日谷歌正式宣布了 Chrome 80 稳定版的到来，值得关注的<a href="https://www.bleepingcomputer.com/news/google/chrome-80-released-with-56-security-fixes-cookie-changes-more/?__cf_chl_jschl_tk__=bf60ebcbcc1329f5a908209b354f6d1db3ec73e8-1584753774-0-AftLNYItNWkE3mlPUgL-2Sl2ckSAVfmk5JwcGmabsGeSIr1ab0p8dpHtq-ih-S1-1tse5FrxLufVGtQ1zMw7XBIfg49-Y8UkYsDMEypnRnZZEOk1pwQoaaOYQB6dEgl_V2yZE2RctP-J2HrqPoFNOrkOr9rAblTE4XinPrMlB_zA-pIoZAqZbrsSvJ6S76cv50M0a3EZk6BRJMo0jhBDL0Yw1KnHK_A6WraKF_0gQAEnvufRW0yBVcw_7YVFlUGzTr-dDzd9QLvnGSuPG6ko6g1rYLRZN2yURaF-Ae_pLdcyavgwiAkmWowk3BC2jZQWfkBE0BreIx39ynlPNrjVAI9hm-B9AOH7ECcQ7IubdcvXk5XvuWL4hPNXxM1RkdMo-w" target="_blank" rel="noopener">主要更新</a>如下：</p>
<ul>
<li>引入全新的 cookie 分类模型 SameSite</li>
<li>静默通知</li>
<li>将所有混合音频和视频资源自动升级为 HTTPS</li>
<li>移除对 FTP 的支持</li>
<li>标签分组，每组可配置个性化颜色</li>
<li>支持 SVG 格式的图像，进一步降低站点资源占用</li>
<li>上线联系人选取和内容索引 API</li>
</ul>
<p>新的版本进一步加强了安全性等，对 cookie 的校验策略也更加严格…</p>
<a id="more"></a>

<hr>
<h2 id="Cookie-策略调整"><a href="#Cookie-策略调整" class="headerlink" title="Cookie 策略调整"></a>Cookie 策略调整</h2><p>简单来说，在 Chrome 80 中，Chrome 会将没有声明 SameSite 值的 cookie 默认设置为 <code>SameSite=Lax</code>，只有采用 <code>SameSite=None; Secure</code> 设置的 cookie 可以从外部访问，前提是通过安全连接（即 HTTPS）访问。</p>
<h2 id="SameSite"><a href="#SameSite" class="headerlink" title="SameSite"></a>SameSite</h2><p>Chrome 51 开始，浏览器的 Cookie 新增加了一个 SameSite 属性，用来防止 CSRF 攻击和用户追踪，它可以设置三个值：</p>
<ul>
<li>Strict</li>
<li>Lax</li>
<li>None</li>
</ul>
<h3 id="Strict"><a href="#Strict" class="headerlink" title="Strict"></a>Strict</h3><p>完全禁止第三方 Cookie，跨站点时，任何情况下都不会发送 Cookie。</p>
<h3 id="Lax"><a href="#Lax" class="headerlink" title="Lax"></a>Lax</h3><p>大多数情况也是不发送第三方 Cookie，但是导航到目标网址的 Get 请求除外，导航到目标网址的 GET 请求，只包括三种情况：链接，预加载请求，GET 表单。详见下表：</p>
<table>
<thead>
<tr>
<th>请求类型</th>
<th>示例</th>
<th>Lax</th>
</tr>
</thead>
<tbody><tr>
<td>链接</td>
<td><code>html &lt;a href=&quot;...&quot;&gt;&lt;/a&gt;</code></td>
<td>发送 Cookie</td>
</tr>
<tr>
<td>预加载</td>
<td><code>html &lt;link rel=&quot;prerender&quot; href=&quot;...&quot;/&gt;</code></td>
<td>发送 Cookie</td>
</tr>
<tr>
<td>GET 表单</td>
<td><code>html &lt;form method=&quot;GET&quot; action=&quot;...&quot;&gt;</code></td>
<td>发送 Cookie</td>
</tr>
<tr>
<td>POST 表单</td>
<td><code>html &lt;form method=&quot;POST&quot; action=&quot;...&quot;&gt;</code></td>
<td>不发送</td>
</tr>
<tr>
<td>iframe</td>
<td><code>html &lt;iframe src=&quot;...&quot;&gt;&lt;/iframe&gt;</code></td>
<td>不发送</td>
</tr>
<tr>
<td>AJAX</td>
<td><code>html $.get(&quot;...&quot;)</code></td>
<td>不发送</td>
</tr>
<tr>
<td>Image</td>
<td><code>html &lt;img src=&quot;...&quot;&gt;</code></td>
<td>不发送</td>
</tr>
</tbody></table>
<p>在 chrome 80 中，Chrome 会将没有声明 SameSite 值的 cookie 默认设置为 <code>SameSite=Lax</code>（以前默认值为 <code>SameSite=None</code>），对基于 <code>POST 表单</code>、<code>iframe</code>、<code>AJAX</code>、<code>Image</code> 方式的跨站请求将会出现因无法携带 cookie 而导致网站无法正常打开的问题。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方式一：配置-chrome"><a href="#方式一：配置-chrome" class="headerlink" title="方式一：配置 chrome"></a>方式一：配置 chrome</h3><ol>
<li>浏览器里输入 <a href="chrome://flags/">chrome://flags/</a></li>
<li>查找 same-site-by-default-cookies 设置项，设置为 disabled<br><img src="/images/chrome-samesite.png" alt="same-site-by-default-cookies"></li>
</ol>
<h3 id="方式二：配置-chrome"><a href="#方式二：配置-chrome" class="headerlink" title="方式二：配置 chrome"></a>方式二：配置 chrome</h3><p>开发者网站的 cookie 需要设置 <code>SameSite=None; Secure</code>，同时网站域名需要基于 https。</p>
<hr>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<p><a href="https://www.oschina.net/news/113190/chrome-80-stable-released" target="_blank" rel="noopener">https://www.oschina.net/news/113190/chrome-80-stable-released</a><br><a href="https://baijiahao.baidu.com/s?id=1657599977359683459&wfr=spider&for=pc" target="_blank" rel="noopener">https://baijiahao.baidu.com/s?id=1657599977359683459&amp;wfr=spider&amp;for=pc</a><br><a href="https://www.chromestatus.com/features/schedule" target="_blank" rel="noopener">https://www.chromestatus.com/features/schedule</a><br><a href="http://www.ruanyifeng.com/blog/2019/09/cookie-samesite.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2019/09/cookie-samesite.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>cookie</tag>
        <tag>chrome</tag>
      </tags>
  </entry>
  <entry>
    <title>普吉岛6日游</title>
    <url>/2020/01/24/journey_%20phuket/</url>
    <content><![CDATA[<p>忙碌了一年，趁着假期享受一下传说中的阳光、海水、沙滩 🌞🌊🏖︎</p>
<a id="more"></a>

<h2 id="行程"><a href="#行程" class="headerlink" title="行程"></a>行程</h2><p>普吉岛 Kingpower 免税店、西蒙人妖秀、珊瑚岛、皇帝岛、椰树岛海滩度假村、包车环岛一日游</p>
<h2 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h2><p>海岛很美，水很蓝，沙子特别软，阳光足；人妖秀远远超出了预期，一定要体验。</p>
<p><img src="/images/phuket/01.jpeg" alt="01"><br><img src="/images/phuket/02.jpeg" alt="02"><br><img src="/images/phuket/03.jpeg" alt="03"><br><img src="/images/phuket/04.jpeg" alt="04"></p>
]]></content>
      <categories>
        <category>旅行</category>
      </categories>
      <tags>
        <tag>普吉岛</tag>
        <tag>泰国</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis vs Memcached</title>
    <url>/2019/02/20/redis_vs_memcached/</url>
    <content><![CDATA[<p>redis 和 memcached 作为两款非常优秀的 kv 存储系统经常会被拿来比较，除了我们最常提起的 redis 支持更多数据类型（字符串、哈希表、链表、集合、有序集合）外它们之间还有什么区别呢？本文将从 <code>内存管理</code>、<code>数据结构</code>、<code>淘汰算法</code>、<code>过期策略</code>、<code>网络IO模型</code>、<code>线程模型</code>、<code>持久化</code>、<code>虚拟内存</code>、<code>高可用</code> 等方面详细介绍。</p>
<a id="more"></a>

<hr>
<h2 id="☞-内存管理器"><a href="#☞-内存管理器" class="headerlink" title="☞ 内存管理器"></a>☞ 内存管理器</h2><h3 id="Memcached"><a href="#Memcached" class="headerlink" title="Memcached"></a>Memcached</h3><p>Memcached 默认情况下采用了名为 <code>Slab Allocator</code>（对象缓存分配） 的机制分配、管理内存，可以有效解决内存碎片的问题。</p>
<p>Slab Allocator 的基本原理是按照预先规定的大小，将分配的内存以 <code>page</code> 为单位（默认情况下一个 page 是 1M，可以通过 -I 参数在启动时指定），分割成各种尺寸的 <code>chunk</code>（块）， 相同尺寸的块组成一个分组，即 <code>slab</code> （可以理解为 chunk 的集合）。</p>
<img src="/images/redis_mc/168149AF31D13B84B64D47328EAFE211.jpg" width="400px" align=center>

<blockquote>
<p>如上图所示，&lt;= 88 byte 的数据均归属于 slab 1，&lt;= 112 byte 的数据均归属于 slab 2</p>
</blockquote>
<p>当需要申请内存时，memcached 会划分出一个新的 page 并基于数据的大小分配给指定的 <code>slab</code>，比如存储的数据大小 &lt;= 88 byte，则 page 会分配给 slab 1，该 slab 新增的 chunk 数量为 $1M / 88byte$。</p>
<img src="/images/redis_mc/BDEF68BBFE9BAADDB8070E26FFBFA599.jpg" width="500px" align=center>

<img src="/images/redis_mc/C357A7E26D57A1876666C9E9CA5B42D1.jpg" width="500px" align=center>

<blockquote>
<p>page 一旦被分配在重启前不会被回收或者重新分配，以解决内存碎片问题</p>
</blockquote>
<h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p>Linux 平台默认内存管理器为 <code>jemalloc</code>，其它平台为 <code>libc malloc</code>，下文为 redis 官方的介绍：</p>
<blockquote>
<p>Selecting a non-default memory allocator when building Redis is done by setting the MALLOC environment variable. <code>Redis is compiled and linked against libc malloc by default, with the exception of jemalloc being the default on Linux systems</code>. This default was picked because jemalloc has proven to have fewer fragmentation problems than libc malloc.<br><br/><br>To force compiling against libc malloc, use:<br><br/><br>% make MALLOC=libc<br>To compile against jemalloc on Mac OS X systems, use:<br><br/><br>% make MALLOC=jemalloc</p>
</blockquote>
<p><a href="https://github.com/antirez/redis#allocator" target="_blank" rel="noopener">链接</a></p>
<p>想了解 jemalloc，建议阅读 <a href="https://www.jianshu.com/p/f1988cc08dfd" target="_blank" rel="noopener">jemalloc 之 实现分析</a></p>
<hr>
<h2 id="☞-数据结构"><a href="#☞-数据结构" class="headerlink" title="☞ 数据结构"></a>☞ 数据结构</h2><h3 id="Memcached-1"><a href="#Memcached-1" class="headerlink" title="Memcached"></a>Memcached</h3><p>Memcached 维护一个巨大的 HashTable 用于通过 key 快速查询缓存数据</p>
<img src="/images/redis_mc/5E0BBDC276FEFC9E3E059AEE0BA93AC0.jpg" width="600px" align=center>

<p>Memcached 上存储的每一个元素都会有一个 item 的结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Structure for storing items within memcached.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">stritem</span> &#123;</span></span><br><span class="line">  <span class="comment">/* Protected by LRU locks */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">stritem</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">stritem</span> *<span class="title">prev</span>;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Rest are protected by an item lock */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">stritem</span> *<span class="title">h_next</span>;</span>    <span class="comment">/* hash chain next */</span></span><br><span class="line">  <span class="keyword">rel_time_t</span>      time;       <span class="comment">/* least recent access */</span></span><br><span class="line">  <span class="keyword">rel_time_t</span>      exptime;    <span class="comment">/* expire time */</span></span><br><span class="line">  <span class="keyword">int</span>             nbytes;     <span class="comment">/* size of data */</span></span><br><span class="line">  <span class="keyword">unsigned</span> short  refcount;</span><br><span class="line">  <span class="keyword">uint8_t</span>         nsuffix;    <span class="comment">/* length of flags-and-length string */</span></span><br><span class="line">  <span class="keyword">uint8_t</span>         it_flags;   <span class="comment">/* ITEM_* above */</span></span><br><span class="line">  <span class="keyword">uint8_t</span>         slabs_clsid;<span class="comment">/* which slab class we're in */</span></span><br><span class="line">  <span class="keyword">uint8_t</span>         nkey;       <span class="comment">/* key length, w/terminating null and padding */</span></span><br><span class="line">  <span class="comment">/* this odd type prevents type-punning issues when we do</span></span><br><span class="line"><span class="comment">    * the little shuffle to save space when not using CAS. */</span></span><br><span class="line">  <span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> cas;</span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">end</span>;</span><br><span class="line">  &#125; data[];</span><br><span class="line">  <span class="comment">/* if it_flags &amp; ITEM_CAS we have 8 bytes CAS */</span></span><br><span class="line">  <span class="comment">/* then null-terminated key */</span></span><br><span class="line">  <span class="comment">/* then " flags length\r\n" (no terminating null) */</span></span><br><span class="line">  <span class="comment">/* then data with terminating \r\n (no terminating null; it's binary!) */</span></span><br><span class="line">&#125; item;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考资料：<br><a href="https://blog.csdn.net/initphp/article/details/44537547" target="_blank" rel="noopener">https://blog.csdn.net/initphp/article/details/44537547</a></p>
</blockquote>
<h3 id="Redis-1"><a href="#Redis-1" class="headerlink" title="Redis"></a>Redis</h3><p>以 set hello world 为例，展示 redis 如何存储数据：</p>
<img src="/images/redis_mc/FAAB924D7C8F278DA26EB5949765A196.jpg" width="400px" align=center>

<ul>
<li><strong>dictEntry</strong>: Redis 是 Key-Value 数据库，因此对每个键值对都会有一个 dictEntry，里面存储了指向 Key 和 Value 的指针；next 指向下一个 dictEntry，与本 Key-Value 无关</li>
<li><strong>key</strong>: 图中右上角可见，Key（hello）并不是直接以字符串存储，而是存储在 SDS 结构中</li>
<li><strong>redisObject</strong>: value 的数据结构，下面详细介绍</li>
</ul>
<h4 id="✔-redisObject-数据结构"><a href="#✔-redisObject-数据结构" class="headerlink" title="✔ redisObject 数据结构"></a>✔ redisObject 数据结构</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> lru:LRU_BITS; <span class="comment">/* LRU time (relative to global lru_clock) or</span></span><br><span class="line"><span class="comment">                          * LFU data (least significant 8 bits frequency</span></span><br><span class="line"><span class="comment">                          * and most significant 16 bits access time). */</span></span><br><span class="line">  <span class="keyword">int</span> refcount;</span><br><span class="line">  <span class="keyword">void</span> *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>type</strong>: 表示对象的类型，目前包括 REDIS_STRING(字符串)、REDIS_LIST (列表)、REDIS_HASH(哈希)、REDIS_SET(集合)、REDIS_ZSET(有序集合)</li>
<li><strong>encoding</strong>: 对象的内部编码，<strong>对于 Redis 支持的每种类型，都有至少两种内部编码</strong>，例如对于字符串，有 int、embstr、raw 三种编码（后面详细介绍）</li>
<li><strong>lru</strong>: 记录的是对象最后一次被命令程序访问的时间</li>
<li><strong>refcount</strong>: 记录的是该对象被引用的次数，主要在于对象的引用计数和内存回收</li>
<li><strong>ptr</strong>: 指针指向具体的数据</li>
</ul>
<h4 id="✔-SDS"><a href="#✔-SDS" class="headerlink" title="✔ SDS"></a>✔ SDS</h4><p>Redis 没有直接使用 C 字符串(即以空字符’\0’结尾的字符数组)作为默认的字符串表示，而是使用了 SDS。SDS 是简单动态字符串(Simple Dynamic String)的缩写。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> len;   <span class="comment">//表示sds当前的长度</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">free</span>;  <span class="comment">//已为sds分配的长度-sds当前的长度</span></span><br><span class="line">  <span class="keyword">char</span> buf[];         <span class="comment">//sds实际存放的位置</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>SDS 与 C 字符串的比较:</p>
<ul>
<li><strong>获取字符串长度</strong>：SDS 是 O(1)，C 字符串是 O(n)</li>
<li><strong>缓冲区溢出</strong>：使用 C 字符串的 API 时，如果字符串长度增加（如 strcat 操作）而忘记重新分配内存，很容易造成缓冲区的溢出；而 SDS 由于记录了长度，相应的 API 在可能造成缓冲区溢出时会自动重新分配内存，杜绝了缓冲区溢出</li>
<li><strong>修改字符串时内存的重分配</strong>：对于 C 字符串，如果要修改字符串，必须要重新分配内存（先释放再申请），因为如果没有重新分配，字符串长度增大时会造成内存缓冲区溢出，字符串长度减小时会造成内存泄露。而对于 SDS，由于可以记录 len 和 free，因此解除了字符串长度和空间数组长度之间的关联，可以在此基础上进行优化。如空间预分配策略（即分配内存时比实际需要的多）使得字符串长度增大时重新分配内存的概率大大减小；惰性空间释放策略使得字符串长度减小时重新分配内存的概率大大减小。</li>
<li><strong>存取二进制数据</strong>：SDS 可以，C 字符串不可以。因为 C 字符串以空字符作为字符串结束的标识，而对于一些二进制文件（如图片等）。内容可能包括空字符串，因此 C 字符串无法正确存取；而 SDS 以字符串长度 len 来作为字符串结束标识，因此没有这个问题。</li>
</ul>
<h4 id="✔-Encoding"><a href="#✔-Encoding" class="headerlink" title="✔ Encoding"></a>✔ Encoding</h4><ul>
<li><p><strong>int</strong>：</p>
</li>
<li><p><strong>embstr</strong>：只分配一次内存空间（因此 redisObject 和 sds 是连续的）</p>
</li>
<li><p><strong>raw</strong>：分配两次内存空间（一次为 sds 分配对象，另一次为 objet 分配对象）</p>
<img src="/images/redis_mc/071AC0120A55D4CE86C71BCCE07D32BC.jpg" width="500px" align=center></li>
<li><p><strong>ziplist</strong>：是 Redis 为了节约内存而开发的，是由一系列特殊编码的连续内存块，总体思想是时间换空间，即以部分读写性能为代价，来换取极高的内存空间利用率。这种结构并不擅长做修改操作，一旦数据发生改动，就会引发内存 realloc。ziplist 只会用于字段个数少，且字段值也较小的场景</p>
<img src="/images/redis_mc/WX20200321-172632@2x.png" width="400px" align=center></li>
<li><p><strong>linkedlist</strong>：由一个 list 结构和多个 listNode 结构组成；典型结构如下图所示：</p>
<img src="/images/redis_mc/D37C1920241705B298B4FF9E1F78D306.jpg" width="500px" align=center></li>
<li><p><strong>hashtable</strong>：一个 hashtable 由 1 个 dict 结构、2 个 dictht 结构、1 个 dictEntry 指针数组（称为 bucket）和多个 dictEntry 结构组成</p>
<img src="/images/redis_mc/AEEFF07D89EA2243B42ED37047DC02D6.jpg" width="500px" align=center></li>
<li><p><strong>intset</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">  <span class="keyword">uint32_t</span> encoding;</span><br><span class="line">  <span class="keyword">uint32_t</span> length;</span><br><span class="line">  <span class="keyword">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>encoding</strong>：redis 根据整型位数将 intset 分为 INTSET_ENC_INT16、INTSET_ENC_INT32、INTSET_ENC_INT64 三种编码</li>
<li><strong>length</strong>：集合元素大小</li>
<li><strong>contents</strong>：元素数组</li>
</ul>
</li>
<li><p><strong>skiplist</strong>：<br>跳跃表是一种有序数据结构，通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的</p>
<img src="/images/redis_mc/0948935EFD68F1624BAA1BCB3545BB18.jpg" width="500px" align=center></li>
<li><p><strong>quicklist</strong>：<br>是一个 ziplist 组成的双向链表</p>
<img src="/images/redis_mc/4E2CC5FA2CBC908A727A5ED54087E6C9.jpg" width="500px" align=center>

<blockquote>
<p>为什么不直接使用 ziplist？<br>ziplist 在我们程序里面来看将会是一块连续的内存块。它使用内存偏移来保存 next 从而节约了 next 指针。这样造成了我们每一次的删除插入操作都会进行 realloc，从而分配一块新的内存块。当我们的 ziplist 特别大的时候。没有这么大空闲的内存块给我们的时候。操作系统其实会抽象出一块连续的内存块给我。在底层来说他其实是一个链表链接成为的内存。不过在我们程序使用来说。他还是一块连续的内存。这样的话会造成内存碎片，并且在操作的时候因为内存不连续等原因造成效率问题。或者因为转移到大内存块等进行数据迁移。从而损失性能。所以 quicklist 是对 ziplist 进行一次封装，使用小块的 ziplist 来既保证了少使用内存，也保证了性能。</p>
</blockquote>
</li>
</ul>
<h4 id="✔-Redis-各类型数据结构"><a href="#✔-Redis-各类型数据结构" class="headerlink" title="✔ Redis 各类型数据结构"></a>✔ Redis 各类型数据结构</h4><ul>
<li><strong>字符串</strong>: int（8 个字节的长整型），embstr（&lt;=39 字节的字符串），raw（大于 39 个字节的字符串）</li>
<li><strong>列表</strong>：ziplist（列表中元素数量小于 512 个且列表中所有字符串对象都不足 64 字节），linkedlist（其它）。redis 3.2 后使用 quicklist 作为底层数据结构</li>
<li><strong>哈希</strong>：ziplist（哈希中元素数量小于 512 个且哈希中所有键值对的键和值字符串长度都小于 64 字节），hashtable（其它）</li>
<li><strong>集合</strong>：intset（集合中元素数量小于 512 个且集合中所有元素都是整数值），hashtable（其它）</li>
<li><strong>有序集合</strong>：ziplist（有序集合中元素数量小于 128 个且有序集合中所有成员长度都不足 64 字节），skiplist（其它）</li>
</ul>
<hr>
<h2 id="☞-淘汰算法"><a href="#☞-淘汰算法" class="headerlink" title="☞ 淘汰算法"></a>☞ 淘汰算法</h2><h3 id="Memcached-2"><a href="#Memcached-2" class="headerlink" title="Memcached"></a>Memcached</h3><p>LRU（Least recently used，最近最少使用）算法，根据数据的历史访问记录来进行淘汰数据，其核心思想是 “如果数据最近被访问过，那么将来被访问的几率也更高”。</p>
<img src="/images/redis_mc/682155E1E9663D2FFC818C32DFF6F34B.jpg" align=center>

<ul>
<li>新数据插入到链表头部；</li>
<li>每当缓存命中（即缓存数据被访问），则将数据移到链表头部；</li>
<li>当链表满的时候，将链表尾部的数据丢弃。</li>
</ul>
<h3 id="Redis-2"><a href="#Redis-2" class="headerlink" title="Redis"></a>Redis</h3><p>LRU 近似算法，即随机选取 5 个 key，淘汰其中间隔时间最长的 key。Redis 4.0 后新增了 LFR 淘汰算法。</p>
<p>LFR（Least frequently used，最不经常使用）如果一个数据在最近一段时间内使用次数很少，那么在将来一段时间内被使用的可能性也很小。</p>
<blockquote>
<p>参考资料<br><a href="https://redis.io/topics/lru-cache" target="_blank" rel="noopener">https://redis.io/topics/lru-cache</a><br><a href="https://zhuanlan.zhihu.com/p/24155554" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/24155554</a></p>
</blockquote>
<hr>
<h2 id="☞-过期策略"><a href="#☞-过期策略" class="headerlink" title="☞ 过期策略"></a>☞ 过期策略</h2><h3 id="Memcached-3"><a href="#Memcached-3" class="headerlink" title="Memcached"></a>Memcached</h3><ul>
<li>最大过期时间 30 天，超过 30 天的过期时间将转化为 unix 时间戳作为过期时间</li>
<li>memcached 的过期数据不会立即从内存删除，而是读取的时候判断是否过期，过期则删除（<strong>惰性失效机制</strong>, lazyexpiration）</li>
</ul>
<blockquote>
<p>参考资料<br><a href="https://github.com/memcached/memcached/wiki/Programming#expiration" target="_blank" rel="noopener">https://github.com/memcached/memcached/wiki/Programming#expiration</a></p>
</blockquote>
<h3 id="Redis-3"><a href="#Redis-3" class="headerlink" title="Redis"></a>Redis</h3><p>通过 <code>maxmemory-policy</code> 参数配置</p>
<ul>
<li><strong>noeviction</strong>：默认策略，不淘汰，如果内存已满，添加数据是报错</li>
<li><strong>allkeys-lru</strong>：在所有 key 中，通过 <code>lru</code> 算法淘汰数据</li>
<li><strong>volatile-lru</strong>：设置过期时间的 key 中，通过 <code>lru</code> 算法淘汰数据</li>
<li><strong>allkeys-random</strong>：在所有 key 中，随机淘汰数据</li>
<li><strong>volatile-random</strong>：设置过期时间的 key 中，随机淘汰数据</li>
<li><strong>volatile-ttl</strong>：设置过期时间的 key 中，抛弃存活时间最短的数据</li>
<li><strong>allkeys-lfu</strong>：在所有 key 中，通过 <code>lfu</code> 算法淘汰数据（4.0 版本后）</li>
<li><strong>volatile-lfu</strong>：设置过期时间的 key 中，通过 <code>lfu</code> 算法淘汰数据（4.0 版本后）</li>
</ul>
<blockquote>
<p>参考资料<br><a href="https://redis.io/topics/lru-cache" target="_blank" rel="noopener">https://redis.io/topics/lru-cache</a></p>
</blockquote>
<hr>
<h2 id="☞-网络IO模型"><a href="#☞-网络IO模型" class="headerlink" title="☞ 网络IO模型"></a>☞ 网络IO模型</h2><h3 id="Memcached-4"><a href="#Memcached-4" class="headerlink" title="Memcached"></a>Memcached</h3><p>非阻塞 IO 多路复用。基于 <code>libevent</code> 开发，代码可读性差</p>
<h3 id="Redis-4"><a href="#Redis-4" class="headerlink" title="Redis"></a>Redis</h3><p>非阻塞 IO 多路复用。自己完成了一个非常轻量级的对 <code>select</code>、<code>epoll</code>、<code>evport</code>、<code>kqueue</code> 这些通用的接口的实现，代码优雅，可读性强</p>
<hr>
<h2 id="☞-线程模型"><a href="#☞-线程模型" class="headerlink" title="☞ 线程模型"></a>☞ 线程模型</h2><h3 id="Memcached-5"><a href="#Memcached-5" class="headerlink" title="Memcached"></a>Memcached</h3><p>多线程</p>
<p>优点：</p>
<ul>
<li>可以发挥多核的优势</li>
</ul>
<p>缺点：</p>
<ul>
<li>处理逻辑复杂</li>
<li>需要考虑线程与线程之间的同步与互斥，上下文切换和锁竞争会导致额外的性能消耗</li>
</ul>
<h3 id="Redis-5"><a href="#Redis-5" class="headerlink" title="Redis"></a>Redis</h3><p>单线程</p>
<p>优点：</p>
<ul>
<li>处理逻辑简单</li>
<li>避免了不必要的上下文切换和竞争条件</li>
<li>容易实现更加丰富的功能</li>
</ul>
<p>缺点</p>
<ul>
<li>无法发挥多核的优势</li>
<li>耗时的操作会造成严重的性能问题（如：redis 提供了一些简单的计算功能，比如排序、聚合等，对于这些操作，单线程模型施加会严重影响整体吞吐量，CPU 计算过程中，整个 IO 调度都是被阻塞的）</li>
</ul>
<blockquote>
<p><a href="https://github.com/JohnSully/KeyDB" target="_blank" rel="noopener">KeyDB</a> 是从 Redis fork 出来的分支，专注于多线程、内存效率和高吞吐量；此外 redis 6.0 也引入了多线程 IO 特性</p>
</blockquote>
<hr>
<h2 id="☞-持久化"><a href="#☞-持久化" class="headerlink" title="☞ 持久化"></a>☞ 持久化</h2><h3 id="Memcached-6"><a href="#Memcached-6" class="headerlink" title="Memcached"></a>Memcached</h3><p>无</p>
<h3 id="Redis-6"><a href="#Redis-6" class="headerlink" title="Redis"></a>Redis</h3><p>RDB, AOF</p>
<hr>
<h2 id="☞-虚拟内存"><a href="#☞-虚拟内存" class="headerlink" title="☞ 虚拟内存"></a>☞ 虚拟内存</h2><h3 id="Memcached-7"><a href="#Memcached-7" class="headerlink" title="Memcached"></a>Memcached</h3><p>memcache 会把所有的数据存储在物理内存里</p>
<h3 id="Redis-7"><a href="#Redis-7" class="headerlink" title="Redis"></a>Redis</h3><p>redis 有自己的 VM 机制，理论上能够存储比物理内存更多的数据，当数据超量时，会引发 swap，把冷数据刷到磁盘上。<strong>需要注意的是，从 2.6 版本开始，redis 已经废弃了 VM 机制。</strong></p>
<blockquote>
<p>参考资料：<br><a href="https://redis.io/topics/internals-vm" target="_blank" rel="noopener">https://redis.io/topics/internals-vm</a></p>
</blockquote>
<hr>
<h2 id="☞-高可用"><a href="#☞-高可用" class="headerlink" title="☞ 高可用"></a>☞ 高可用</h2><h3 id="Memcached-8"><a href="#Memcached-8" class="headerlink" title="Memcached"></a>Memcached</h3><p>要想要实现高可用，需要进行二次开发，例如客户端的双读双写，或者服务端的集群同步</p>
<h3 id="Redis-8"><a href="#Redis-8" class="headerlink" title="Redis"></a>Redis</h3><p>支持集群部署、主从复制、读写分离、数据分片等特性</p>
<blockquote>
<p>参考资料：<br>  <a href="https://redis.io/topics/cluster-tutorial" target="_blank" rel="noopener">https://redis.io/topics/cluster-tutorial</a><br>  <a href="https://yq.aliyun.com/articles/626532" target="_blank" rel="noopener">https://yq.aliyun.com/articles/626532</a></p>
</blockquote>
]]></content>
      <categories>
        <category>缓存</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>memcached</tag>
      </tags>
  </entry>
  <entry>
    <title>通过Python绘制NBA球员投篮图表</title>
    <url>/2015/08/29/create-NBA-shot-chart-in-pathon/</url>
    <content><![CDATA[<p>喜欢看NBA的同学都见过官方绘制的球员投篮图表，这些图表能够非常直观地反映某个球员的投篮分布图以及投篮热图等。当然，借助NBA官方提供的数据，我们也可以自己绘制这些图表。</p>
<p>只要有数据，能够绘这种图的工具有很多，鉴于最近在学习Python，而且刚好也有一位大牛写了一篇相关的文章<a href="http://savvastjortjoglou.com/nba-shot-sharts.html" target="_blank" rel="noopener">“How to Create NBA Shot Charts in Python”</a>，借鉴这篇文章，我也使用Python折腾了一把。</p>
<a id="more"></a>

<h3 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h3><ul>
<li><p>操作系统</p>
<p>  CentOS 6.7(32-bit)</p>
</li>
<li><p>Python版本</p>
<p>  2.7.10</p>
</li>
</ul>
<h3 id="第三方模块"><a href="#第三方模块" class="headerlink" title="第三方模块"></a>第三方模块</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br></pre></td></tr></table></figure>

<h3 id="绘制篮球场"><a href="#绘制篮球场" class="headerlink" title="绘制篮球场"></a>绘制篮球场</h3><p>绘制投篮图表时，我们需要以篮球场地作为参考标准，所以我们先要清楚的了解篮球场的尺寸（详见<a href="http://www.sportscourtdimensions.com/wp-content/uploads/2015/02/nba_court_dimensions_h.png" target="_blank" rel="noopener">1</a>和<a href="http://www.sportsknowhow.com/basketball/dimensions/nba-basketball-court-dimensions.html" target="_blank" rel="noopener">2</a>），然后使用Matplotlib Patches绘制<code>圆形</code>，<code>矩形</code>和<code>圆弧</code>，并组合成一个篮球场。绘制篮球场的函数实现如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.patches <span class="keyword">import</span> Circle, Rectangle, Arc</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw_court</span><span class="params">(ax=None, color=<span class="string">'gray'</span>, lw=<span class="number">1</span>, outer_lines=False)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Returns an axes with a basketball court drawn onto to it.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    This function draws a court based on the x and y-axis values that the NBA</span></span><br><span class="line"><span class="string">    stats API provides for the shot chart data.  For example, the NBA stat API</span></span><br><span class="line"><span class="string">    represents the center of the hoop at the (0,0) coordinate.  Twenty-two feet</span></span><br><span class="line"><span class="string">    from the left of the center of the hoop in is represented by the (-220,0)</span></span><br><span class="line"><span class="string">    coordinates.  So one foot equals +/-10 units on the x and y-axis.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    TODO: explain the parameters</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> ax <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        ax = plt.gca()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Create the various parts of an NBA basketball court</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Create the basketball hoop</span></span><br><span class="line">    hoop = Circle((<span class="number">0</span>, <span class="number">0</span>), radius=<span class="number">7.5</span>, linewidth=lw, color=color, fill=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Create backboard</span></span><br><span class="line">    backboard = Rectangle((<span class="number">-30</span>, <span class="number">-7.5</span>), <span class="number">60</span>, <span class="number">-1</span>, linewidth=lw, color=color)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># The paint</span></span><br><span class="line">    <span class="comment"># Create the outer box 0f the paint, width=16ft, height=19ft</span></span><br><span class="line">    outer_box = Rectangle((<span class="number">-80</span>, <span class="number">-47.5</span>), <span class="number">160</span>, <span class="number">190</span>, linewidth=lw, color=color, fill=<span class="literal">False</span>)</span><br><span class="line">    <span class="comment"># Create the inner box of the paint, widt=12ft, height=19ft</span></span><br><span class="line">    inner_box = Rectangle((<span class="number">-60</span>, <span class="number">-47.5</span>), <span class="number">120</span>, <span class="number">190</span>, linewidth=lw, color=color, fill=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Create free throw top arc</span></span><br><span class="line">    top_free_throw = Arc((<span class="number">0</span>, <span class="number">142.5</span>), <span class="number">120</span>, <span class="number">120</span>, theta1=<span class="number">0</span>, theta2=<span class="number">180</span>, linewidth=lw, color=color, fill=<span class="literal">False</span>)</span><br><span class="line">    <span class="comment"># Create free throw bottom arc</span></span><br><span class="line">    bottom_free_throw = Arc((<span class="number">0</span>, <span class="number">142.5</span>), <span class="number">120</span>, <span class="number">120</span>, theta1=<span class="number">180</span>, theta2=<span class="number">0</span>, linewidth=lw, color=color, linestyle=<span class="string">'dashed'</span>)</span><br><span class="line">    <span class="comment"># Restricted Zone, it is an arc with 4ft radius from center of the hoop</span></span><br><span class="line">    restricted = Arc((<span class="number">0</span>, <span class="number">0</span>), <span class="number">80</span>, <span class="number">80</span>, theta1=<span class="number">0</span>, theta2=<span class="number">180</span>, linewidth=lw, color=color)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Three point line</span></span><br><span class="line">    <span class="comment"># Create the right side 3pt lines, it's 14ft long before it arcs</span></span><br><span class="line">    corner_three_a = Rectangle((<span class="number">-220</span>, <span class="number">-47.5</span>), <span class="number">0</span>, <span class="number">140</span>, linewidth=lw, color=color)</span><br><span class="line">    <span class="comment"># Create the right side 3pt lines, it's 14ft long before it arcs</span></span><br><span class="line">    corner_three_b = Rectangle((<span class="number">220</span>, <span class="number">-47.5</span>), <span class="number">0</span>, <span class="number">140</span>, linewidth=lw, color=color)</span><br><span class="line">    <span class="comment"># 3pt arc - center of arc will be the hoop, arc is 23'9" away from hoop</span></span><br><span class="line">    three_arc = Arc((<span class="number">0</span>, <span class="number">0</span>), <span class="number">475</span>, <span class="number">475</span>, theta1=<span class="number">22</span>, theta2=<span class="number">158</span>, linewidth=lw, color=color)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Center Court</span></span><br><span class="line">    center_outer_arc = Arc((<span class="number">0</span>, <span class="number">422.5</span>), <span class="number">120</span>, <span class="number">120</span>, theta1=<span class="number">180</span>, theta2=<span class="number">0</span>, linewidth=lw, color=color)</span><br><span class="line">    center_inner_arc = Arc((<span class="number">0</span>, <span class="number">422.5</span>), <span class="number">40</span>, <span class="number">40</span>, theta1=<span class="number">180</span>, theta2=<span class="number">0</span>, linewidth=lw, color=color)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># List of the court elements to be plotted onto the axes</span></span><br><span class="line">    court_elements = [hoop, backboard, outer_box, inner_box, top_free_throw,</span><br><span class="line">                      bottom_free_throw, restricted, corner_three_a,</span><br><span class="line">                      corner_three_b, three_arc, center_outer_arc,</span><br><span class="line">                      center_inner_arc]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> outer_lines:</span><br><span class="line">        <span class="comment"># Draw the half court line, baseline and side out bound lines</span></span><br><span class="line">        outer_lines = Rectangle((<span class="number">-250</span>, <span class="number">-47.5</span>), <span class="number">500</span>, <span class="number">470</span>, linewidth=lw, color=color, fill=<span class="literal">False</span>)</span><br><span class="line">        court_elements.append(outer_lines)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Add the court elements onto the axes</span></span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> court_elements:</span><br><span class="line">    	ax.add_patch(element)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ax</span><br></pre></td></tr></table></figure>

<p>现在测试一下效果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ns.set_style(<span class="string">'white'</span>)</span><br><span class="line">sns.set_color_codes()</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">12</span>,<span class="number">11</span>))</span><br><span class="line"></span><br><span class="line">draw_court()</span><br><span class="line">plt.xlim(<span class="number">-250</span>,<span class="number">250</span>)</span><br><span class="line">plt.ylim(<span class="number">422.5</span>, <span class="number">-47.5</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>效果如下：<br><img src="/images/draw_court.png" alt="draw_court" width="760px" /></p>
<h3 id="绘制投篮分布图"><a href="#绘制投篮分布图" class="headerlink" title="绘制投篮分布图"></a>绘制投篮分布图</h3><h4 id="获取投篮数据"><a href="#获取投篮数据" class="headerlink" title="获取投篮数据"></a>获取投篮数据</h4><p>获取最权威数据的途径当然是nba官网<a href="http://stats.nba.com/" target="_blank" rel="noopener">stats.nba.com</a>。NBA官网并没有提供相关的API，不过我们可以通过requests库从官方获取包含我们需要信息的JSON文件，具体类实现如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shots</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Shots is a wrapper around the NBA stats API that can access the shot chart</span></span><br><span class="line"><span class="string">    data.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, player_id, league_id=<span class="string">"00"</span>, season=<span class="string">"2014-15"</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 season_type=<span class="string">"Regular Season"</span>, team_id=<span class="number">0</span>, game_id=<span class="string">""</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 outcome=<span class="string">""</span>, location=<span class="string">""</span>, month=<span class="number">0</span>, season_segment=<span class="string">""</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 date_from=<span class="string">""</span>, date_to=<span class="string">""</span>, opp_team_id=<span class="number">0</span>, vs_conference=<span class="string">""</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 vs_division=<span class="string">""</span>, position=<span class="string">""</span>, rookie_year=<span class="string">""</span>, game_segment=<span class="string">""</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 period=<span class="number">0</span>, last_n_games=<span class="number">0</span>, clutch_time=<span class="string">""</span>, ahead_behind=<span class="string">""</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 point_diff=<span class="string">""</span>, range_type=<span class="string">""</span>, start_period=<span class="string">""</span>, end_period=<span class="string">""</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 start_range=<span class="string">""</span>, end_range=<span class="string">""</span>, context_filter=<span class="string">""</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 context_measure=<span class="string">"FGA"</span>)</span>:</span></span><br><span class="line"></span><br><span class="line">        self.player_id = player_id</span><br><span class="line"></span><br><span class="line">        self.base_url = <span class="string">"http://stats.nba.com/stats/shotchartdetail?"</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># <span class="doctag">TODO:</span> Figure out what all these parameters mean for NBA stats api</span></span><br><span class="line">        <span class="comment">#       Need to figure out and include CFID and CFPARAMS, they are</span></span><br><span class="line">        <span class="comment">#       associated w/ContextFilter somehow</span></span><br><span class="line">        self.url_paramaters = &#123;</span><br><span class="line">                                <span class="string">"LeagueID"</span>: league_id,</span><br><span class="line">                                <span class="string">"Season"</span>: season,</span><br><span class="line">                                <span class="string">"SeasonType"</span>: season_type,</span><br><span class="line">                                <span class="string">"TeamID"</span>: team_id,</span><br><span class="line">                                <span class="string">"PlayerID"</span>: player_id,</span><br><span class="line">                                <span class="string">"GameID"</span>: game_id,</span><br><span class="line">                                <span class="string">"Outcome"</span>: outcome,</span><br><span class="line">                                <span class="string">"Location"</span>: location,</span><br><span class="line">                                <span class="string">"Month"</span>: month,</span><br><span class="line">                                <span class="string">"SeasonSegment"</span>: season_segment,</span><br><span class="line">                                <span class="string">"DateFrom"</span>: date_from,</span><br><span class="line">                                <span class="string">"DateTo"</span>: date_to,</span><br><span class="line">                                <span class="string">"OpponentTeamID"</span>: opp_team_id,</span><br><span class="line">                                <span class="string">"VsConference"</span>: vs_conference,</span><br><span class="line">                                <span class="string">"VsDivision"</span>: vs_division,</span><br><span class="line">                                <span class="string">"Position"</span>: position,</span><br><span class="line">                                <span class="string">"RookieYear"</span>: rookie_year,</span><br><span class="line">                                <span class="string">"GameSegment"</span>: game_segment,</span><br><span class="line">                                <span class="string">"Period"</span>: period,</span><br><span class="line">                                <span class="string">"LastNGames"</span>: last_n_games,</span><br><span class="line">                                <span class="string">"ClutchTime"</span>: clutch_time,</span><br><span class="line">                                <span class="string">"AheadBehind"</span>: ahead_behind,</span><br><span class="line">                                <span class="string">"PointDiff"</span>: point_diff,</span><br><span class="line">                                <span class="string">"RangeType"</span>: range_type,</span><br><span class="line">                                <span class="string">"StartPeriod"</span>: start_period,</span><br><span class="line">                                <span class="string">"EndPeriod"</span>: end_period,</span><br><span class="line">                                <span class="string">"StartRange"</span>: start_range,</span><br><span class="line">                                <span class="string">"EndRange"</span>: end_range,</span><br><span class="line">                                <span class="string">"ContextFilter"</span>: context_filter, <span class="comment"># unsure of what this does</span></span><br><span class="line">                                <span class="string">"ContextMeasure"</span>: context_measure</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">        self.response = requests.get(self.base_url, params=self.url_paramaters)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">change_params</span><span class="params">(self, parameters)</span>:</span></span><br><span class="line">        <span class="string">"""Pass in a disctionary of url parameters to change"""</span></span><br><span class="line">        self.url_paramaters.update(parameters)</span><br><span class="line">        self.response = requests.get(self.base_url, params=self.url_paramaters)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_shots</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Returns the shot chart data as a pandas DataFrame."""</span></span><br><span class="line">        shots = self.response.json()[<span class="string">'resultSets'</span>][<span class="number">0</span>][<span class="string">'rowSet'</span>]</span><br><span class="line">        headers = self.response.json()[<span class="string">'resultSets'</span>][<span class="number">0</span>][<span class="string">'headers'</span>]</span><br><span class="line">        <span class="keyword">return</span> pd.DataFrame(shots, columns=headers)</span><br></pre></td></tr></table></figure>

<p>当定义<code>Shots</code>类的一个实例时，必须为参数<code>player_id</code>传入一个值，该数值代表球员的编号，如不知道可以参考：<a href="https://raw.githubusercontent.com/savvastj/nbaShotChartsData/master/player_id.csv" target="_blank" rel="noopener">player_id.csv</a>。本文中以Kobe Bryant在2005-06赛季的数据为例，使用方法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Kobe = Shots(<span class="number">977</span>, season=<span class="string">"2005-06"</span>)</span><br><span class="line">shot_df = Kobe.get_shots()</span><br></pre></td></tr></table></figure>

<h4 id="绘制投篮分布图-1"><a href="#绘制投篮分布图-1" class="headerlink" title="绘制投篮分布图"></a>绘制投篮分布图</h4><p><code>Shorts</code>类的get_shots()方法返回的数据包含了Kobe Bryant在2005-06常规赛期间的所有出手投篮数据，通过如下操作可以提取该数据的头信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.display <span class="keyword">import</span> display</span><br><span class="line"><span class="keyword">with</span> pd.option_context(<span class="string">'display.max_columns'</span>, <span class="literal">None</span>):</span><br><span class="line">    display(shot_df.head())</span><br></pre></td></tr></table></figure>

<p>从结果中可以发现我们需要的数据在LOC_X和LOC_Y 里面，这些坐标值对应每一次出手投篮，然后我们可以把这些坐标绘制到一组表示篮球场的轴上，绘制投篮分布图的函数如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shot_chart</span><span class="params">(x, y, title=<span class="string">""</span>, kind=<span class="string">"scatter"</span>, color=<span class="string">"b"</span>, cmap=None,</span></span></span><br><span class="line"><span class="function"><span class="params">               xlim=<span class="params">(<span class="number">-250</span>, <span class="number">250</span>)</span>, ylim=<span class="params">(<span class="number">422.5</span>, <span class="number">-47.5</span>)</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">               court_color=<span class="string">"gray"</span>, outer_lines=False, court_lw=<span class="number">1</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">               flip_court=False, kde_shade=True, hex_gridsize=None,</span></span></span><br><span class="line"><span class="function"><span class="params">               ax=None, **kwargs)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Returns an Axes object with player shots plotted.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    TODO: explain the parameters</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ax <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        ax = plt.gca()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> cmap <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        cmap = sns.light_palette(color, as_cmap=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> flip_court:</span><br><span class="line">        ax.set_xlim(xlim)</span><br><span class="line">        ax.set_ylim(ylim)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        ax.set_xlim(xlim[::<span class="number">-1</span>])</span><br><span class="line">        ax.set_ylim(ylim[::<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">    ax.tick_params(labelbottom=<span class="string">"off"</span>, labelleft=<span class="string">"off"</span>)</span><br><span class="line">    ax.set_title(title, fontsize=<span class="number">18</span>)</span><br><span class="line"></span><br><span class="line">    draw_court(ax, color=court_color, lw=court_lw, outer_lines=outer_lines)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> kind == <span class="string">"scatter"</span>:</span><br><span class="line">        ax.scatter(x, y, c=color, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> kind == <span class="string">"kde"</span>:</span><br><span class="line">        sns.kdeplot(x, y, shade=kde_shade, cmap=cmap, ax=ax, **kwargs)</span><br><span class="line">        ax.set_xlabel(<span class="string">''</span>)</span><br><span class="line">        ax.set_ylabel(<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> kind == <span class="string">"hex"</span>:</span><br><span class="line">        <span class="keyword">if</span> hex_gridsize <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># Get the number of bins for hexbin using Freedman-Diaconis rule</span></span><br><span class="line">            <span class="comment"># This is idea was taken from seaborn, which got the calculation</span></span><br><span class="line">            <span class="comment"># from http://stats.stackexchange.com/questions/798/</span></span><br><span class="line">            <span class="keyword">from</span> seaborn.distributions <span class="keyword">import</span> _freedman_diaconis_bins</span><br><span class="line">            x_bin = _freedman_diaconis_bins(x)</span><br><span class="line">            y_bin = _freedman_diaconis_bins(y)</span><br><span class="line">            hex_gridsize = int(np.mean([x_bin, y_bin]))</span><br><span class="line"></span><br><span class="line">        ax.hexbin(x, y, gridsize=hex_gridsize, cmap=cmap, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">"kind must be 'scatter', 'kde', or 'hex'."</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ax</span><br></pre></td></tr></table></figure>

<p>使用方法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">shot_chart(shot_df.LOC_X, shot_df.LOC_Y)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/images/Kobe_shot_chart.png" alt="Kobe_shot_chart" width="760px" />

<h4 id="投篮热力图"><a href="#投篮热力图" class="headerlink" title="投篮热力图"></a>投篮热力图</h4><p>Seaborn是Python中基于matplotlib的统计绘图模块，下面的函数是使用searorn中的<a href="http://stanford.edu/~mwaskom/software/seaborn/generated/seaborn.jointplot.html" target="_blank" rel="noopener"><code>Jointplot()</code></a>函数可以让我们以统计学的方式展示投篮分布图：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shot_chart_jointplot</span><span class="params">(x, y, data=None, title=<span class="string">""</span>, kind=<span class="string">"scatter"</span>, color=<span class="string">"b"</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">                         cmap=None, xlim=<span class="params">(<span class="number">-250</span>, <span class="number">250</span>)</span>, ylim=<span class="params">(<span class="number">422.5</span>, <span class="number">-47.5</span>)</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                         space=<span class="number">0</span>, court_color=<span class="string">"gray"</span>, outer_lines=False,</span></span></span><br><span class="line"><span class="function"><span class="params">                         court_lw=<span class="number">1</span>, flip_court=False,</span></span></span><br><span class="line"><span class="function"><span class="params">                         set_size_inches=<span class="params">(<span class="number">12</span>, <span class="number">11</span>)</span>, **kwargs)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Returns a seaborn JointGrid using sns.jointplot</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    TODO: Better documentation</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># If a colormap is not provided, then it is based off of the color</span></span><br><span class="line">    <span class="keyword">if</span> cmap <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        cmap = sns.light_palette(color, as_cmap=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    plot = sns.jointplot(x, y, data=<span class="literal">None</span>, stat_func=<span class="literal">None</span>, kind=kind, space=<span class="number">0</span>, color=cmap(<span class="number">0.1</span>), cmap=cmap, **kwargs)</span><br><span class="line"></span><br><span class="line">    plot.fig.set_size_inches(set_size_inches)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># A joint plot has 3 Axes, the first one called ax_joint </span></span><br><span class="line">    <span class="comment"># is the one we want to draw our court onto and adjust some other settings</span></span><br><span class="line">    ax = plot.ax_joint</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> flip_court:</span><br><span class="line">        ax.set_xlim(xlim)</span><br><span class="line">        ax.set_ylim(ylim)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        ax.set_xlim(xlim[::<span class="number">-1</span>])</span><br><span class="line">        ax.set_ylim(ylim[::<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">    draw_court(ax, color=court_color, lw=court_lw, outer_lines=outer_lines)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Get rid of axis labels and tick marks</span></span><br><span class="line">    ax.set_xlabel(<span class="string">''</span>)</span><br><span class="line">    ax.set_ylabel(<span class="string">''</span>)</span><br><span class="line">    ax.tick_params(labelbottom=<span class="string">'off'</span>, labelleft=<span class="string">'off'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Add a title</span></span><br><span class="line">    ax.set_title(title, y=<span class="number">-0.1</span>, fontsize=<span class="number">18</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> plot</span><br></pre></td></tr></table></figure>

<p>其中，参数kind可以选择不同的显示样式，可选择的有<code>“scatter”，“reg”，“resid”，“kde”，“hex”</code>，参数<code>cmap</code>为matplotlib配色。示例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">shot_chart_jointplot(shot_df.LOC_X, shot_df.LOC_Y, title=<span class="string">"Kobe Bryant FGA \n2005-06 Reg. Season"</span>, kind=<span class="string">"kde"</span>, cmap=plt.cm.YlOrRd_r)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/images/shot_chart_jointplot.png" alt="shot_chart_jointplot" width="760px" />

<hr>
<h3 id="添加球员头像信息"><a href="#添加球员头像信息" class="headerlink" title="添加球员头像信息"></a>添加球员头像信息</h3><h4 id="获取球员图像"><a href="#获取球员图像" class="headerlink" title="获取球员图像"></a>获取球员图像</h4><p>为了更好的展示，我们可以在投篮热图上加上球员的头像，头像的来源仍然是<a href="http://stats.nba.com/" target="_blank" rel="noopener">stats.nba.com</a>。抓取方式如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_player_img</span><span class="params">(player_id)</span>:</span></span><br><span class="line">    <span class="string">"""Returns the image of the player from stats.nba.com</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    player_id: int</span></span><br><span class="line"><span class="string">        The player ID used to find the image.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    url = <span class="string">"http://stats.nba.com/media/players/230x185/"</span>+str(player_id)+<span class="string">".png"</span></span><br><span class="line">    img_file = str(player_id) + <span class="string">".png"</span></span><br><span class="line">    <span class="keyword">return</span> urllib.urlretrieve(url, img_file)[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<p>先看一下效果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sns.set_style(<span class="string">'white'</span>)</span><br><span class="line">sns.set_color_codes()</span><br><span class="line"></span><br><span class="line">pic = get_player_img(<span class="number">977</span>)</span><br><span class="line">Kobe_img = plt.imread(pic)</span><br><span class="line">plt.imshow(Kobe_img)</span><br></pre></td></tr></table></figure>
<img src="/images/977.png" alt="Kobe" width="180px" />

<h4 id="带球员头像的投篮热力图"><a href="#带球员头像的投篮热力图" class="headerlink" title="带球员头像的投篮热力图"></a>带球员头像的投篮热力图</h4><p>在获取到球员头像后，我们可以通过使用<code>matplotlib.Offset</code>模块中的<code>OffsetImage</code>函数在我们的投篮热力图的右上角加入球员头像，具体实现如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">m matplotlib.offsetbox <span class="keyword">import</span>  OffsetImage</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shot_chart_jointplot_with_player_img</span><span class="params">(x, y, player_img, data=None, title=<span class="string">""</span>, kind=<span class="string">"scatter"</span>, color=<span class="string">"b"</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">                         cmap=None, xlim=<span class="params">(<span class="number">-250</span>, <span class="number">250</span>)</span>, ylim=<span class="params">(<span class="number">422.5</span>, <span class="number">-47.5</span>)</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                         space=<span class="number">0</span>, court_color=<span class="string">"gray"</span>, outer_lines=False,</span></span></span><br><span class="line"><span class="function"><span class="params">                         court_lw=<span class="number">1</span>, flip_court=False,</span></span></span><br><span class="line"><span class="function"><span class="params">                         set_size_inches=<span class="params">(<span class="number">12</span>, <span class="number">11</span>)</span>, **kwargs)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Returns a seaborn JointGrid using sns.jointplot</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    TODO: Better documentation</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># If a colormap is not provided, then it is based off of the color</span></span><br><span class="line">    <span class="keyword">if</span> cmap <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        cmap = sns.light_palette(color, as_cmap=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    plot = sns.jointplot(x, y, data=<span class="literal">None</span>, stat_func=<span class="literal">None</span>, kind=kind, space=<span class="number">0</span>, color=cmap(<span class="number">0.1</span>), cmap=cmap, **kwargs)</span><br><span class="line"></span><br><span class="line">    plot.fig.set_size_inches(set_size_inches)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># A joint plot has 3 Axes, the first one called ax_joint </span></span><br><span class="line">    <span class="comment"># is the one we want to draw our court onto and adjust some other settings</span></span><br><span class="line">    ax = plot.ax_joint</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> flip_court:</span><br><span class="line">        ax.set_xlim(xlim)</span><br><span class="line">        ax.set_ylim(ylim)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        ax.set_xlim(xlim[::<span class="number">-1</span>])</span><br><span class="line">        ax.set_ylim(ylim[::<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">    draw_court(ax, color=court_color, lw=court_lw, outer_lines=outer_lines)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Get rid of axis labels and tick marks</span></span><br><span class="line">    ax.set_xlabel(<span class="string">''</span>)</span><br><span class="line">    ax.set_ylabel(<span class="string">''</span>)</span><br><span class="line">    ax.tick_params(labelbottom=<span class="string">'off'</span>, labelleft=<span class="string">'off'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Add a title</span></span><br><span class="line">    ax.set_title(title, y=<span class="number">-0.1</span>, fontsize=<span class="number">18</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># First create our OffSetImage by passing in our image</span></span><br><span class="line">    <span class="comment"># and set the zoom level to make the image small enough </span></span><br><span class="line">    <span class="comment"># to fit on our plot</span></span><br><span class="line">    img = OffsetImage(player_img, zoom=<span class="number">0.6</span>)</span><br><span class="line">    <span class="comment"># Pass in a tuple of x,y coordinates to set_offset</span></span><br><span class="line">    <span class="comment"># to place the plot where you want, I just played around</span></span><br><span class="line">    <span class="comment"># with the values until I found a spot where I wanted</span></span><br><span class="line">    <span class="comment"># the image to be</span></span><br><span class="line">    img.set_offset((<span class="number">992</span>,<span class="number">914</span>))</span><br><span class="line">    <span class="comment"># add the image</span></span><br><span class="line">    ax.add_artist(img)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> plot</span><br></pre></td></tr></table></figure>
<p>使用示例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">shot_chart_jointplot_with_player_img(shot_df.LOC_X, shot_df.LOC_Y, Kobe_img, title=<span class="string">"Kobe Bryant FGA \n2005-06 Reg. Season"</span>, kind=<span class="string">"kde"</span>, cmap=plt.cm.YlOrRd_r)</span><br><span class="line">plt.savefig(<span class="string">'Kobe_shot_chart_jointplot_with_player_img.png'</span>)</span><br></pre></td></tr></table></figure>

<p>效果如下图：</p>
<img src="/images/Kobe_shot_chart_jointplot_with_player_img.png" alt="Kobe_shot_chart_jointplot_with_player_img" width="760px" />
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>NBA</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP和扩展KMP算法</title>
    <url>/2015/08/04/kmp/</url>
    <content><![CDATA[<p>介绍经典的KMP算法。</p>
<a id="more"></a>

<h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><ul>
<li><p>Leetcode</p>
<p>  <a href="https://leetcode.com/problems/implement-strstr/" target="_blank" rel="noopener">Implement strStr()</a></p>
</li>
<li><p>分析</p>
<p>  KMP算法是一个经典的字符串匹配算法，如给定主串S及模式串T，求出S子串第一次匹配T的地址，如不存在则返回-1。其主要思想是利用字符匹配失败的信息，减少模式串与主串的匹配次数。</p>
<blockquote>
<p>如下图，假设已经比对了<code>s[i-1, i+m-1]</code>（图中黄色部分）和<code>T[0, j+n-1]</code>，在比对<code>S[i+m]</code>和<code>T[j+n]</code>时，发生了字符不匹配。</p>
</blockquote>
<p>  <img src="/images/kmp01.png" alt="kmp01"></p>
<blockquote>
<p>按照传统的做法，需要从头开始比较，即从<code>S[i]</code>和<code>T[0]</code>逐个进行字符匹配，如下图。</p>
</blockquote>
<p>  <img src="/images/kmp02.png" alt="kmp02"></p>
<blockquote>
<p>上面的方法显然不可取，因为我们在之前的比对过程中已经发现<code>s[i-1, i+m-1]=T[0, j+n-1]</code>，我们需要充分利用这些信息来避免重复的工作。</p>
</blockquote>
<blockquote>
<p>在去理解KMP算法之前，我们需要先弄清楚两个概念：</p>
</blockquote>
<ul>
<li><p>前缀：除最后一个字符外，一个字符串的全部头补组合，如hello的前缀有h, he, hel, hell。</p>
</li>
<li><p>后缀：除第一个字符外，一个字符串全部尾部组合，如hello的后缀有ello, llo, lo, o。</p>
</li>
</ul>
<hr>
<blockquote>
<p>如下图，假设<code>T[0, j+n-1]</code>最长公共前缀和后缀为<code>t0</code>和<code>t1</code>，即<code>t0=t1</code>且<code>T[j]!=T[j+n]</code>。在上次的比较中，我们已经得到<code>s=t1</code>，所以t0这部分是不需要再重复比对的，我们只需要从<code>S[i+m]</code>和<code>T[j]</code>开始比较就可以了。</p>
</blockquote>
<p>  <img src="/images/kmp03.png" alt="kmp03"></p>
<blockquote>
<p>如果<code>S[i+m]=T[j]</code>，则继续比对两个字符串的下一个字符，若<code>S[i+m]!=T[j]</code>，我们需要继续通过字符串<code>t0</code>的最长公共前缀和后缀来判断T中需要和<code>S[i+m]</code>进行比较的字符的最大位置。若该位置的字符仍与S[i+m]不相等，则继续以前缀作为子串，寻找T中需要做判断的字符的位置，如此往复，直至该位置的字符和S[i+m]相等或者已经到了T的第一个字符。</p>
</blockquote>
<blockquote>
<p>假设数组<code>next[i]</code>, $0 \leq i&lt;strlen(T)$存放着模式串T的子串T[0, i]的最长前缀和后缀的长度。则编程实现方法如下：</p>
</blockquote>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int strStr(char* S, char* T) &#123;</span><br><span class="line">	int S_len &#x3D; strlen(S);</span><br><span class="line">	int T_len&#x3D;strlen(T);</span><br><span class="line"></span><br><span class="line">	if(T_len&#x3D;&#x3D;0)</span><br><span class="line">		return 0;</span><br><span class="line"></span><br><span class="line">	int *next &#x3D; (int*)malloc(T_len*sizeof(int));</span><br><span class="line"></span><br><span class="line">	getNext(next, T);</span><br><span class="line"></span><br><span class="line">	int i;</span><br><span class="line">	int cursor &#x3D; 0;			&#x2F;&#x2F;T中需要和S[i]进行比较的字符的下标</span><br><span class="line"></span><br><span class="line">	for(i&#x3D;0;i&lt;S_len;i++)&#123;</span><br><span class="line">		while(cursor&gt;0 &amp;&amp; S[i]!&#x3D;T[cursor])</span><br><span class="line">			cursor &#x3D; next[cursor-1];</span><br><span class="line"></span><br><span class="line">		if(S[i]&#x3D;&#x3D;T[cursor])</span><br><span class="line">			cursor++;</span><br><span class="line"></span><br><span class="line">		if(cursor &#x3D;&#x3D; T_len)</span><br><span class="line">			return i+1-T_len;</span><br><span class="line">	&#125;</span><br><span class="line">	return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<ul>
<li><p>next数组</p>
<blockquote>
<p>假设next[0, i-1]已经求出，现在我们需要求<code>next[i]</code>，如下图：</p>
</blockquote>
<p>  <img src="/images/kmp04.png" alt="kmp04"></p>
<blockquote>
<p>此时，需要比较<code>T[i]</code>和<code>T[next[i-1]]</code>是否相等。若相等，则继续比较下一组，即在<code>i+1</code>和<code>next[i-1]+1</code>处的字符。若不等，则比较在<code>i</code>和<code>next[next[i-1]]</code>处的字符是否相等，如下图红色标注的部分。</p>
</blockquote>
<p>  <img src="/images/kmp05.png" alt="kmp05"></p>
<blockquote>
<p>在计算next数组时，还需要注意临界值的判断，即next[0]=0。计算next数组的编程实现如下：</p>
</blockquote>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void getNext(int* next, char* T)&#123;</span><br><span class="line">	int len &#x3D; strlen(T);</span><br><span class="line">	next[0] &#x3D; 0;</span><br><span class="line"></span><br><span class="line">	int i;</span><br><span class="line">	int cursor &#x3D; 0;</span><br><span class="line">	for(i&#x3D;1;i&lt;len;i++)&#123;</span><br><span class="line">		while(cursor&gt;0 &amp;&amp; T[i]!&#x3D;T[cursor])</span><br><span class="line">		cursor &#x3D; next[cursor-1];</span><br><span class="line"></span><br><span class="line">		if(T[i]&#x3D;&#x3D;T[cursor])</span><br><span class="line">			cursor++;</span><br><span class="line"></span><br><span class="line">		next[i] &#x3D; cursor;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<h3 id="扩展KMP"><a href="#扩展KMP" class="headerlink" title="扩展KMP"></a>扩展KMP</h3><p>扩展KMP是求主串S的所有后缀（包括S）与模式串T的所有前缀（包括T）的最长公共元素的长度，即求子串<code>S[i, strlen(S)-1]</code>和<code>T</code>的最长公共前缀（包括自身）的长度，结果记录在extend数组中。例如，对以下两个字符串：</p>
<blockquote>
<p>S=”aaabaa”<br/> T=”aaba”</p>
</blockquote>
<p>根据上述定义，有extend[0]=2, extend[1]=4, extend[2]=1, extend[3]=0, extend[4]=2, extend[5]=1。</p>
<ul>
<li><p>extend数组</p>
</li>
<li><p>next数组</p>
</li>
</ul>
<p>(未完待续)</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>最长回文子串</title>
    <url>/2015/07/28/longest-palindromic-substring/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>最长回文子串 (Longest Palindromic Substring)</p>
<blockquote>
<p>Given a string S, find the longest palindromic substring in S. You may assume that the maximum length of S is 1000, and there exists one unique longest palindromic substring.</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">leetcode链接</a></li>
</ul>
<a id="more"></a>

<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ul>
<li><p>动态规划</p>
<p>  使用动态规划是以空间换取时间，避免重复的判断。具体思想是在内存中开辟一段大小为len*(len+1)/2 的数组 is_palindrome，用于记录 s 中从 i 到 j (i&lt;j) 的子串是否为回文。</p>
<ul>
<li><p>时间复杂度： $O(n^2)$</p>
</li>
<li><p>空间复杂度： $O(n^2)$</p>
</li>
</ul>
</li>
<li><p>中心扩展</p>
<p>  以字符串 s 的每个字符以及每两个在相邻位置字符相同的子串作为中心，向两边遍历，记录以该字符或字符串为中心的最长回文。</p>
<ul>
<li><p>时间复杂度： $O(n^2)$</p>
</li>
<li><p>空间复杂度： $O(1)$</p>
</li>
</ul>
</li>
</ul>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><ul>
<li><p>动态规划</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pos</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> j*(j+<span class="number">1</span>)/<span class="number">2</span>+i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">longestPalindrome_dp</span><span class="params">(<span class="keyword">char</span>* s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> * res;</span><br><span class="line">	<span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">	<span class="keyword">int</span> max_palindrome_start, max_palindrome_len;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//printf("%d\n", len);</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(len&lt;<span class="number">2</span>)</span><br><span class="line">		<span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> max_size = len*(len+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> *is_palindrome = (<span class="keyword">bool</span> *)<span class="built_in">malloc</span>(max_size*<span class="keyword">sizeof</span>(<span class="keyword">bool</span>));     <span class="comment">//*(is_palindrome + pos(i, j)) 表示s[i...j] (i&lt;j)是不是回文</span></span><br><span class="line">	<span class="built_in">memset</span>(is_palindrome, <span class="number">0</span>, max_size*<span class="keyword">sizeof</span>(<span class="keyword">bool</span>));                 <span class="comment">//初始为false</span></span><br><span class="line"></span><br><span class="line">	max_palindrome_start = <span class="number">0</span>;</span><br><span class="line">	max_palindrome_len   = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> i,j;</span><br><span class="line">	<span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;len; j++)&#123;</span><br><span class="line">		*(is_palindrome + pos(j, j)) = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;j; i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(j==i+<span class="number">1</span>)&#123;</span><br><span class="line">				<span class="keyword">if</span>(s[i]==s[j])</span><br><span class="line">					*(is_palindrome + pos(i, j)) = <span class="literal">true</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="keyword">if</span>( s[i]==s[j] &amp;&amp; (*(is_palindrome + pos(i+<span class="number">1</span>, j<span class="number">-1</span>))) )</span><br><span class="line">					*(is_palindrome + pos(i, j)) = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span>( *(is_palindrome + pos(i, j)) )&#123;</span><br><span class="line">				<span class="keyword">if</span>(max_palindrome_len&lt;(j-i+<span class="number">1</span>))&#123;</span><br><span class="line">					max_palindrome_len = j-i+<span class="number">1</span>;</span><br><span class="line">					max_palindrome_start = i;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//printf("%d\n", max_palindrome_start);</span></span><br><span class="line">	<span class="comment">//printf("%d\n", max_palindrome_len);</span></span><br><span class="line"></span><br><span class="line">	res = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>((max_palindrome_len+<span class="number">1</span>)*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">	<span class="built_in">memset</span>(res, <span class="number">0</span>, (max_palindrome_len+<span class="number">1</span>)*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">	<span class="built_in">strncpy</span>(res, s+max_palindrome_start, max_palindrome_len);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>中心扩展</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">longestPalindrome_ex</span><span class="params">(<span class="keyword">char</span>* s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> * res;</span><br><span class="line">	<span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">	<span class="keyword">int</span> max_palindrome_start, max_palindrome_len;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//printf("%d\n", len);</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(len&lt;<span class="number">2</span>)</span><br><span class="line">		<span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">	max_palindrome_start = <span class="number">0</span>;</span><br><span class="line">	max_palindrome_len   = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> palindrome_len;</span><br><span class="line">		<span class="keyword">int</span> left, right;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//以s[i]为中心</span></span><br><span class="line">		left  = i<span class="number">-1</span>;</span><br><span class="line">		right = i+<span class="number">1</span>;</span><br><span class="line">		palindrome_len   = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span>(left&gt;=<span class="number">0</span>&amp;&amp;right&lt;len)&#123;</span><br><span class="line">			<span class="keyword">if</span>(s[left]==s[right])</span><br><span class="line">				palindrome_len += <span class="number">2</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			left--;</span><br><span class="line">			right++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(max_palindrome_len&lt;palindrome_len)&#123;</span><br><span class="line">			max_palindrome_len = palindrome_len;</span><br><span class="line">			max_palindrome_start = i - palindrome_len/<span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//以s[i]和s[i+1]为中心</span></span><br><span class="line">		<span class="keyword">if</span>(s[i]==s[i+<span class="number">1</span>])&#123;</span><br><span class="line">			left  = i<span class="number">-1</span>;</span><br><span class="line">			right = i+<span class="number">2</span>;</span><br><span class="line">			palindrome_len   = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">while</span>(left&gt;=<span class="number">0</span>&amp;&amp;right&lt;len)&#123;</span><br><span class="line">				<span class="keyword">if</span>(s[left]==s[right])</span><br><span class="line">					palindrome_len += <span class="number">2</span>;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">				left--;</span><br><span class="line">				right++;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span>(max_palindrome_len&lt;palindrome_len)&#123;</span><br><span class="line">				max_palindrome_len = palindrome_len;</span><br><span class="line">				max_palindrome_start = i - palindrome_len/<span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	res = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>((max_palindrome_len+<span class="number">1</span>)*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">	<span class="built_in">memset</span>(res, <span class="number">0</span>, (max_palindrome_len+<span class="number">1</span>)*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">	<span class="built_in">strncpy</span>(res, s+max_palindrome_start, max_palindrome_len);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
</search>
