<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>工作中常用的加密算法介绍</title>
    <url>/2020/05/04/encrypt-algo/</url>
    <content><![CDATA[<p>作为一个开发者，我们总会接触到诸如 <code>接口鉴权</code>、<code>https</code>、<code>数字签名</code>、<code>数字证书</code> 甚至近两年特别火的话题 - <code>区块链</code> 等，这里面的核心技术便是密码学相关的知识，本文将介绍我们在工作中经常用到的四类加密算法：<code>密码散列函数</code>（Cryptographic Hash Function）、<code>消息认证码</code>（Message Authentication Codes, MACs）、<code>对称加密算法</code>（Symmetric Key Algorithms）、<code>非对称加密</code>（Asymmetric Key Algorithms）、<code>认证加密</code>（Authenticated Encryption, AE）。</p>
<a id="more"></a>

<hr>
<h2 id="一些基本概念介绍"><a href="#一些基本概念介绍" class="headerlink" title="一些基本概念介绍"></a>一些基本概念介绍</h2><h3 id="☞-机密性（confidentiality）-防泄露"><a href="#☞-机密性（confidentiality）-防泄露" class="headerlink" title="☞ 机密性（confidentiality）- 防泄露"></a>☞ 机密性（confidentiality）- 防泄露</h3><p>一提到加密，大家的直观感受就是保证明文数据没办法被直接解读，这个就是机密性，为了实现机密性，密码算法都需需要密钥。</p>
<h3 id="☞-完整性（integrity）-防篡改"><a href="#☞-完整性（integrity）-防篡改" class="headerlink" title="☞ 完整性（integrity）- 防篡改"></a>☞ 完整性（integrity）- 防篡改</h3><p>为了防止有人对数据进行了修改，一般使用的技术包括：<code>密码散列函数</code>、<code>消息认证码</code>、<code>数字签名</code>等。</p>
<h3 id="☞-真实性（authenticity）-防伪装"><a href="#☞-真实性（authenticity）-防伪装" class="headerlink" title="☞ 真实性（authenticity）- 防伪装"></a>☞ 真实性（authenticity）- 防伪装</h3><p>为了防止伪装以保证数据发送方的身份，一般使用的技术包括：<code>消息认证码</code>、<code>数字签名</code>等。</p>
<h3 id="☞-不可否认性（Non-repudiation）-防否认"><a href="#☞-不可否认性（Non-repudiation）-防否认" class="headerlink" title="☞ 不可否认性（Non-repudiation）- 防否认"></a>☞ 不可否认性（Non-repudiation）- 防否认</h3><p>确认数据只能来自指定的发送方，其他人无法伪造，一般使用的技术包括：<code>数字签名</code>等。</p>
<h3 id="☞-加密方式分类"><a href="#☞-加密方式分类" class="headerlink" title="☞ 加密方式分类"></a>☞ 加密方式分类</h3><table width="307.65" border="0" cellpadding="0" cellspacing="0" style='width:307.65pt;border-collapse:collapse;table-layout:fixed;'>
   <col width="112.50" style='mso-width-source:userset;mso-width-alt:4800;'/>
   <col width="109.15" style='mso-width-source:userset;mso-width-alt:4657;'/>
   <tr height="29" style='height:29.00pt;mso-height-source:userset;mso-height-alt:580;'>
    <td class="xl65" width="112.50" style='width:112.50pt;border:.5pt solid windowtext;font-weight: bold;' x:str>按密钥特征分类</td>
    <td class="xl66" width="109.15" style='width:109.15pt;border:.5pt solid windowtext;font-weight: bold;' x:str>按照加密方式分类</td>
   </tr>
   <tr height="21" style='height:21.00pt;mso-height-source:userset;mso-height-alt:420;'>
    <td class="xl67" rowspan="2" style='border:.5pt solid windowtext;' x:str>对称加密</td>
    <td class="xl67" style='border:.5pt solid windowtext;' x:str>流密码</td>
   </tr>
   <tr height="18" style='height:18.00pt;mso-height-source:userset;mso-height-alt:360;'>
    <td class="xl68" rowspan="3" style='border:.5pt solid windowtext;' x:str>分组密码</td>
   </tr>
   <tr height="13.60" style='height:13.60pt;'>
    <td class="xl67" rowspan="2" style='border:.5pt solid windowtext;border-bottom:.5pt solid windowtext' x:str>非对称加密</td>
   </tr>
  </table>

<blockquote>
<p>注：<strong>分组密码</strong>（<a href="https://en.wikipedia.org/wiki/Block_cipher" target="_blank" rel="noopener">Block Cipher Algorithms</a>），只能加密固定长度的分组，若要加密变长数据，则数据必须先被划分为一些单独的密码块；<br><strong>流密码</strong>（<a href="https://en.wikipedia.org/wiki/Stream_cipher" target="_blank" rel="noopener">Stream Cipher Algorithms</a>），是一种对称加密算法（也就是说非对称加密均为分组密码），加密时候，先由种子密钥生成一个密钥流，加密和解密双方使用相同伪随机加密数据流（pseudo-random stream）作为密钥，明文数据每次与密钥数据流顺次对应加密，得到密文数据流。实践中数据通常是一个位（bit）并用异或（xor）操作加密。</p>
</blockquote>
<h3 id="☞-分组密码工作模式"><a href="#☞-分组密码工作模式" class="headerlink" title="☞ 分组密码工作模式"></a>☞ 分组密码工作模式</h3><p>分组密码 <code>工作模式</code> 描述了如何重复加密比较长的多个数据块，工作模式为许多国家和国内的标准认证实体所定义，其中最有影响力的来源是美国的NIST。</p>
<p>常见的保证机密性的工作模式有：</p>
<ul>
<li><strong>ECB</strong>：Electronic CodeBook mode（电子密码模式）</li>
<li><strong>CBC</strong>：Cipher Block Chaining mode（密码分组链接模式）</li>
<li><strong>CFB</strong>：Cipher FeedBack mode（密文反馈模式）</li>
<li><strong>OFB</strong>：Output FeedBack mode（输出反馈模式）</li>
<li><strong>CTR</strong>：CounTeR mode（计数器模式）</li>
</ul>
<p>保证完整性和真实性常见的工作模式有：</p>
<ul>
<li><strong>HMAC</strong>：2002 年被标准化，<a href="https://csrc.nist.gov/csrc/media/publications/fips/198/archive/2002-03-06/documents/fips-198a.pdf" target="_blank" rel="noopener">FIPS 198</a></li>
<li><strong>CMAC</strong>：2005 年被标准化，<a href="https://csrc.nist.gov/publications/detail/sp/800-38b/archive/2005-05-01" target="_blank" rel="noopener">SP 800-38B</a></li>
<li><strong>GMAC</strong>：2007 年被标准化，<a href="https://csrc.nist.gov/publications/detail/sp/800-38d/final" target="_blank" rel="noopener">SP 800-38D</a></li>
</ul>
<p>常见的认证加密（AE）模式有：</p>
<ul>
<li><strong>CCM</strong>：2004 年被标准化，<a href="https://csrc.nist.gov/publications/detail/sp/800-38c/final" target="_blank" rel="noopener">SP 800-38C</a></li>
<li><strong>GCM</strong>：2007 年被标准化，<a href="https://csrc.nist.gov/publications/detail/sp/800-38d/final" target="_blank" rel="noopener">SP 800-38D</a></li>
<li><strong>CWC</strong>：</li>
<li><strong>EAX</strong>：</li>
<li><strong>IAPM</strong>：</li>
<li><strong>OCB</strong>：</li>
</ul>
<h3 id="☞-分组密码填充方式分类"><a href="#☞-分组密码填充方式分类" class="headerlink" title="☞ 分组密码填充方式分类"></a>☞ 分组密码填充方式分类</h3><p>分组密码中，需要将明文按指定大小进行分组，由于明文并非指定大小的整数倍，因此在明文的最后一个分组需要通过 <code>填充方式</code> 将其填充至加密算法所要求的分组大小后进行加密，常见的填充方式有：</p>
<ul>
<li><strong>NoPadding</strong>：不填充，在此填充下原始数据必须是分组大小的整数倍，非整数倍时无法使用该模式</li>
<li><strong>PKCS5Padding / PKCS7Padding</strong>：填充至符合块大小的整数倍，填充值为填充数量数</li>
<li><strong>ISO10126Padding</strong>：填充至符合块大小的整数倍，填充值最后一个字节为填充的数量数，其他字节随机处理</li>
<li><strong>ISO7816-4Padding</strong>：填充至符合块大小的整数倍，填充值第一个字节为 0x80，其他字节填 0</li>
<li><strong>ZeroBytePadding</strong>：填充至符合块大小的整数倍，填充值为 0</li>
<li><strong>X923Padding</strong>：填充至符合块大小的整数倍，填充值最后一个字节为填充的数量数，其他字节填 0</li>
<li><strong>TBCPadding（Trailing-Bit-Compliment）</strong>：填充至符合块大小的整数倍，原文最后一位为 “1”时填充 0x00，最后一位为 “0” 时填充 “0xFF”</li>
<li><strong>PKCS1Padding</strong>：该填充模式是 RSA 加密中使用的，详见 <a href="https://tools.ietf.org/html/rfc2313" target="_blank" rel="noopener">RFC2313</a></li>
</ul>
<hr>
<p>这里介绍一下 CTR 计数器模式，在计数器模式下，我们不再对密文进行加密，而是对一个逐次累加的计数器进行加密，用加密后的比特序列与明文分组进行 XOR得到密文。过程如下图：</p>
<p><img src="/images/encrypt/ctr.png" alt="CTR"></p>
<hr>
<h2 id="密码散列函数"><a href="#密码散列函数" class="headerlink" title="密码散列函数"></a>密码散列函数</h2><p>密码散列函数是一种可以将任意的数据映射为某一固定长度的字符串（一般称为消息摘要，Message Digest，或哈希值，Hash Value）的函数，改函数具有如下的特点：</p>
<ul>
<li>确定性，同样的数据计算的 hash 值是固定的</li>
<li>给定原数据可以很快计算出 hash 值</li>
<li>无法根据 hash 值计算出原数据</li>
<li>两个不同的原数据只有极低的几率会产生相同的 hash 值</li>
<li>对原数据进行很小的更改会导致 hash 值发生改变，同时新的 hash 值看起来与旧的 hash 值不相关</li>
</ul>
<p>密码散列函数有着丰富的应用场景，如：<code>数字签名</code>（digital signatures）、<code>消息认证码</code>（message authentication codes, MACs）、<code>区块链</code>（Block Chain）等，同时还可以用作普通的哈希函数，为哈希表中的数据建立索引、进行指纹识别、检测重复数据或唯一标识文件等。</p>
<p>常用算法有：MD5、SHA-1、RIPEMD-160、bcrypt、Whirlpool、SHA-2、SHA-3、BLAKE2、BLAKE3、SM3 等</p>
<h3 id="☞-MD5"><a href="#☞-MD5" class="headerlink" title="☞ MD5"></a>☞ MD5</h3><p>英文全称是 Message Digest Algorithm MD5，译为 <code>消息摘要算法第五版</code>，在 <a href="https://tools.ietf.org/html/rfc1321" target="_blank" rel="noopener">RFC 1321</a> 中被标准化，MD5 广泛使用在为文件传输提供一定的可靠性，在很多系统中也作为保护密码的一种方式，但这种方式已经不建议使用了，密码的保护还是建议采用更为安全的 bcrypt 算法。</p>
<h3 id="☞-SHA-1"><a href="#☞-SHA-1" class="headerlink" title="☞ SHA-1"></a>☞ SHA-1</h3><p>英文全称是 Secure Hash Algorithm 1，译为 <code>安全散列算法1</code>，该算法由美国国家安全局设计，并由美国国家标准技术研究所（NIST）发布为联邦数据处理标准（FIPS）[1995年]。SHA-1 可以生成一个被称为消息摘要的 160 位（20字节）散列值，散列值通常的呈现形式为 40 个十六进制数。</p>
<p>2005 年，密码分析人员发现了对 SHA-1 的有效攻击方法，这表明该算法可能不够安全，不能继续使用，自 2010 年以来，许多组织建议用 SHA-2 或 SHA-3 来替换 SHA-1</p>
<h3 id="☞-SHA-2"><a href="#☞-SHA-2" class="headerlink" title="☞ SHA-2"></a>☞ SHA-2</h3><p>英文全称是 Secure Hash Algorithm 2，译为 <code>安全散列算法2</code>，同样是由美国国家安全局设计，并由美国国家标准技术研究所（NIST）发布为联邦数据处理标准（FIPS）[2001年]。</p>
<p>根据摘要长度，SHA-2 衍生出来的算法有：SHA-224、SHA-256、SHA-384、SHA-512、SHA-512/224、SHA-512/256。</p>
<h3 id="☞-SHA-3"><a href="#☞-SHA-3" class="headerlink" title="☞ SHA-3"></a>☞ SHA-3</h3><p>英文全称是 Secure Hash Algorithm 3，译为 <code>安全散列算法3</code>，之前名为 Keccak 算法，SHA-3 在 2015 年 8 月 5 日由 NIST 通过 <a href="https://www.federalregister.gov/documents/2015/08/05/2015-19181/announcing-approval-of-federal-information-processing-standard-fips-202-sha-3-standard" target="_blank" rel="noopener">FIPS 202</a> 正式发表。SHA-3 当前并未大规模取代 SHA-2，因为 SHA-2 当前没有出现明显的弱点。由于对 MD5、SHA-0 和 SHA-1 出现成功的破解，NIST 感觉需要一个与之前算法不同的，可替换的加密散列算法，也就是现在的 SHA-3。</p>
<h3 id="☞-SM3"><a href="#☞-SM3" class="headerlink" title="☞ SM3"></a>☞ SM3</h3><p>SM3 是中国政府采用的一种密码散列函数标准，由 <code>国家密码管理</code> 局于 2010 年 12 月 17 日发布。相关标准为 <a href="http://www.oscca.gov.cn/sca/xxgk/2010-12/17/content_1002389.shtml" target="_blank" rel="noopener">“GM/T 0004-2012 《SM3密码杂凑算法》”</a>，其安全性及效率与 SHA-256 相当。</p>
<hr>
<h2 id="消息认证码"><a href="#消息认证码" class="headerlink" title="消息认证码"></a>消息认证码</h2><p>在开放的计算和通信世界中，我们会使用不可靠的媒介传输和存储信息，而对信息 <code>完整性</code> 和 <code>真实性</code> 的校验在某些情景下就十分重要。基于密钥作完整性校验的方法常称为消息认证码 (Message Authentication Code, MAC)，通常 MAC 在共享密钥的双方之间，校验相互传递的信息。</p>
<p>同密码散列函数相比，消息摘要只能保证消息的完整性，如果第三方修改了数据，然后进行散列，并一块发给接收方，接收方并不能察觉到数据被篡改的。<code>MAC 算法则能够保证消息的真实性，数据的发送方和接收方拥有相同的密钥，通过加密策略保证数据不会被第三方篡改</code>。</p>
<p>MAC 有很多实现方式，比较常用的是 基于 Hash 算法的 MAC，即 <code>HMAC</code>；基于分组密码的实现，比如 OMAC、CBC-MAC、PMAC、<a href="https://en.wikipedia.org/wiki/Galois/Counter_Mode" target="_blank" rel="noopener"><code>GMAC</code></a> 、<a href="https://en.wikipedia.org/wiki/Poly1305" target="_blank" rel="noopener"><code>Poly1305</code></a>。本文只介绍一下 HMAC、GCM 和 Poly1305 算法。</p>
<blockquote>
<p>注：在后面会介绍基于流密码 <a href="https://en.wikipedia.org/wiki/Salsa20" target="_blank" rel="noopener">ChaCha20</a> 和 Poly1305 实现的一种认证加密算法 <code>ChaCha20-Poly1305</code>（<a href="https://tools.ietf.org/html/rfc7539" target="_blank" rel="noopener">RFC7539</a>）。</p>
</blockquote>
<h3 id="☞-HMAC-RCF2104"><a href="#☞-HMAC-RCF2104" class="headerlink" title="☞ HMAC(RCF2104)"></a>☞ HMAC(<a href="https://tools.ietf.org/html/rfc2104" target="_blank" rel="noopener">RCF2104</a>)</h3><p>基于加密 Hash 算法实现，任何加密 Hash 比如 MD5、SHA1、SHA256、SHA512 等，都可以用来实现 HMAC 算法，其相应的算法称为 HMAC-MD5、HMAC-SHA1、HMAC-SHA256、HMAC-SHA512。HMAC 计算公式为：</p>
<p>$$ HMAC(K，M) = H(K \oplus opad ∣ H( K \oplus ipad ∣ M)) $$</p>
<p>其中：</p>
<ul>
<li>K 是密钥，长度可为 64 字节，若小于该长度，在密钥后面用 <code>0</code> 补齐</li>
<li>M 是消息内容</li>
<li>H 表示 Hash 函数</li>
<li>opad 和 ipad 分别是由若干个 0x5c 和 0x36 组成的字符串</li>
<li>$\oplus$ 表示异或运算</li>
<li>∣ 表示连接操作</li>
</ul>
<p>以 <code>HMAC-MD5</code> 为例，其计算流程如下：</p>
<blockquote>
<ol>
<li>在密钥 key 后面添加 0 来创建一个长为 64 字节的字符串 (str)，如果 key 超过 64 字节则使用 key 的 md5 代替 key，再在后面加 0 补齐 64 字节</li>
<li>将上一步生成的字符串 (str) 与 ipad(0x36) 做异或运算，形成结果字符串 (istr)</li>
<li>将消息内容 M 附加到第 2 步的结果字符串 (istr) 的末尾；</li>
<li>做 md5 运算于第 3 步生成的数据流(istr)；</li>
<li>将第 1 步生成的字符串 (str) 与 opad(0x5c) 做异或运算，形成结果字符串 (ostr)；</li>
<li>再将第 4 步的结果 (istr) 附加到第五步的结果字符串 (ostr) 的末尾；</li>
<li>做 md5 运算于第 6 步生成的数据流 (ostr)，输出最终结果 </li>
</ol>
</blockquote>
<p>Java 中计算 HMAC-MD5 如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">HMACMD5</span><span class="params">(String s, String keyString)</span> </span>&#123;</span><br><span class="line">  String res = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    SecretKeySpec key = <span class="keyword">new</span> SecretKeySpec((keyString).getBytes(<span class="string">"UTF-8"</span>), <span class="string">"HmacMD5"</span>);</span><br><span class="line">    Mac mac = Mac.getInstance(<span class="string">"HmacMD5"</span>);</span><br><span class="line">    mac.init(key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] bytes = mac.doFinal(s.getBytes(<span class="string">"ASCII"</span>));</span><br><span class="line"></span><br><span class="line">    StringBuffer hash = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bytes.length; i++) &#123;</span><br><span class="line">      String hex = Integer.toHexString(<span class="number">0xFF</span> &amp;  bytes[i]);</span><br><span class="line">      <span class="keyword">if</span> (hex.length() == <span class="number">1</span>) &#123;</span><br><span class="line">          hash.append(<span class="string">'0'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      hash.append(hex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res = hash.toString();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">  &#125; <span class="keyword">catch</span>(InvalidKeyException e)&#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure>

<h3 id="☞-GMAC"><a href="#☞-GMAC" class="headerlink" title="☞ GMAC"></a>☞ GMAC</h3><p>GMAC 是利用伽罗华域（Galois Field，GF，有限域）乘法运算来计算消息的 MAC 值。假设秘钥长度为 128bits, 当密文大于 128bits 时，需要将密文按 128bits 进行分组。应用流程如下图：</p>
<p><img src="/images/encrypt/gmac.png" alt="GMAC"></p>
<p>其中，Mh 表示将输入与秘钥 h 在有限域 $GF(2^{128})$ 上做乘法。</p>
<p>GMAC 是 </p>
<h3 id="☞-Poly1305"><a href="#☞-Poly1305" class="headerlink" title="☞ Poly1305"></a>☞ Poly1305</h3><p>Poly1305 是 D. J. Bernstein 设计的一种 MAC 算法，它需要一个 32 字节的一次性密钥和一条消息以产生用于认证消息的 16 字节的标签。最初的设计是基于 AES 加密算法实现，Google 在 2014 年选择了 Poly1305 和 ChaCha20 对称加密算法（也是 Bernstein 提出的，大牛就是大牛）替换了 TLS/SSL 中的 RC4 算法，这种设计最终也成为了 RFC 标准：<a href="https://tools.ietf.org/html/rfc7539" target="_blank" rel="noopener">RFC7539</a>。</p>
<p>Poly1305-AES 的算法实现可以参考：<a href="http://cr.yp.to/mac.html" target="_blank" rel="noopener">http://cr.yp.to/mac.html</a>，该网站提供了基于 C++、Python、Perl 语言的实现源码。</p>
<hr>
<h2 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h2><p>对称加密算法是应用较早的加密算法，技术成熟，其特点计算加密和解密使用相同的密钥，主要的算法有 DES、3DES、AES、RC4 和 Salsa20/Chacha20 、SM1、SM4、SM7、祖冲之算法(ZUC) 等，其中 DES、3DES、AES、SM1、SM4、SM7 属于分组密码，RC4、Salsa20/Chacha20、祖冲之算法(ZUC) 属于流密码。</p>
<h3 id="☞-DES-3DES"><a href="#☞-DES-3DES" class="headerlink" title="☞ DES/3DES"></a>☞ DES/3DES</h3><p>DES 全称为 Data Encryption Standard，即数据加密标准，1977 年被美国联邦政府的国家标准局确定为联邦资料处理标准（FIPS）。3DES 是对 DES 的一种改良算法，针对 DES 算法密钥短，迭代次数少的缺点做了改进。但是 3DES 算法速度慢，密钥计算时间长，加密效率不高，实际使用也不多。</p>
<p>JDK 仅支持 56 位的密钥长度（出口限制），对称加密系列算法的特点是：密钥长度越高安全性越高，因此 JDK 本身自带的 DES 和 3DES 算法仅适合学术和一般场景使用，Bouncy Castle 提供了 64 位密钥长度的支持。</p>
<h3 id="☞-AES"><a href="#☞-AES" class="headerlink" title="☞ AES"></a>☞ AES</h3><p>AES 全称 Advanced Encryption Standard，即高级加密标准，由美国国家标准与技术研究院（NIST）于 2001 年 11 月 26 日发布为联邦数据处理标准（FIPS），这个标准用来替代原先的DES，已经被多方分析且广为全世界所使用。</p>
<p>AES 的密钥长度为 128、192 或者 256 位，分组长度 128 位，由于进口管制限制，JDK 默认是不允许 256 位密钥的 AES 加解密的，解决方法就下载官方JCE无限制强度加密策略文件，覆盖即可。</p>
<p>JDK6的下载地址：<br><a href="http://www.oracle.com/technetwork/java/javase/downloads/jce-6-download-429243.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/jce-6-download-429243.html</a></p>
<p>JDK7的下载地址：<br><a href="http://www.oracle.com/technetwork/java/javase/downloads/jce-7-download-432124.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/jce-7-download-432124.html</a></p>
<p>JDK8的下载地址：<br><a href="http://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html</a></p>
<p>但从 Java 1.8.0_151 和 1.8.0_152 开始，为 JVM 启用无限制强度管辖策略有了一种更简单的方法：在 jre/lib/security 文件夹中查找文件 java.security，现在用文本编辑器打开 java.security，并找到定义 java 安全性属性 crypto.policy 的行，它可以有两个值l imited 或 unlimited - 默认值是 limited。将其设置为：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">crypto.policy=unlimited</span><br></pre></td></tr></table></figure>

<h3 id="☞-SM1-SM4-SM7"><a href="#☞-SM1-SM4-SM7" class="headerlink" title="☞ SM1/SM4/SM7"></a>☞ SM1/SM4/SM7</h3><p>均为国家商用密码管理办公室制定的对称分组加密标准，其中：</p>
<p>SM1 算法是分组密码算法，分组长度为 128 位，密钥长度都为 128 比特，算法安全保密强度及相关软硬件实现性能与 AES 相当，算法不公开，仅以IP 核的形式存在于芯片中。</p>
<p>SM4 用于无线局域网产品。该算法的分组长度为 128 位，密钥长度为 128 比特。加密算法与密钥扩展算法都采用 32 轮非线性迭代结构。解密算法与加密算法的结构相同，只是轮密钥的使用顺序相反，解密轮密钥是加密轮密钥的逆序。详情可参考：<a href="http://www.sca.gov.cn/sca/c100061/201611/1002423/files/330480f731f64e1ea75138211ea0dc27.pdf" target="_blank" rel="noopener">无线局域网产品使用的 SMS4 密码算法</a>。</p>
<p>SM7 分组长度为 128 比特，密钥长度为 128 比特。SM7 适用于非接触式 IC 卡，应用包括身份识别类应用(门禁卡、工作证、参赛证)，票务类应用(大型赛事门票、展会门票)，支付与通卡类应用（积分消费卡、校园一卡通、企业一卡通等）。</p>
<p>SM1、SM7 算法不公开，调用该算法时，需要通过加密芯片的接口进行调用。</p>
<h3 id="☞-chacha20"><a href="#☞-chacha20" class="headerlink" title="☞ chacha20"></a>☞ chacha20</h3><p>基于 <a href="https://zh.wikipedia.org/wiki/Salsa20" target="_blank" rel="noopener">Salsa20</a> 算法，Salsa20 是一种流加密算法，由丹尼尔·J·伯恩斯坦设计，它创建在基于 add-rotate-xor（ARX）操作的伪随机函数之上（32位模加、异或和循环移位操作），Salsa20 映射一个 256 位密钥、一个 64位 nonce 以及一个 64 位流位置到一个 512 位的输出（也存在一个 128 位密钥的版本），这使 Salsa20 具有了不同寻常的优势，用户可以在恒定时间内寻求输出流中的任何位置。</p>
<p>在 2008 年，丹尼尔·J·伯恩斯坦发布了一个密切相关的 “ChaCha” 密码家族，其目的是增加每一轮的扩散以实现相同或稍微提升的性能。</p>
<p>Google 选择了伯恩斯坦设计的，带 Poly1305 消息认证码的 ChaCha20，作为 OpenSSL 中 RC4 的替代品，用以完成互联网的安全通信。不久之后，Google 在 TLS 中采用它，ChaCha20 和 Poly1305 算法也以 <a href="mailto:chacha20-poly1305@openssh.com">chacha20-poly1305@openssh.com</a> 成为 OpenSSH 中的一个新密码包。在没有 AES 指令集的低端 CPU 上，ChaCha20 的性能较 AES 高。</p>
<h3 id="☞-ZUC-祖冲之算法"><a href="#☞-ZUC-祖冲之算法" class="headerlink" title="☞ ZUC 祖冲之算法"></a>☞ ZUC 祖冲之算法</h3><p>祖冲之序列密码算法是中国自主研究的流密码算法,是运用于移动通信 4G 网络中的国际标准密码算法,该算法包括祖冲之算法(ZUC)、加密算法(128-EEA3)和完整性算法(128-EIA3)三个部分。目前已有对ZUC算法的优化实现，有专门针对 128-EEA3 和 128-EIA3 的硬件实现与优化。</p>
<hr>
<h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><p>全称 Asymmetric cryptography，是密码学的一种算法，它需要两个密钥，一个是 <code>公开密钥</code>，另一个是 <code>私有密钥</code>；公钥用作加密，私钥则用作解密。使用公钥把明文加密后所得的密文，只能用相对应的私钥才能解密并得到原本的明文，最初用来加密的公钥不能用作解密。基于公开密钥加密的特性，它还能提供 <code>数字签名</code> 的功能，使电子文件可以得到如同在纸本文件上亲笔签署的效果。</p>
<p>常见的公钥加密算法有：RSA、ECC、SM2、双线性映射、SM9等。</p>
<h3 id="☞-RSA"><a href="#☞-RSA" class="headerlink" title="☞ RSA"></a>☞ RSA</h3><p>RSA 是由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）在 1977 年一起提出的，RSA就是三个人名字首字母。RSA 的安全性是基于 <code>对大质数进行因式分解过于困难保证的</code>，因而 RSA 的密钥一般非常长，目前来说 1024 位的RSA密钥基本安全，2048 位的密钥极其安全。</p>
<h3 id="☞-ECC"><a href="#☞-ECC" class="headerlink" title="☞ ECC"></a>☞ ECC</h3><p>全称 Elliptic Curves Cryptography，即椭圆曲线密码，是一种基于椭圆曲线数学的公开密钥加密算法，关于椭圆曲线的理论知识可以阅读《椭圆曲线密码学导论》。ECC 的主要优势是它相比 RSA 加密算法使用较小的密钥长度并提供相当等级的安全性。</p>
<h3 id="☞-SM2"><a href="#☞-SM2" class="headerlink" title="☞ SM2"></a>☞ SM2</h3><p>SM2 是国家密码管理局于 2010 年 12 月 17 日发布的椭圆曲线公钥密码算法，加密强度为 256 位，是一种椭圆曲线算法，相关标准为 <a href="http://www.oscca.gov.cn/sca/xxgk/2012-11/22/content_1002397.shtml" target="_blank" rel="noopener">“《SM2椭圆曲线公钥密码算法》</a>“。</p>
<h3 id="☞-双线性映射"><a href="#☞-双线性映射" class="headerlink" title="☞ 双线性映射"></a>☞ 双线性映射</h3><p>全称 Bilinear Pairing，可以实现 <code>基于身份的加密方案</code>（Identity Based Encryption, IBE），IBE 的公钥不是从公钥证书中获得，而是直接用标志自己身份信息的任意长度字符串作为公钥，比如姓名、邮箱地址、IP地址等，与传统的公钥密码体制相比，基于身份的加密体制不需要专门的认证机构，减少了证书分发与管理的复杂性。</p>
<h3 id="☞-SM9"><a href="#☞-SM9" class="headerlink" title="☞ SM9"></a>☞ SM9</h3><p>SM9 是由国密局发布的一种 IBE 算法，SM9 是基于 256 位的 BN 椭圆曲线的，使用有限域 $ \mathbb{F}_{p^2} $ 和素域 $ \mathbb{F}_p $ ，双线性对使用 R-ate。</p>
<hr>
<h2 id="认证加密"><a href="#认证加密" class="headerlink" title="认证加密"></a>认证加密</h2><p>认证加密（Authenticated Encryption, AE）是一种加密形式，它能同时保证数据的 <code>机密性</code>、<code>完整性</code>和 <code>真实性</code>。在实际中推荐使用的是它的一个变体 - <code>关联数据的认证加密</code>（Authenticated Encryption with Associated Data, <code>AEAD</code>），除了拥有 AE 的特性，它还可以提供对未加密的 <code>关联数据</code>（Associated Data）的完整性保证。</p>
<p>AEAD 产生的原因很简单，单纯的对称加密算法，其解密步骤是无法确认密钥是否正确的，也就是说，加密后的数据可以用任何密钥执行解密运算，得到一组疑似原始数据。</p>
<p>为了构造更加安全的算法，密码学领域一开始使用了组合密码的形式，即通过 <code>加密</code> 实现 <code>机密性</code>，通过 <code>MAC</code> 进行消息认证以保证消息的 <code>完整性</code> 和 <code>真实性</code>，基于该思路产生了以下几种方案：</p>
<ul>
<li>EtM (Encryption then MAC)</li>
<li>E&amp;M (Encryption and MAC)</li>
<li>MtE (MAC then Encryption)</li>
</ul>
<p>通过这种组合的方式也引入和很多的安全漏洞，2008 年密码学界逐渐提出了「用一个算法在内部同时实现加密和认证」的想法，也就是 AEAD，常用的 AEAD 算法有：<code>AES128/256_GCM</code>、AES128/256_EAX、AES128/256_CTR_HMAC_SHA256、<code>CHACHA20_POLY1305</code> 等</p>
<h3 id="☞-AES-GCM-vs-CHACHA20-POLY1305"><a href="#☞-AES-GCM-vs-CHACHA20-POLY1305" class="headerlink" title="☞ AES-GCM vs CHACHA20_POLY1305"></a>☞ AES-GCM vs CHACHA20_POLY1305</h3><p>对于 AES 这样的块加密算法来说，在某些硬件上运行的非常快，比如现在的服务器和台式机都有 <code>AES-NI</code> 加速指令。而如果没有加速指令，纯粹通过软件运行，性能是很低的。</p>
<p>而流密码算法刚好反过来，软件实现性能更高，大部分移动设备（比如手机）由于没有 AES-NI 支持，运行 AES 加密是很缓慢的。大部分观点认为，在移动设备上（没有 AES-NI 指令），ChaCha20-Poly1305 算法的性能是 AES-128-GCM 的三倍；当然在台式机和服务器上，AES-128-GCM 性能比 ChaCha20-Poly1305 更高。</p>
<hr>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<p><a href="https://en.wikipedia.org/wiki/Cryptographic_hash_function" target="_blank" rel="noopener">Cryptographic hash function</a><br><a href="https://zh.wikipedia.org/wiki/%E8%A8%8A%E6%81%AF%E9%91%91%E5%88%A5%E7%A2%BC" target="_blank" rel="noopener">消息认证码</a><br><a href="https://blog.csdn.net/l243224118/article/details/83932434" target="_blank" rel="noopener">消息认证码(MAC)解读</a><br><a href="http://www.flydean.com/hmac/" target="_blank" rel="noopener">HMAC算法及其应用</a><br><a href="https://blog.csdn.net/mutourend/article/details/100578436" target="_blank" rel="noopener">密码学中的AEAD(authenticated encryption with associated data)</a><br><a href="https://www.jianshu.com/p/4ca48cfeb4f4" target="_blank" rel="noopener">Java 11的新加密算法ChaCha20-Poly1305</a><br><a href="https://www.jianshu.com/p/9e46908750de" target="_blank" rel="noopener">HTTP协议-19.对称加密与非对称加密、数字签名与证书</a><br><a href="https://docs.aws.amazon.com/crypto/latest/userguide/cryptography-concepts.html" target="_blank" rel="noopener">Cryptography concepts</a><br><a href="https://www.jianshu.com/p/16e1cbc0b7a9" target="_blank" rel="noopener">分组密码算法的填充模式</a><br><a href="https://www.cnblogs.com/davidwang456/p/8386933.html" target="_blank" rel="noopener">分组密码的工作模式–wiki</a><br><a href="https://www.jianshu.com/p/dd5050c676d2" target="_blank" rel="noopener">DES/3DES算法 – 算法介绍</a><br><a href="https://www.jianshu.com/p/8c3657a1769f" target="_blank" rel="noopener">【易错概念】国密算法SM1（SCB2）、SM2、SM3、SM4、SM7、SM9、ZUC</a></p>
</blockquote>
]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>加密</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA 11</title>
    <url>/2020/04/25/java11/</url>
    <content><![CDATA[<p>Oracle 在 2014 年 3 月发布了 Java 8 正式版，5 年之后的 2018年 9 月，Java 11 正式版也和广大的 java 开发者见面，作为 Java8 后的首个长期支持版本，Java 11 也逐渐得到了开发者的青睐。根据 <a href="https://blog.newrelic.com/technology/state-of-java/" target="_blank" rel="noopener">New Relic</a> 发布的数据显示，截至 2020 年 3 月，Java 8 的使用量高达 <code>84.48%</code>，Java 11 则是 <code>11.11%</code>。</p>
<p>尽管普及程度还远远达不到 Java 8 的标准，但 Java 11 带来的各方面提升还是非常具有吸引力的，本文也将介绍在 Java 8 基础上 Java 11 都带了哪些新特性和性能提升。</p>
<a id="more"></a>

<hr>
<h2 id="为什么关注-Java-11"><a href="#为什么关注-Java-11" class="headerlink" title="为什么关注 Java 11"></a>为什么关注 Java 11</h2><p>从今天 Java 8 的普及程度我们大概可以预测 Java 11 的前景，作为 Java8 后的首个长期支持版本，技术支持时间直到 2023 年 9 月份，补丁和扩展支持直到 2026 年 9 月份（详情见：<a href="https://www.oracle.com/java/technologies/java-se-support-roadmap.html" target="_blank" rel="noopener">Oracle Java SE Support Roadmap</a>）。</p>
<p><img src="/images/jdk11/roadmap.png" alt="java-roadmap"></p>
<hr>
<h2 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h2><p>11 和 8 之间还经历了 2 个版本，虽然不是长期支持的版本，但还是要简单介绍一下。在介绍新特性之前我们先了解两个概念：</p>
<ul>
<li><strong>JSR</strong>：Java Specification Requests，Java 规范请求，由 JCP（Java Community Process，由社会各界 Java 组成的社区）成员向委员会提交的 Java 发展议案，经过一系列流程后，如果通过最终会体现在未来的 Java 中</li>
<li><strong>JEP</strong>：JDK Enhancement Proposal，JDK 增强提案，目的在于鼓励 OpenJDK 提交者贡献点子和扩展以改进 OpenJDK 生态圈，详情可以在 <a href="https://openjdk.java.net/jeps/1" target="_blank" rel="noopener">官网</a> 查看</li>
</ul>
<h3 id="Java-9"><a href="#Java-9" class="headerlink" title="Java 9"></a>Java 9</h3><p>经过 4 次跳票，历经曲折的 Java 9 终于终于在 2017 年 9 月 21 日发布（距离上个版本足足3年半时间），Java 9 提供了超过 150 项新功能特性，包括备受期待的<code>模块化系统</code>、<code>可交互的 REPL 工具：jshell</code>，<code>JDK 编译工具</code>，<code>Java 公共 API 和私有代码</code>，以及<code>安全增强</code>、<code>扩展提升</code>、<code>性能管理改善</code>等，它的新特性来自于 100 余项 JEP 和 40 余项 JSR。主要的特性（<a href="https://www.jcp.org/en/jsr/detail?id=379" target="_blank" rel="noopener">JSR 379</a>）如下：</p>
<ul>
<li>Platform<ul>
<li><a href="http://openjdk.java.net/jeps/220" target="_blank" rel="noopener">Modular Run-Time Images</a></li>
<li><a href="http://openjdk.java.net/jeps/261" target="_blank" rel="noopener">Module System</a><a href="https://jcp.org/en/jsr/detail?id=376" target="_blank" rel="noopener">(JSR 376)</a></li>
<li><a href="http://openjdk.java.net/jeps/238" target="_blank" rel="noopener">Multi-Release JAR Files</a></li>
<li><a href="http://openjdk.java.net/jeps/223" target="_blank" rel="noopener">New Version-String Scheme</a></li>
<li><a href="http://openjdk.java.net/jeps/200" target="_blank" rel="noopener">The Modular JDK</a></li>
</ul>
</li>
<li>Language<ul>
<li><a href="http://openjdk.java.net/jeps/211" target="_blank" rel="noopener">Elide Deprecation Warnings on Import Statements</a></li>
<li><a href="http://openjdk.java.net/jeps/286" target="_blank" rel="noopener">Local-Variable Type Inference</a></li>
<li><a href="http://openjdk.java.net/jeps/213" target="_blank" rel="noopener">Milling Project Coin</a></li>
</ul>
</li>
<li>Core Libraries<ul>
<li><a href="http://openjdk.java.net/jeps/269" target="_blank" rel="noopener">Convenience Factory Methods for Collections</a></li>
<li><a href="http://openjdk.java.net/jeps/277" target="_blank" rel="noopener">Enhanced Deprecation</a></li>
<li><a href="http://openjdk.java.net/jeps/274" target="_blank" rel="noopener">Enhanced Method Handles</a></li>
<li><a href="http://openjdk.java.net/jeps/264" target="_blank" rel="noopener">Platform Logging API and Service</a></li>
<li><a href="http://openjdk.java.net/jeps/102" target="_blank" rel="noopener">Process API Updates</a></li>
<li><a href="http://openjdk.java.net/jeps/285" target="_blank" rel="noopener">Spin-Wait Hints</a></li>
<li><a href="http://openjdk.java.net/jeps/193" target="_blank" rel="noopener">Variable Handles</a></li>
</ul>
</li>
<li>Networking<ul>
<li><a href="http://openjdk.java.net/jeps/110" target="_blank" rel="noopener">HTTP/2 Client</a></li>
</ul>
</li>
<li>Security<ul>
<li><a href="http://openjdk.java.net/jeps/229" target="_blank" rel="noopener">Create PKCS12 Keystores by Default</a></li>
<li><a href="http://openjdk.java.net/jeps/273" target="_blank" rel="noopener">DRBG-Based SecureRandom Implementations</a></li>
<li><a href="http://openjdk.java.net/jeps/219" target="_blank" rel="noopener">Datagram Transport Layer Security (DTLS)</a></li>
<li><a href="http://openjdk.java.net/jeps/249" target="_blank" rel="noopener">OCSP Stapling for TLS</a></li>
<li><a href="http://openjdk.java.net/jeps/244" target="_blank" rel="noopener">TLS Application-Layer Protocol Negotiation</a></li>
</ul>
</li>
<li>Client Libraries<ul>
<li><a href="http://openjdk.java.net/jeps/289" target="_blank" rel="noopener">Deprecate the Applet API</a></li>
<li><a href="http://openjdk.java.net/jeps/251" target="_blank" rel="noopener">Multi-Resolution Images</a></li>
<li><a href="http://openjdk.java.net/jeps/272" target="_blank" rel="noopener">Platform-Specific Desktop Features</a></li>
<li><a href="http://openjdk.java.net/jeps/262" target="_blank" rel="noopener">TIFF Image I/O</a></li>
</ul>
</li>
<li>XML<ul>
<li><a href="http://openjdk.java.net/jeps/268" target="_blank" rel="noopener">XML Catalogs</a></li>
</ul>
</li>
</ul>
<h3 id="Java-10"><a href="#Java-10" class="headerlink" title="Java 10"></a>Java 10</h3><p>在 Java9 之后，为了更快地迭代以及跟进社区反馈，Java 的版本发布周期变更为每六个月一次，并且承诺不会跳票。新的发布周期也会严格遵循时间点，将在每年的 3 月份和 9 月份发布。不负众望，Java 10 在 2018 年 3 月 14 如期和大家见面了。虽然只有短短的 6 个月，Java 10 还是带来了 109 项新的特性（<a href="https://www.jcp.org/en/jsr/detail?id=383" target="_blank" rel="noopener">JSR 383</a>），其中备受关注的是 <a href="https://openjdk.java.net/projects/jdk/10/" target="_blank" rel="noopener">12 个 JEP 特性增强提议</a>：</p>
<ul>
<li><a href="https://openjdk.java.net/jeps/286" target="_blank" rel="noopener">Local-Variable Type Inference</a></li>
<li><a href="https://openjdk.java.net/jeps/296" target="_blank" rel="noopener">Consolidate the JDK Forest into a Single Repository</a></li>
<li><a href="https://openjdk.java.net/jeps/304" target="_blank" rel="noopener">Garbage-Collector Interface</a></li>
<li><a href="https://openjdk.java.net/jeps/307" target="_blank" rel="noopener">Parallel Full GC for G1</a></li>
<li><a href="https://openjdk.java.net/jeps/310" target="_blank" rel="noopener">Application Class-Data Sharing</a></li>
<li><a href="https://openjdk.java.net/jeps/312" target="_blank" rel="noopener">Thread-Local Handshakes</a></li>
<li><a href="https://openjdk.java.net/jeps/313" target="_blank" rel="noopener">Remove the Native-Header Generation Tool (javah)</a></li>
<li><a href="https://openjdk.java.net/jeps/314" target="_blank" rel="noopener">Additional Unicode Language-Tag Extensions</a></li>
<li><a href="https://openjdk.java.net/jeps/316" target="_blank" rel="noopener">Heap Allocation on Alternative Memory Devices</a></li>
<li><a href="https://openjdk.java.net/jeps/317" target="_blank" rel="noopener">Experimental Java-Based JIT Compiler</a></li>
<li><a href="https://openjdk.java.net/jeps/319" target="_blank" rel="noopener">Root Certificates</a></li>
<li><a href="https://openjdk.java.net/jeps/322" target="_blank" rel="noopener">Time-Based Release Versioning</a></li>
</ul>
<h3 id="Java-11"><a href="#Java-11" class="headerlink" title="Java 11"></a>Java 11</h3><p>2018 年 9 月，收个长期支持版本发布，也就是今天的主角 Java 11，该版本带来了 90 项新的特性（<a href="https://www.jcp.org/en/jsr/detail?id=384" target="_blank" rel="noopener">JSR 384</a>），其中备受关注的还是 <a href="https://openjdk.java.net/projects/jdk/11/" target="_blank" rel="noopener">17 个 JEP 特性增强提议</a>：</p>
<ul>
<li><a href="https://openjdk.java.net/jeps/181" target="_blank" rel="noopener">Nest-Based Access Control</a></li>
<li><a href="https://openjdk.java.net/jeps/309" target="_blank" rel="noopener">Dynamic Class-File Constants</a></li>
<li><a href="https://openjdk.java.net/jeps/315" target="_blank" rel="noopener">Improve Aarch64 Intrinsics</a></li>
<li><a href="https://openjdk.java.net/jeps/318" target="_blank" rel="noopener">Epsilon: A No-Op Garbage Collector</a></li>
<li><a href="https://openjdk.java.net/jeps/320" target="_blank" rel="noopener">Remove the Java EE and CORBA Modules</a></li>
<li><a href="https://openjdk.java.net/jeps/321" target="_blank" rel="noopener">HTTP Client (Standard)</a></li>
<li><a href="https://openjdk.java.net/jeps/323" target="_blank" rel="noopener">Local-Variable Syntax for Lambda Parameters</a></li>
<li><a href="https://openjdk.java.net/jeps/324" target="_blank" rel="noopener">Key Agreement with Curve25519 and Curve448</a></li>
<li><a href="https://openjdk.java.net/jeps/327" target="_blank" rel="noopener">Unicode 10</a></li>
<li><a href="https://openjdk.java.net/jeps/328" target="_blank" rel="noopener">Flight Recorder</a></li>
<li><a href="https://openjdk.java.net/jeps/329" target="_blank" rel="noopener">ChaCha20 and Poly1305 Cryptographic Algorithms</a></li>
<li><a href="https://openjdk.java.net/jeps/330" target="_blank" rel="noopener">Launch Single-File Source-Code Programs</a></li>
<li><a href="https://openjdk.java.net/jeps/331" target="_blank" rel="noopener">Low-Overhead Heap Profiling</a></li>
<li><a href="https://openjdk.java.net/jeps/332" target="_blank" rel="noopener">Transport Layer Security (TLS) 1.3</a></li>
<li><a href="https://openjdk.java.net/jeps/333" target="_blank" rel="noopener">ZGC: A Scalable Low-Latency Garbage Collector(Experimental)</a></li>
<li><a href="https://openjdk.java.net/jeps/335" target="_blank" rel="noopener">Deprecate the Nashorn JavaScript Engine</a></li>
<li><a href="https://openjdk.java.net/jeps/336" target="_blank" rel="noopener">Deprecate the Pack200 Tools and API</a></li>
</ul>
<hr>
<h2 id="Java-8-升级到-Java-11-带来的改变"><a href="#Java-8-升级到-Java-11-带来的改变" class="headerlink" title="Java 8 升级到 Java 11 带来的改变"></a>Java 8 升级到 Java 11 带来的改变</h2><p>基于开源规划调度引擎 OptaPlanner 官网发布的 <a href="https://www.optaplanner.org/blog/2019/01/17/HowMuchFasterIsJava11.html" target="_blank" rel="noopener">Java 11 GC 性能基准测试报告</a> 显示，平均而言，仅通过切换到 Java 11 就有 16％ 的性能提升，这种提升可能是因为 Java 10 中引入了 <a href="https://openjdk.java.net/jeps/307" target="_blank" rel="noopener">JEP 307: Parallel Full GC for G1</a>。</p>
<p>那么主要有哪些改进的特性呢：</p>
<h3 id="本地变量类型推断"><a href="#本地变量类型推断" class="headerlink" title="本地变量类型推断"></a>本地变量类型推断</h3><blockquote>
<p>@since 9</p>
</blockquote>
<p>变量类型推断就是左边的类型直接使用 var 定义，而不用写具体的类型，编译器能根据右边的表达式自动推断类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> javastack = <span class="string">"javastack"</span>;</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String javastack = <span class="string">"javastack"</span>;</span><br></pre></td></tr></table></figure>

<h3 id="紧凑型的字符串"><a href="#紧凑型的字符串" class="headerlink" title="紧凑型的字符串"></a>紧凑型的字符串</h3><blockquote>
<p>@since 9</p>
</blockquote>
<p>从 Java 9 开始 String 数据承载由 char[] 改为 byte[] 紧凑的字符串，在很多时候只包含 Latin-1 里的字符，这些字符可节省一半内存。</p>
<h3 id="增强-api"><a href="#增强-api" class="headerlink" title="增强 api"></a>增强 api</h3><ul>
<li><p>字符串增强 </p>
<blockquote>
<p>@since 11</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断字符串是否为空白</span></span><br><span class="line"><span class="string">" "</span>.isBlank(); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 去除首尾空白</span></span><br><span class="line"><span class="string">" Javastack "</span>.strip(); <span class="comment">// "Javastack"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 去除尾部空格</span></span><br><span class="line"><span class="string">" Javastack "</span>.stripTrailing(); <span class="comment">// " Javastack"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 去除首部空格</span></span><br><span class="line"><span class="string">" Javastack "</span>.stripLeading(); <span class="comment">// "Javastack "</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 复制字符串</span></span><br><span class="line"><span class="string">"Java"</span>.repeat(<span class="number">3</span>);<span class="comment">// "JavaJavaJava"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 行数统计</span></span><br><span class="line"><span class="string">"A\nB\nC"</span>.lines().count(); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></li>
<li><p>集合增强</p>
<blockquote>
<p>@since 9</p>
</blockquote>
<p>从Java 9 开始，jdk 里面就为集合（List、Set、Map）增加了 of（since 9）和 copyOf（since 10）方法。它们用来创建不可变集合。</p>
<p>示例 1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> list = List.of(<span class="string">"Java"</span>, <span class="string">"Python"</span>, <span class="string">"C"</span>);</span><br><span class="line"><span class="keyword">var</span> copy = List.copyOf(list);</span><br><span class="line">System.out.println(list == copy);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"><span class="keyword">var</span> copy = List.copyOf(list);</span><br><span class="line">System.out.println(list == copy);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用 of 和 copyOf 创建的集合为不可变集合，不能进行添加、删除、替换、排序等操作，不然会报 java.lang.UnsupportedOperationException 异常；使用 Set.of() 不能出现重复元素、Map.of()不能出现重复 key，否则会报 java.lang.IllegalArgumentException。</p>
</blockquote>
</li>
<li><p>Stream 增强</p>
<blockquote>
<p>@since 9</p>
</blockquote>
<p>Stream 是Java 8 中的特性，在 Java 9 中为其新增了 4 个方法</p>
<ul>
<li>ofNullable(T t)<br>此方法可以接收null来创建一个空流<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以前</span></span><br><span class="line">Stream.of(<span class="keyword">null</span>); <span class="comment">//报错</span></span><br><span class="line"><span class="comment">// 现在</span></span><br><span class="line">Stream.ofNullable(<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure></li>
<li>takeWhile(Predicate&lt;? super T&gt; predicate)<br>此方法根据 Predicate 接口来判断如果为 true 就取出 来生成一个新的流，只要碰到 false 就终止，不管后边的元素是否符合条件。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;Integer&gt; integerStream = Stream.of(<span class="number">6</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">15</span>, <span class="number">20</span>);</span><br><span class="line">Stream&lt;Integer&gt; takeWhile = integerStream.takeWhile(t -&gt; t % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line">takeWhile.forEach(System.out::println); <span class="comment">// 6,10</span></span><br></pre></td></tr></table></figure></li>
<li>dropWhile(Predicate&lt;? super T&gt; predicate)<br>此方法根据 Predicate 接口来判断如果为 true 就丢弃来生成一个新的流，只要碰到 false 就终止，不管后边的元素是否符合条件。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;Integer&gt; integerStream = Stream.of(<span class="number">6</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">15</span>, <span class="number">20</span>);</span><br><span class="line">Stream&lt;Integer&gt; takeWhile = integerStream.dropWhile(t -&gt; t % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line">takeWhile.forEach(System.out::println); <span class="comment">//11,15,20</span></span><br></pre></td></tr></table></figure></li>
<li>iterate 重载<br>以前使用 iterate 方法生成无限流需要配合 limit 进行截断<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;Integer&gt; limit = Stream.iterate(<span class="number">1</span>, i -&gt; i + <span class="number">1</span>).limit(<span class="number">5</span>);</span><br><span class="line">limit.forEach(System.out::println); <span class="comment">//1,2,3,4,5</span></span><br></pre></td></tr></table></figure>
现在重载后这个方法增加了个判断参数<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;Integer&gt; iterate = Stream.iterate(<span class="number">1</span>, i -&gt; i &lt;= <span class="number">5</span>, i -&gt; i + <span class="number">1</span>);</span><br><span class="line">iterate.forEach(System.out::println); <span class="comment">//1,2,3,4,5</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Optional 增强</p>
<blockquote>
<p>@since 9</p>
</blockquote>
<ul>
<li>stream()<br>如果为空返回一个空流，如果不为空将Optional的值转成一个流。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回Optional值的流</span></span><br><span class="line">Stream&lt;String&gt; stream = Optional.of(<span class="string">"Java 11"</span>).stream();</span><br><span class="line">stream.forEach(System.out::println); <span class="comment">// Java 11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回空流</span></span><br><span class="line">Stream&lt;Object&gt; stream = Optional.ofNullable(<span class="keyword">null</span>).stream();</span><br><span class="line">stream.forEach(System.out::println); <span class="comment">//</span></span><br></pre></td></tr></table></figure></li>
<li>ifPresentOrElse(Consumer&lt;? super T&gt; action, Runnable emptyAction)<br>如果一个 Optional 包含值，则对其包含的值调用函数 action，即 action.accept(value)，这与 ifPresent 一致；与 ifPresent 方法的区别在于，ifPresentOrElse 还有第二个参数 emptyAction —— 如果 Optional 不包含值，那么 ifPresentOrElse 便会调用 emptyAction，即 emptyAction.run()。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;Integer&gt; optional = Optional.of(<span class="number">1</span>);</span><br><span class="line">optional.ifPresentOrElse( x -&gt; System.out.println(<span class="string">"Value: "</span> + x),() -&gt;</span><br><span class="line">System.out.println(<span class="string">"Not Present."</span>)); <span class="comment">//Value: 1</span></span><br><span class="line"></span><br><span class="line">optional = Optional.empty();</span><br><span class="line">optional.ifPresentOrElse( x -&gt; System.out.println(<span class="string">"Value: "</span> + x),() -&gt;</span><br><span class="line">System.out.println(<span class="string">"Not Present."</span>)); <span class="comment">//Not Present.</span></span><br></pre></td></tr></table></figure></li>
<li>or(Supplier&lt;? extends Optional&lt;? extends T&gt;&gt; supplier)<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;String&gt; optional1 = Optional.of(<span class="string">"Java"</span>);</span><br><span class="line">Supplier&lt;Optional&lt;String&gt;&gt; supplierString = () -&gt; Optional.of(<span class="string">"Not Present"</span>);</span><br><span class="line">optional1 = optional1.or( supplierString);</span><br><span class="line">optional1.ifPresent( x -&gt; System.out.println(<span class="string">"Value: "</span> + x)); <span class="comment">//Value: Java</span></span><br><span class="line">optional1 = Optional.empty();</span><br><span class="line">optional1 = optional1.or( supplierString);</span><br><span class="line">optional1.ifPresent( x -&gt; System.out.println(<span class="string">"Value: "</span> + x)); <span class="comment">//Value: Not Present</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>InputStream 增强 </p>
<blockquote>
<p>@since 9</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String lxs = <span class="string">"java"</span>;</span><br><span class="line"><span class="keyword">try</span> (<span class="keyword">var</span> inputStream = <span class="keyword">new</span> ByteArrayInputStream(lxs.getBytes());</span><br><span class="line">  <span class="keyword">var</span> outputStream = <span class="keyword">new</span> ByteArrayOutputStream()) &#123;</span><br><span class="line">  inputStream.transferTo(outputStream);</span><br><span class="line">  System.out.println(outputStream); <span class="comment">// java</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>HTTP Client API</p>
<blockquote>
<p>@since 11</p>
</blockquote>
<p>支持同步和异步两种方式，下面是两种方式的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">var</span> request = HttpRequest.newBuilder()</span><br><span class="line">.uri(URI.create(<span class="string">"https://www.58.com/"</span>))</span><br><span class="line">.build();</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">var</span> client = HttpClient.newHttpClient();</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 同步</span></span><br><span class="line"> HttpResponse&lt;String&gt; response = client.send(request, HttpResponse.BodyHandlers.ofString());</span><br><span class="line"> System.out.println(response.body());</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 异步</span></span><br><span class="line"> CompletableFuture&lt;HttpResponse&lt;String&gt;&gt; sendAsync = client.sendAsync(request, HttpResponse.BodyHandlers.ofString());</span><br><span class="line"> <span class="comment">//这里会阻塞</span></span><br><span class="line"> HttpResponse&lt;String&gt; response1 = sendAsync.get();</span><br><span class="line"> System.out.println(response1.body());</span><br></pre></td></tr></table></figure>
</li>
<li><p>完全支持Linux容器（包括docker）</p>
<blockquote>
<p>@since 10</p>
</blockquote>
<p>许多运行在 Java 虚拟机中的应用程序（包括 Apache Spark 和 Kafka 等数据服务以及传统的企业应用程序）都可以在 Docker 容器中运行。但是在 Docker 容器中运行 Java 应用程序一直存在一个问题，那就是在容器中运行 JVM 程序在设置内存大小和 CPU 使用率后，会导致应用程序的性能下降。这是因为 Java 应用程序没有意识到它正在容器中运行。随着 Java 10 的发布，这个问题总算得以解决，JVM 现在可以识别由容器控制组（cgroups）设置的约束。可以在容器中使用内存和 CPU 约束来直接管理 Java 应用程序，其中包括：</p>
<ul>
<li>遵守容器中设置的内存限制</li>
<li>在容器中设置可用的CPU</li>
<li>在容器中设置CPU约束</li>
</ul>
</li>
<li><p>移除内容</p>
<ul>
<li>com.sun.awt.AWTUtilities。</li>
<li>sun.misc.Unsafe.defineClass 使用java.lang.invoke.MethodHandles.Lookup.defineClass来替代。</li>
<li>Thread.destroy() 以及 Thread.stop(Throwable) 方法。</li>
<li>sun.nio.ch.disableSystemWideOverlappingFileLockCheck 属性。</li>
<li>sun.locale.formatasdefault 属性。</li>
<li>jdk snmp 模块。</li>
<li>javafx，openjdk 是从 java10 版本就移除了，oracle java10 还尚未移除 javafx ，而 java11 版本将 javafx 也移除了。</li>
<li>Java Mission Control，从 JDK 中移除之后，需要自己单独下载。</li>
<li>Root Certificates ：Baltimore Cybertrust Code Signing CA，SECOM ，AOL and Swisscom。</li>
<li>在 java11 中将 java9 标记废弃的 Java EE 及 CORBA模 块移除掉。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="Java-11-收费吗？"><a href="#Java-11-收费吗？" class="headerlink" title="Java 11 收费吗？"></a>Java 11 收费吗？</h2><p>最后说一个大家比较关心的问题，Java 11 收费吗？</p>
<p>我们都知道，Oracle 在 Java 8 的时候开启了 JDK 的收费模式，具体来说 Oracle 将继续提供 JDK 8 免费的公共更新和自动更新，支持个人用户到 2020 年 12 月底，支持商业用户到 2019 年 1 月；换句话说如果想 Oracle 后续继续为你提供 JDK 8 的支持，那么则需要付费。</p>
<p>Oracle JDK 从 11 之后使用了 <code>OTN 协议</code>（即 Oracle Technology Network License Agreement），简单的说就是可以私用，商用需要付费。不过 Oracle 在发布 JDK 时会同时发布两个不同版本，分别为 <code>Oracle JDK</code> 和 <code>OpenJDK</code>, 这两个版本除了所附带的许可文件不一样（OpenJDK 支持 GPL 协议），刚发布的版本几乎完全相同。至于更新计划可以看下图：</p>
<p><img src="/images/jdk11/JavaReleaseSystematik.jpg" alt="JavaReleaseSystematik"></p>
<p>针对 OpenJDK 11 来说，应该有 JDK 11.0.0，然后是两个安全补丁 11.0.1 和 11.0.2，如果需要继续使用 Oracle 的 OpenJDK 构建和安全补丁，那么须在发布后的一个月内迁移到 JDK 12。</p>
<p><img src="/images/jdk11/java-roadmap.png" alt="java-roadmap"></p>
<p><em>PS: 不得不吐槽一下 Oracle 确实很坑，希望 Java 不会在他手上没落；以前一直以为微软很封闭，现在真的是刮目相看</em></p>
<p>除了 OpenJDK 外，还有很多开源 JDK 产品：</p>
<ul>
<li><a href="http://adoptopenjdk.net/" target="_blank" rel="noopener">AdoptOpenJDK</a></li>
<li><a href="https://developers.redhat.com/products/openjdk/download" target="_blank" rel="noopener">Red Hat OpenJDK</a></li>
<li><a href="https://zulu.org/" target="_blank" rel="noopener">Azul Zulu</a></li>
<li><a href="https://sap.github.io/SapMachine/" target="_blank" rel="noopener">SAP</a></li>
</ul>
<hr>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<p><a href="https://www.toutiao.com/i6796064802574696963/?tt_from=weixin&utm_campaign=client_share&wxshare_count=1&timestamp=1587818043&app=news_article&utm_source=weixin&utm_medium=toutiao_android&req_id=20200425203402010130037138445BA3E5&group_id=6796064802574696963" target="_blank" rel="noopener">「是时候升级Java11了」 JDK11优势和JDK选择</a><br><a href="https://www.jianshu.com/p/548c8ece1c95" target="_blank" rel="noopener">Java8及新版本许可证及收费？</a><br><a href="https://yq.aliyun.com/articles/645952" target="_blank" rel="noopener">JDK 11 是发布了，但收费吗？</a><br><a href="https://www.promatis.de/en/2018/09/30/what-is-behind-the-new-license-model-of-oracle-java/" target="_blank" rel="noopener">What is behind the new license model of Oracle Java?</a><br><a href="http://www.360doc.com/content/18/1123/15/48481448_796736124.shtml" target="_blank" rel="noopener">java9新特性（简述十大新特性）</a><br><a href="https://www.oschina.net/translate/109-new-features-in-jdk-10" target="_blank" rel="noopener">JDK 10 的 109 项新特性（译）</a><br><a href="https://cn.azul.com/90-new-features-and-apis-in-jdk-11/" target="_blank" rel="noopener">90 New Features (and APIs) in JDK 11</a><br><a href="https://www.jianshu.com/p/6e08454cc8ac" target="_blank" rel="noopener">Java11正式发布，要不要升级请看这里！</a><br><a href="https://www.oschina.net/news/103704/how-much-faster-is-java-11" target="_blank" rel="noopener">Java 11 究竟比 8 快了多少？看看这个基准测试</a></p>
</blockquote>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>Nested-Loop Join，Hash Join，Sort Merge Join</title>
    <url>/2020/03/31/Nested_Loop-Hash_Join-Merge_Join/</url>
    <content><![CDATA[<p>我们都知道 MySQL 8 中推出了一种新的算法 Hash Join，大家对这个新特性也都非常的兴奋，那究竟什么是 Hash Join 呢，它比现在 MySQL 使用的 Nested-Loop Join 有什么优势呢，下面我们将介绍一下数据库中常用的三个 join 算法（Nested-Loop Join、Hash Join、Sort Merge Join）以及它们之前的区别和联系。</p>
<a id="more"></a>

<h2 id="Nested-Loop-Join"><a href="#Nested-Loop-Join" class="headerlink" title="Nested-Loop Join"></a>Nested-Loop Join</h2><p>Nested-Loop 是通过两层循环，用第一张表做 Outter Loop，第二张表做 Inner Loop，Outter Loop 的每一条记录跟 Inner Loop 的记录作比较，符合条件的就输出。Nested-Loop Join 又有 3 种细分的算法：</p>
<h3 id="Simple-Nested-Loop-Join（SNLJ）"><a href="#Simple-Nested-Loop-Join（SNLJ）" class="headerlink" title="Simple Nested-Loop Join（SNLJ）"></a>Simple Nested-Loop Join（SNLJ）</h3><p>SNLJ 就是两层循环全量扫描连接的两张表，得到符合条件的两条记录则输出，这也就是让两张表做笛卡尔积，比较次数是 R * S，是比较暴力的算法，会比较耗时。</p>
<p><img src="/images/join/snlj.webp" alt="snlj"></p>
<h3 id="Index-Nested-Loop-Join（INLJ）"><a href="#Index-Nested-Loop-Join（INLJ）" class="headerlink" title="Index Nested-Loop Join（INLJ）"></a>Index Nested-Loop Join（INLJ）</h3><p>INLJ 是在 SNLJ 的基础上做了优化，通过连接条件确定可用的索引，在 Inner Loop 中扫描索引而不去扫描数据本身，从而提高 Inner Loop 的效率。<br>而 INLJ 也有缺点，就是如果扫描的索引是非聚簇索引，并且需要访问非索引的数据，会产生一个回表读取数据的操作，这就多了一次随机的 I/O 操作。</p>
<p><img src="/images/join/inlj.webp" alt="inlj"></p>
<h3 id="Block-Nested-Loop-Join（BNLJ）"><a href="#Block-Nested-Loop-Join（BNLJ）" class="headerlink" title="Block Nested-Loop Join（BNLJ）"></a>Block Nested-Loop Join（BNLJ）</h3><p>一般情况下，MySQL 优化器在索引可用的情况下，会优先选择使用 INLJ 算法，但是在无索引可用或者判断 full scan 可能比使用索引更快的情况下，还是不会选择使用过于粗暴的 SNLJ 算法。<br>这里就出现了 BNLJ 算法了，BNLJ 在 SNLJ 的基础上使用了 <code>join buffer</code>，会提前读取 Inner Loop 所需要的记录到 buffer 中，以提高 Inner Loop 的效率。</p>
<p><img src="/images/join/bnlj.webp" alt="bnlj"></p>
<hr>
<h2 id="Sort-Merge-Join"><a href="#Sort-Merge-Join" class="headerlink" title="Sort Merge Join"></a>Sort Merge Join</h2><p>Sort Merge Join 又叫 Merge Join，简单说来就是将 Join 的两个表，首先根据连接属性进行排序，然后进行一次扫描归并, 进而就可以得出最后的结果。从改算法的特性可以看出，该算法最大的消耗在于对内外表数据进行排序，而当连接列为索引列时，我们可以利用索引的有序性避免排序带来的消耗。</p>
<hr>
<h2 id="Hash-Join"><a href="#Hash-Join" class="headerlink" title="Hash Join"></a>Hash Join</h2><p>Hash Join 可以在被驱动表没有索引的情况下进行快速的连接并查询，优化器使用两个表中较小（相对较小）的表利用 Join Key 在内存中建立散列表，然后扫描较大的表并探测散列表，找出与 Hash 表匹配的行。这种方式适用于较小的表完全可以放于内存中的情况，这样总成本就是访问两个表的成本之和。但是在表很大的情况下并不能完全放入内存，这时优化器会将它分割成若干不同的分区，不能放入内存的部分就把该分区写入磁盘的临时段，此时要求有较大的临时段从而尽量提高 I/O 的性能。它能够很好的工作于没有索引的大表和并行查询的环境中，并提供最好的性能。Hash Join 只能应用于等值连接(如WHERE A.COL3 = B.COL4)，这是由 Hash 的特点决定的。</p>
<p>详细的执行过程见：<a href="https://www.jianshu.com/p/29eeb3ec4bc2" target="_blank" rel="noopener">技术分享 | Hash join in MySQL 8</a></p>
<hr>
<h2 id="几种-JOIN-算法对比"><a href="#几种-JOIN-算法对比" class="headerlink" title="几种 JOIN 算法对比"></a>几种 JOIN 算法对比</h2><table>
<thead>
<tr>
<th>join 算法</th>
<th>Nested-Loop Join</th>
<th>Merge Join</th>
<th>Hash Join</th>
</tr>
</thead>
<tbody><tr>
<td>使用条件</td>
<td>任何条件</td>
<td>等值或非等值连接(&gt;，&lt;，=，&gt;=，&lt;=)，‘&lt;&gt;’除外</td>
<td>等值连接（=）</td>
</tr>
<tr>
<td>相关资源</td>
<td>CPU、磁盘I/O</td>
<td>内存、临时空间</td>
<td>内存、临时空间</td>
</tr>
<tr>
<td>特点</td>
<td>当有高选择性索引或进行限制性搜索时效率比较高，能够快速返回第一次的搜索结果</td>
<td>当缺乏索引或者索引条件模糊时，Merge Join 比 Nested Loop 有效。非等值连接时，Merge Join比 Hash Join 更有效</td>
<td>当缺乏索引或者索引条件模糊时，Hash Join 比 Nested Loop 有效。通常比 Merge Join 快。在数据仓库环境下，如果表的纪录数多，效率高</td>
</tr>
<tr>
<td>缺点</td>
<td>当索引丢失或者查询条件限制不够时，效率很低；当表的纪录数多时，效率低</td>
<td>所有的表都需要排序。它为最优化的吞吐量而设计，并且在结果没有全部找到前不返回数据</td>
<td>建立哈希表需要大量内存，第一次的结果返回较慢</td>
</tr>
</tbody></table>
<hr>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<p><a href="http://www.jasongj.com/2015/03/07/Join1/" target="_blank" rel="noopener">http://www.jasongj.com/2015/03/07/Join1/</a><br><a href="https://www.jianshu.com/p/741a6d4efc44" target="_blank" rel="noopener">https://www.jianshu.com/p/741a6d4efc44</a><br><a href="https://zhuanlan.zhihu.com/p/41535500" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/41535500</a><br><a href="https://zhuanlan.zhihu.com/p/94065716" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/94065716</a><br><a href="https://www.jianshu.com/p/d128fef9e747" target="_blank" rel="noopener">https://www.jianshu.com/p/d128fef9e747</a></p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Nested-Loop Join</tag>
        <tag>Hash Join</tag>
        <tag>Sort Merge Join</tag>
      </tags>
  </entry>
  <entry>
    <title>B树，B+树及LSM树对比</title>
    <url>/2020/03/22/btree_b+tree_lsm/</url>
    <content><![CDATA[<p>对开发人员来说熟悉数据库是一项非常重要的技能，为了保证数据库的性能 B树、B+树、LSM树广泛应用在了各种数据库产品中。<code>B树</code>和<code>B+树</code>一般应用于文件存储系统以及数据库系统中，如我们非常常见的 Mysql InnoDB 引擎就是采用了B+树实现的索引结构；<code>LSM树</code>则在诸如 <a href="http://hbase.apache.org/" target="_blank" rel="noopener">Apache HBase</a>、<a href="https://cassandra.apache.org/" target="_blank" rel="noopener">Apache Cassandra</a>、<a href="https://blog.csdn.net/baijiwei/article/details/80506121" target="_blank" rel="noopener">MongoDB 的 Wired Tiger 存储引擎</a>、<a href="https://blog.csdn.net/Double2hao/article/details/90107904" target="_blank" rel="noopener">LevelDB</a>、<a href="https://rocksdb.org.cn/" target="_blank" rel="noopener">RocksDB</a>、<a href="https://pingcap.com/index.html" target="_blank" rel="noopener">TiDB</a> 等产品中都有应用。</p>
<a id="more"></a>

<hr>
<h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><p>全称 Balance-tree（平衡多路查找树），<code>平衡</code> 的意思是左边和右边分布均匀；<code>多路</code>的意思是相对于二叉树而言的，二叉树就是二路查找树，查找时只有两条路，而 B树 有多条路，即父节点有多个子节点。</p>
<p>B树是为磁盘或其它直接存取的辅助存储设备而设计的一种平衡搜索树，它类似于红黑树，但它在降低磁盘 I/O 操作上更好。</p>
<h3 id="结构特点"><a href="#结构特点" class="headerlink" title="结构特点"></a>结构特点</h3><p>名词介绍</p>
<blockquote>
<ul>
<li><strong>阶</strong>：一棵 m 阶 B-tree，每个结点至多可以拥有 m 个子结点，即遍观整棵树，子节点最多的个数是 m，那么这棵树就是 m 阶树。</li>
<li><strong>度</strong>：树的度就是树的高度，即树的层数。</li>
</ul>
</blockquote>
<h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul>
<li>根节点至少有两个子节点</li>
<li>每个中间节点都包含 k-1 个数据和 k 个孩子，其中 m/2 &lt;= k &lt;= m</li>
<li>每个叶子节点都包含 k-1 个数据，其中 m/2 &lt;= k &lt;= m</li>
<li>所有的叶子结点都位于同一层</li>
<li>每个节点中的数据都按照从小到大的顺序排列，每个数据左子树中的所有数据都小于它，而右子树中的所有数据都大于它</li>
</ul>
<p><img src="/images/20200322/B-tree.png" alt="b-tree"></p>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p>
<ul>
<li>使用层次化的索引来最小化磁盘读取</li>
<li>使用不完全填充的块来加速插入和删除</li>
<li>通过优雅的遍历算法来保持索引平衡</li>
</ul>
<p>缺点：</p>
<ul>
<li>每个节点中既要存索引信息，又要存其对应的数据，如果数据很大，那么当树的体量很大时，每次读到内存中的树的信息就会不太够</li>
<li>B树遍历整个树的过程和二叉树本质上是一样的，B树相对二叉树虽然提高了磁盘IO性能，但并没有解决遍历元素效率低下的问题</li>
</ul>
<hr>
<h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p>B树的变体，它把所有的数据都存储在叶节点中，中间节点只存放 <code>关键字</code> 和 <code>子节点指针</code>，因此最大化了中间节点的分支因子，所以B+树的遍历也更加高效(<code>B树需要以中序的方式遍历节点，而B+树只需把所有叶子节点串成链表就可以从头到尾遍历</code>)。</p>
<h3 id="结构特点-1"><a href="#结构特点-1" class="headerlink" title="结构特点"></a>结构特点</h3><p>一棵 B+ 树需要满足以下条件：</p>
<ul>
<li>节点的子树数和关键字数相同</li>
<li>节点的关键字表示的是子树中的最大数，在子树中同样含有这个数据</li>
<li>叶子节点包含了全部数据，同时符合左小右大的顺序</li>
</ul>
<p><img src="/images/20200322/Bplustree.png" alt="Bplustree"></p>
<h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p>
<ul>
<li>中间节点不包含数据，同样大小的磁盘页可以容纳更多的节点元素，这就意味着在数据量相同的情况下，B+树更加的矮胖，因此IO的次数也就较少</li>
<li>B+树查询必须查找到叶子节点，每一次查找都是稳定的</li>
<li>所有叶子节点形成有序链表，便于范围查询，远远高于B树</li>
</ul>
<p>缺点：<br>在一些情况下会产生大量的随机IO，如</p>
<ul>
<li>主键不是有序递增的，导致每次插入数据产生大量的数据迁移和空间碎片</li>
<li>使主键是有序递增的，大量写请求的分布仍是随机的</li>
</ul>
<hr>
<h2 id="LSM-树"><a href="#LSM-树" class="headerlink" title="LSM 树"></a>LSM 树</h2><p>即日志结构合并树(Log-Structured Merge-Tree)，传统关系型数据库使用b树或一些变体作为存储结构，能高效进行查找。但保存在磁盘中时它也有一个明显的缺陷，那就是逻辑上相离很近但物理却可能相隔很远，这就可能造成大量的磁盘随机读写。随机读写比顺序读写慢很多，为了提升IO性能，我们需要一种能将随机操作变为顺序操作的机制，于是便有了 LSM 树。<code>LSM 树能让我们进行顺序写磁盘，从而大幅提升写操作，作为代价的是牺牲了一些读性能</code>。</p>
<h3 id="结构特点-2"><a href="#结构特点-2" class="headerlink" title="结构特点"></a>结构特点</h3><p>LSM 树使用两部分类树的数据结构存储数据，并同时提供查询。其中一部分数据结构（C0）存于内存中（memtable），<code>负责接受新的数据插入、更新及查询的请求，并直接在内存中对数据进行排序</code>；另一部分数据结构（C1）存于硬盘上，由 C0 写入磁盘（sstable）而成，<code>主要提供读的操作，特点是有序且不会被修改</code>；LSM 树会使用日志文件（commit log）来为<code>数据恢复</code>提供保障。</p>
<img src="/images/20200322/LSM.jpg" width="300px" align=center>

<p>三类数据结构的协作顺序是：<code>所有新插入和更新操作先被记录到 commit log，最后达到一定条件时会从 memtable 写入 sstable，并抛弃相关的 log 数据</code>；</p>
<h3 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h3><p>这种数据结构的特点：非常适合数据的快速写入，但不利于读，因此 LSM 树采用了以下策略：</p>
<ul>
<li>定期将硬盘上小的 sstable 合并（Merge）成大的 sstable，以减少 sstable 数量，合并时也会将重复的操作或合并或更新去重</li>
<li>对每个 sstable 使用布隆过滤器（Bloom filter），以加速对数据在该 sstable 的存在性进行判定，从而减少数据查询的总时间</li>
</ul>
<p>WTable 为58同城基于 RocksDB 实现的一个高性能 Key Value 存储平台，针对 LSM 树的 Compaction 问题做了一些优化，详情可以阅读《<a href="https://tech.58.com/#/article?id=27" target="_blank" rel="noopener">58同城RocksDB使用技巧之分布式存储扩容演进</a>》。</p>
<p>字节跳动内部大量的数据库产品（如图数据库、NewSQL 等）都构建在 RocksDB 之上，也对 RocksDB 存储引擎做了几方面的改进，详情可以阅读《<a href="https://www.toutiao.com/i6806261982442816013/?tt_from=weixin&utm_campaign=client_share&wxshare_count=1&timestamp=1585061583&app=news_article&utm_source=weixin&utm_medium=toutiao_android&req_id=202003242253030101300371380A1BEEC8&group_id=6806261982442816013" target="_blank" rel="noopener">字节跳动在 RocksDB 存储引擎上的改进实践</a>》。</p>
<hr>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<p><a href="https://www.zhihu.com/question/19887265" target="_blank" rel="noopener">https://www.zhihu.com/question/19887265</a><br><a href="https://www.jianshu.com/p/3fb899684392" target="_blank" rel="noopener">https://www.jianshu.com/p/3fb899684392</a><br><a href="https://blog.csdn.net/u010916338/article/details/86134334" target="_blank" rel="noopener">https://blog.csdn.net/u010916338/article/details/86134334</a><br><a href="https://zh.wikipedia.org/wiki/B%E6%A0%91" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/B%E6%A0%91</a><br><a href="https://zh.wikipedia.org/wiki/B%2B%E6%A0%91" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/B%2B%E6%A0%91</a><br><a href="https://www.cnblogs.com/nullzx/p/8729425.html" target="_blank" rel="noopener">https://www.cnblogs.com/nullzx/p/8729425.html</a><br><a href="https://blog.csdn.net/yangguosb/article/details/81903583" target="_blank" rel="noopener">https://blog.csdn.net/yangguosb/article/details/81903583</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>B树</tag>
        <tag>B+树</tag>
        <tag>LSM树</tag>
      </tags>
  </entry>
  <entry>
    <title>程序猫炸炸</title>
    <url>/2020/03/19/zhazha_read_code/</url>
    <content><![CDATA[<p>炸炸化身程序猫，这是要给我找 BUG 吗 😂</p>
<a id="more"></a>

<div id="dplayer0" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px; height:450px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"autoplay":true,"video":{"url":"/video/zhazha_video_01.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script>]]></content>
      <categories>
        <category>炸炸</category>
      </categories>
      <tags>
        <tag>炸炸</tag>
        <tag>视频</tag>
      </tags>
  </entry>
  <entry>
    <title>Chrome 80 带来的 Cookie 新策略 SameSite 是什么？</title>
    <url>/2020/03/11/chrome_samesite/</url>
    <content><![CDATA[<p>2020年2月4日谷歌正式宣布了 Chrome 80 稳定版的到来，值得关注的<a href="https://www.bleepingcomputer.com/news/google/chrome-80-released-with-56-security-fixes-cookie-changes-more/?__cf_chl_jschl_tk__=bf60ebcbcc1329f5a908209b354f6d1db3ec73e8-1584753774-0-AftLNYItNWkE3mlPUgL-2Sl2ckSAVfmk5JwcGmabsGeSIr1ab0p8dpHtq-ih-S1-1tse5FrxLufVGtQ1zMw7XBIfg49-Y8UkYsDMEypnRnZZEOk1pwQoaaOYQB6dEgl_V2yZE2RctP-J2HrqPoFNOrkOr9rAblTE4XinPrMlB_zA-pIoZAqZbrsSvJ6S76cv50M0a3EZk6BRJMo0jhBDL0Yw1KnHK_A6WraKF_0gQAEnvufRW0yBVcw_7YVFlUGzTr-dDzd9QLvnGSuPG6ko6g1rYLRZN2yURaF-Ae_pLdcyavgwiAkmWowk3BC2jZQWfkBE0BreIx39ynlPNrjVAI9hm-B9AOH7ECcQ7IubdcvXk5XvuWL4hPNXxM1RkdMo-w" target="_blank" rel="noopener">主要更新</a>如下：</p>
<ul>
<li>引入全新的 cookie 分类模型 SameSite</li>
<li>静默通知</li>
<li>将所有混合音频和视频资源自动升级为 HTTPS</li>
<li>移除对 FTP 的支持</li>
<li>标签分组，每组可配置个性化颜色</li>
<li>支持 SVG 格式的图像，进一步降低站点资源占用</li>
<li>上线联系人选取和内容索引 API</li>
</ul>
<p>新的版本进一步加强了安全性等，对 cookie 的校验策略也更加严格…</p>
<a id="more"></a>

<hr>
<h2 id="Cookie-策略调整"><a href="#Cookie-策略调整" class="headerlink" title="Cookie 策略调整"></a>Cookie 策略调整</h2><p>简单来说，在 Chrome 80 中，Chrome 会将没有声明 SameSite 值的 cookie 默认设置为 <code>SameSite=Lax</code>，只有采用 <code>SameSite=None; Secure</code> 设置的 cookie 可以从外部访问，前提是通过安全连接（即 HTTPS）访问。</p>
<h2 id="SameSite"><a href="#SameSite" class="headerlink" title="SameSite"></a>SameSite</h2><p>Chrome 51 开始，浏览器的 Cookie 新增加了一个 SameSite 属性，用来防止 CSRF 攻击和用户追踪，它可以设置三个值：</p>
<ul>
<li>Strict</li>
<li>Lax</li>
<li>None</li>
</ul>
<h3 id="Strict"><a href="#Strict" class="headerlink" title="Strict"></a>Strict</h3><p>完全禁止第三方 Cookie，跨站点时，任何情况下都不会发送 Cookie。</p>
<h3 id="Lax"><a href="#Lax" class="headerlink" title="Lax"></a>Lax</h3><p>大多数情况也是不发送第三方 Cookie，但是导航到目标网址的 Get 请求除外，导航到目标网址的 GET 请求，只包括三种情况：链接，预加载请求，GET 表单。详见下表：</p>
<table>
<thead>
<tr>
<th>请求类型</th>
<th>示例</th>
<th>Lax</th>
</tr>
</thead>
<tbody><tr>
<td>链接</td>
<td><code>html &lt;a href=&quot;...&quot;&gt;&lt;/a&gt;</code></td>
<td>发送 Cookie</td>
</tr>
<tr>
<td>预加载</td>
<td><code>html &lt;link rel=&quot;prerender&quot; href=&quot;...&quot;/&gt;</code></td>
<td>发送 Cookie</td>
</tr>
<tr>
<td>GET 表单</td>
<td><code>html &lt;form method=&quot;GET&quot; action=&quot;...&quot;&gt;</code></td>
<td>发送 Cookie</td>
</tr>
<tr>
<td>POST 表单</td>
<td><code>html &lt;form method=&quot;POST&quot; action=&quot;...&quot;&gt;</code></td>
<td>不发送</td>
</tr>
<tr>
<td>iframe</td>
<td><code>html &lt;iframe src=&quot;...&quot;&gt;&lt;/iframe&gt;</code></td>
<td>不发送</td>
</tr>
<tr>
<td>AJAX</td>
<td><code>html $.get(&quot;...&quot;)</code></td>
<td>不发送</td>
</tr>
<tr>
<td>Image</td>
<td><code>html &lt;img src=&quot;...&quot;&gt;</code></td>
<td>不发送</td>
</tr>
</tbody></table>
<p>在 chrome 80 中，Chrome 会将没有声明 SameSite 值的 cookie 默认设置为 <code>SameSite=Lax</code>（以前默认值为 <code>SameSite=None</code>），对基于 <code>POST 表单</code>、<code>iframe</code>、<code>AJAX</code>、<code>Image</code> 方式的跨站请求将会出现因无法携带 cookie 而导致网站无法正常打开的问题。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方式一：配置-chrome"><a href="#方式一：配置-chrome" class="headerlink" title="方式一：配置 chrome"></a>方式一：配置 chrome</h3><ol>
<li>浏览器里输入 <a href="chrome://flags/">chrome://flags/</a></li>
<li>查找 same-site-by-default-cookies 设置项，设置为 disabled<br><img src="/images/chrome-samesite.png" alt="same-site-by-default-cookies"></li>
</ol>
<h3 id="方式二：配置-chrome"><a href="#方式二：配置-chrome" class="headerlink" title="方式二：配置 chrome"></a>方式二：配置 chrome</h3><p>开发者网站的 cookie 需要设置 <code>SameSite=None; Secure</code>，同时网站域名需要基于 https。</p>
<hr>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<p><a href="https://www.oschina.net/news/113190/chrome-80-stable-released" target="_blank" rel="noopener">https://www.oschina.net/news/113190/chrome-80-stable-released</a><br><a href="https://baijiahao.baidu.com/s?id=1657599977359683459&wfr=spider&for=pc" target="_blank" rel="noopener">https://baijiahao.baidu.com/s?id=1657599977359683459&amp;wfr=spider&amp;for=pc</a><br><a href="https://www.chromestatus.com/features/schedule" target="_blank" rel="noopener">https://www.chromestatus.com/features/schedule</a><br><a href="http://www.ruanyifeng.com/blog/2019/09/cookie-samesite.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2019/09/cookie-samesite.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>cookie</tag>
        <tag>chrome</tag>
      </tags>
  </entry>
  <entry>
    <title>普吉岛6日游</title>
    <url>/2020/01/24/journey_%20phuket/</url>
    <content><![CDATA[<p>忙碌了一年，趁着假期享受一下传说中的阳光、海水、沙滩 🌞🌊🏖︎</p>
<a id="more"></a>

<h2 id="行程"><a href="#行程" class="headerlink" title="行程"></a>行程</h2><p>普吉岛 Kingpower 免税店、西蒙人妖秀、珊瑚岛、皇帝岛、椰树岛海滩度假村、包车环岛一日游</p>
<h2 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h2><p>海岛很美，水很蓝，沙子特别软，阳光足；人妖秀远远超出了预期，一定要体验。</p>
<p><img src="/images/phuket/01.jpeg" alt="01"><br><img src="/images/phuket/02.jpeg" alt="02"><br><img src="/images/phuket/03.jpeg" alt="03"><br><img src="/images/phuket/04.jpeg" alt="04"></p>
]]></content>
      <categories>
        <category>旅行</category>
      </categories>
      <tags>
        <tag>普吉岛</tag>
        <tag>泰国</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis vs Memcached</title>
    <url>/2019/02/20/redis_vs_memcached/</url>
    <content><![CDATA[<p>redis 和 memcached 作为两款非常优秀的 kv 存储系统经常会被拿来比较，除了我们最常提起的 redis 支持更多数据类型（字符串、哈希表、链表、集合、有序集合）外它们之间还有什么区别呢？本文将从 <code>内存管理</code>、<code>数据结构</code>、<code>淘汰算法</code>、<code>过期策略</code>、<code>网络IO模型</code>、<code>线程模型</code>、<code>持久化</code>、<code>虚拟内存</code>、<code>高可用</code> 等方面详细介绍。</p>
<a id="more"></a>

<hr>
<h2 id="☞-内存管理器"><a href="#☞-内存管理器" class="headerlink" title="☞ 内存管理器"></a>☞ 内存管理器</h2><h3 id="Memcached"><a href="#Memcached" class="headerlink" title="Memcached"></a>Memcached</h3><p>Memcached 默认情况下采用了名为 <code>Slab Allocator</code>（对象缓存分配） 的机制分配、管理内存，可以有效解决内存碎片的问题。</p>
<p>Slab Allocator 的基本原理是按照预先规定的大小，将分配的内存以 <code>page</code> 为单位（默认情况下一个 page 是 1M，可以通过 -I 参数在启动时指定），分割成各种尺寸的 <code>chunk</code>（块）， 相同尺寸的块组成一个分组，即 <code>slab</code> （可以理解为 chunk 的集合）。</p>
<img src="/images/redis_mc/168149AF31D13B84B64D47328EAFE211.jpg" width="400px" align=center>

<blockquote>
<p>如上图所示，&lt;= 88 byte 的数据均归属于 slab 1，&lt;= 112 byte 的数据均归属于 slab 2</p>
</blockquote>
<p>当需要申请内存时，memcached 会划分出一个新的 page 并基于数据的大小分配给指定的 <code>slab</code>，比如存储的数据大小 &lt;= 88 byte，则 page 会分配给 slab 1，该 slab 新增的 chunk 数量为 $1M / 88byte$。</p>
<img src="/images/redis_mc/BDEF68BBFE9BAADDB8070E26FFBFA599.jpg" width="500px" align=center>

<img src="/images/redis_mc/C357A7E26D57A1876666C9E9CA5B42D1.jpg" width="500px" align=center>

<blockquote>
<p>page 一旦被分配在重启前不会被回收或者重新分配，以解决内存碎片问题</p>
</blockquote>
<h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p>Linux 平台默认内存管理器为 <code>jemalloc</code>，其它平台为 <code>libc malloc</code>，下文为 redis 官方的介绍：</p>
<blockquote>
<p>Selecting a non-default memory allocator when building Redis is done by setting the MALLOC environment variable. <code>Redis is compiled and linked against libc malloc by default, with the exception of jemalloc being the default on Linux systems</code>. This default was picked because jemalloc has proven to have fewer fragmentation problems than libc malloc.<br><br/><br>To force compiling against libc malloc, use:<br><br/><br>% make MALLOC=libc<br>To compile against jemalloc on Mac OS X systems, use:<br><br/><br>% make MALLOC=jemalloc</p>
</blockquote>
<p><a href="https://github.com/antirez/redis#allocator" target="_blank" rel="noopener">链接</a></p>
<p>想了解 jemalloc，建议阅读 <a href="https://www.jianshu.com/p/f1988cc08dfd" target="_blank" rel="noopener">jemalloc 之 实现分析</a></p>
<hr>
<h2 id="☞-数据结构"><a href="#☞-数据结构" class="headerlink" title="☞ 数据结构"></a>☞ 数据结构</h2><h3 id="Memcached-1"><a href="#Memcached-1" class="headerlink" title="Memcached"></a>Memcached</h3><p>Memcached 维护一个巨大的 HashTable 用于通过 key 快速查询缓存数据</p>
<img src="/images/redis_mc/5E0BBDC276FEFC9E3E059AEE0BA93AC0.jpg" width="600px" align=center>

<p>Memcached 上存储的每一个元素都会有一个 item 的结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Structure for storing items within memcached.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">stritem</span> &#123;</span></span><br><span class="line">  <span class="comment">/* Protected by LRU locks */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">stritem</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">stritem</span> *<span class="title">prev</span>;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Rest are protected by an item lock */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">stritem</span> *<span class="title">h_next</span>;</span>    <span class="comment">/* hash chain next */</span></span><br><span class="line">  <span class="keyword">rel_time_t</span>      time;       <span class="comment">/* least recent access */</span></span><br><span class="line">  <span class="keyword">rel_time_t</span>      exptime;    <span class="comment">/* expire time */</span></span><br><span class="line">  <span class="keyword">int</span>             nbytes;     <span class="comment">/* size of data */</span></span><br><span class="line">  <span class="keyword">unsigned</span> short  refcount;</span><br><span class="line">  <span class="keyword">uint8_t</span>         nsuffix;    <span class="comment">/* length of flags-and-length string */</span></span><br><span class="line">  <span class="keyword">uint8_t</span>         it_flags;   <span class="comment">/* ITEM_* above */</span></span><br><span class="line">  <span class="keyword">uint8_t</span>         slabs_clsid;<span class="comment">/* which slab class we're in */</span></span><br><span class="line">  <span class="keyword">uint8_t</span>         nkey;       <span class="comment">/* key length, w/terminating null and padding */</span></span><br><span class="line">  <span class="comment">/* this odd type prevents type-punning issues when we do</span></span><br><span class="line"><span class="comment">    * the little shuffle to save space when not using CAS. */</span></span><br><span class="line">  <span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> cas;</span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">end</span>;</span><br><span class="line">  &#125; data[];</span><br><span class="line">  <span class="comment">/* if it_flags &amp; ITEM_CAS we have 8 bytes CAS */</span></span><br><span class="line">  <span class="comment">/* then null-terminated key */</span></span><br><span class="line">  <span class="comment">/* then " flags length\r\n" (no terminating null) */</span></span><br><span class="line">  <span class="comment">/* then data with terminating \r\n (no terminating null; it's binary!) */</span></span><br><span class="line">&#125; item;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考资料：<br><a href="https://blog.csdn.net/initphp/article/details/44537547" target="_blank" rel="noopener">https://blog.csdn.net/initphp/article/details/44537547</a></p>
</blockquote>
<h3 id="Redis-1"><a href="#Redis-1" class="headerlink" title="Redis"></a>Redis</h3><p>以 set hello world 为例，展示 redis 如何存储数据：</p>
<img src="/images/redis_mc/FAAB924D7C8F278DA26EB5949765A196.jpg" width="400px" align=center>

<ul>
<li><strong>dictEntry</strong>: Redis 是 Key-Value 数据库，因此对每个键值对都会有一个 dictEntry，里面存储了指向 Key 和 Value 的指针；next 指向下一个 dictEntry，与本 Key-Value 无关</li>
<li><strong>key</strong>: 图中右上角可见，Key（hello）并不是直接以字符串存储，而是存储在 SDS 结构中</li>
<li><strong>redisObject</strong>: value 的数据结构，下面详细介绍</li>
</ul>
<h4 id="✔-redisObject-数据结构"><a href="#✔-redisObject-数据结构" class="headerlink" title="✔ redisObject 数据结构"></a>✔ redisObject 数据结构</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> lru:LRU_BITS; <span class="comment">/* LRU time (relative to global lru_clock) or</span></span><br><span class="line"><span class="comment">                          * LFU data (least significant 8 bits frequency</span></span><br><span class="line"><span class="comment">                          * and most significant 16 bits access time). */</span></span><br><span class="line">  <span class="keyword">int</span> refcount;</span><br><span class="line">  <span class="keyword">void</span> *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>type</strong>: 表示对象的类型，目前包括 REDIS_STRING(字符串)、REDIS_LIST (列表)、REDIS_HASH(哈希)、REDIS_SET(集合)、REDIS_ZSET(有序集合)</li>
<li><strong>encoding</strong>: 对象的内部编码，<strong>对于 Redis 支持的每种类型，都有至少两种内部编码</strong>，例如对于字符串，有 int、embstr、raw 三种编码（后面详细介绍）</li>
<li><strong>lru</strong>: 记录的是对象最后一次被命令程序访问的时间</li>
<li><strong>refcount</strong>: 记录的是该对象被引用的次数，主要在于对象的引用计数和内存回收</li>
<li><strong>ptr</strong>: 指针指向具体的数据</li>
</ul>
<h4 id="✔-SDS"><a href="#✔-SDS" class="headerlink" title="✔ SDS"></a>✔ SDS</h4><p>Redis 没有直接使用 C 字符串(即以空字符’\0’结尾的字符数组)作为默认的字符串表示，而是使用了 SDS。SDS 是简单动态字符串(Simple Dynamic String)的缩写。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> len;   <span class="comment">//表示sds当前的长度</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">free</span>;  <span class="comment">//已为sds分配的长度-sds当前的长度</span></span><br><span class="line">  <span class="keyword">char</span> buf[];         <span class="comment">//sds实际存放的位置</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>SDS 与 C 字符串的比较:</p>
<ul>
<li><strong>获取字符串长度</strong>：SDS 是 O(1)，C 字符串是 O(n)</li>
<li><strong>缓冲区溢出</strong>：使用 C 字符串的 API 时，如果字符串长度增加（如 strcat 操作）而忘记重新分配内存，很容易造成缓冲区的溢出；而 SDS 由于记录了长度，相应的 API 在可能造成缓冲区溢出时会自动重新分配内存，杜绝了缓冲区溢出</li>
<li><strong>修改字符串时内存的重分配</strong>：对于 C 字符串，如果要修改字符串，必须要重新分配内存（先释放再申请），因为如果没有重新分配，字符串长度增大时会造成内存缓冲区溢出，字符串长度减小时会造成内存泄露。而对于 SDS，由于可以记录 len 和 free，因此解除了字符串长度和空间数组长度之间的关联，可以在此基础上进行优化。如空间预分配策略（即分配内存时比实际需要的多）使得字符串长度增大时重新分配内存的概率大大减小；惰性空间释放策略使得字符串长度减小时重新分配内存的概率大大减小。</li>
<li><strong>存取二进制数据</strong>：SDS 可以，C 字符串不可以。因为 C 字符串以空字符作为字符串结束的标识，而对于一些二进制文件（如图片等）。内容可能包括空字符串，因此 C 字符串无法正确存取；而 SDS 以字符串长度 len 来作为字符串结束标识，因此没有这个问题。</li>
</ul>
<h4 id="✔-Encoding"><a href="#✔-Encoding" class="headerlink" title="✔ Encoding"></a>✔ Encoding</h4><ul>
<li><p><strong>int</strong>：</p>
</li>
<li><p><strong>embstr</strong>：只分配一次内存空间（因此 redisObject 和 sds 是连续的）</p>
</li>
<li><p><strong>raw</strong>：分配两次内存空间（一次为 sds 分配对象，另一次为 objet 分配对象）</p>
<img src="/images/redis_mc/071AC0120A55D4CE86C71BCCE07D32BC.jpg" width="500px" align=center></li>
<li><p><strong>ziplist</strong>：是 Redis 为了节约内存而开发的，是由一系列特殊编码的连续内存块，总体思想是时间换空间，即以部分读写性能为代价，来换取极高的内存空间利用率。这种结构并不擅长做修改操作，一旦数据发生改动，就会引发内存 realloc。ziplist 只会用于字段个数少，且字段值也较小的场景</p>
<img src="/images/redis_mc/WX20200321-172632@2x.png" width="400px" align=center></li>
<li><p><strong>linkedlist</strong>：由一个 list 结构和多个 listNode 结构组成；典型结构如下图所示：</p>
<img src="/images/redis_mc/D37C1920241705B298B4FF9E1F78D306.jpg" width="500px" align=center></li>
<li><p><strong>hashtable</strong>：一个 hashtable 由 1 个 dict 结构、2 个 dictht 结构、1 个 dictEntry 指针数组（称为 bucket）和多个 dictEntry 结构组成</p>
<img src="/images/redis_mc/AEEFF07D89EA2243B42ED37047DC02D6.jpg" width="500px" align=center></li>
<li><p><strong>intset</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">  <span class="keyword">uint32_t</span> encoding;</span><br><span class="line">  <span class="keyword">uint32_t</span> length;</span><br><span class="line">  <span class="keyword">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>encoding</strong>：redis 根据整型位数将 intset 分为 INTSET_ENC_INT16、INTSET_ENC_INT32、INTSET_ENC_INT64 三种编码</li>
<li><strong>length</strong>：集合元素大小</li>
<li><strong>contents</strong>：元素数组</li>
</ul>
</li>
<li><p><strong>skiplist</strong>：<br>跳跃表是一种有序数据结构，通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的</p>
<img src="/images/redis_mc/0948935EFD68F1624BAA1BCB3545BB18.jpg" width="500px" align=center></li>
<li><p><strong>quicklist</strong>：<br>是一个 ziplist 组成的双向链表</p>
<img src="/images/redis_mc/4E2CC5FA2CBC908A727A5ED54087E6C9.jpg" width="500px" align=center>

<blockquote>
<p>为什么不直接使用 ziplist？<br>ziplist 在我们程序里面来看将会是一块连续的内存块。它使用内存偏移来保存 next 从而节约了 next 指针。这样造成了我们每一次的删除插入操作都会进行 realloc，从而分配一块新的内存块。当我们的 ziplist 特别大的时候。没有这么大空闲的内存块给我们的时候。操作系统其实会抽象出一块连续的内存块给我。在底层来说他其实是一个链表链接成为的内存。不过在我们程序使用来说。他还是一块连续的内存。这样的话会造成内存碎片，并且在操作的时候因为内存不连续等原因造成效率问题。或者因为转移到大内存块等进行数据迁移。从而损失性能。所以 quicklist 是对 ziplist 进行一次封装，使用小块的 ziplist 来既保证了少使用内存，也保证了性能。</p>
</blockquote>
</li>
</ul>
<h4 id="✔-Redis-各类型数据结构"><a href="#✔-Redis-各类型数据结构" class="headerlink" title="✔ Redis 各类型数据结构"></a>✔ Redis 各类型数据结构</h4><ul>
<li><strong>字符串</strong>: int（8 个字节的长整型），embstr（&lt;=39 字节的字符串），raw（大于 39 个字节的字符串）</li>
<li><strong>列表</strong>：ziplist（列表中元素数量小于 512 个且列表中所有字符串对象都不足 64 字节），linkedlist（其它）。redis 3.2 后使用 quicklist 作为底层数据结构</li>
<li><strong>哈希</strong>：ziplist（哈希中元素数量小于 512 个且哈希中所有键值对的键和值字符串长度都小于 64 字节），hashtable（其它）</li>
<li><strong>集合</strong>：intset（集合中元素数量小于 512 个且集合中所有元素都是整数值），hashtable（其它）</li>
<li><strong>有序集合</strong>：ziplist（有序集合中元素数量小于 128 个且有序集合中所有成员长度都不足 64 字节），skiplist（其它）</li>
</ul>
<hr>
<h2 id="☞-淘汰算法"><a href="#☞-淘汰算法" class="headerlink" title="☞ 淘汰算法"></a>☞ 淘汰算法</h2><h3 id="Memcached-2"><a href="#Memcached-2" class="headerlink" title="Memcached"></a>Memcached</h3><p>LRU（Least recently used，最近最少使用）算法，根据数据的历史访问记录来进行淘汰数据，其核心思想是 “如果数据最近被访问过，那么将来被访问的几率也更高”。</p>
<img src="/images/redis_mc/682155E1E9663D2FFC818C32DFF6F34B.jpg" align=center>

<ul>
<li>新数据插入到链表头部；</li>
<li>每当缓存命中（即缓存数据被访问），则将数据移到链表头部；</li>
<li>当链表满的时候，将链表尾部的数据丢弃。</li>
</ul>
<h3 id="Redis-2"><a href="#Redis-2" class="headerlink" title="Redis"></a>Redis</h3><p>LRU 近似算法，即随机选取 5 个 key，淘汰其中间隔时间最长的 key。Redis 4.0 后新增了 LFR 淘汰算法。</p>
<p>LFR（Least frequently used，最不经常使用）如果一个数据在最近一段时间内使用次数很少，那么在将来一段时间内被使用的可能性也很小。</p>
<blockquote>
<p>参考资料<br><a href="https://redis.io/topics/lru-cache" target="_blank" rel="noopener">https://redis.io/topics/lru-cache</a><br><a href="https://zhuanlan.zhihu.com/p/24155554" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/24155554</a></p>
</blockquote>
<hr>
<h2 id="☞-过期策略"><a href="#☞-过期策略" class="headerlink" title="☞ 过期策略"></a>☞ 过期策略</h2><h3 id="Memcached-3"><a href="#Memcached-3" class="headerlink" title="Memcached"></a>Memcached</h3><ul>
<li>最大过期时间 30 天，超过 30 天的过期时间将转化为 unix 时间戳作为过期时间</li>
<li>memcached 的过期数据不会立即从内存删除，而是读取的时候判断是否过期，过期则删除（<strong>惰性失效机制</strong>, lazyexpiration）</li>
</ul>
<blockquote>
<p>参考资料<br><a href="https://github.com/memcached/memcached/wiki/Programming#expiration" target="_blank" rel="noopener">https://github.com/memcached/memcached/wiki/Programming#expiration</a></p>
</blockquote>
<h3 id="Redis-3"><a href="#Redis-3" class="headerlink" title="Redis"></a>Redis</h3><p>通过 <code>maxmemory-policy</code> 参数配置</p>
<ul>
<li><strong>noeviction</strong>：默认策略，不淘汰，如果内存已满，添加数据是报错</li>
<li><strong>allkeys-lru</strong>：在所有 key 中，通过 <code>lru</code> 算法淘汰数据</li>
<li><strong>volatile-lru</strong>：设置过期时间的 key 中，通过 <code>lru</code> 算法淘汰数据</li>
<li><strong>allkeys-random</strong>：在所有 key 中，随机淘汰数据</li>
<li><strong>volatile-random</strong>：设置过期时间的 key 中，随机淘汰数据</li>
<li><strong>volatile-ttl</strong>：设置过期时间的 key 中，抛弃存活时间最短的数据</li>
<li><strong>allkeys-lfu</strong>：在所有 key 中，通过 <code>lfu</code> 算法淘汰数据（4.0 版本后）</li>
<li><strong>volatile-lfu</strong>：设置过期时间的 key 中，通过 <code>lfu</code> 算法淘汰数据（4.0 版本后）</li>
</ul>
<blockquote>
<p>参考资料<br><a href="https://redis.io/topics/lru-cache" target="_blank" rel="noopener">https://redis.io/topics/lru-cache</a></p>
</blockquote>
<hr>
<h2 id="☞-网络IO模型"><a href="#☞-网络IO模型" class="headerlink" title="☞ 网络IO模型"></a>☞ 网络IO模型</h2><h3 id="Memcached-4"><a href="#Memcached-4" class="headerlink" title="Memcached"></a>Memcached</h3><p>非阻塞 IO 多路复用。基于 <code>libevent</code> 开发，代码可读性差</p>
<h3 id="Redis-4"><a href="#Redis-4" class="headerlink" title="Redis"></a>Redis</h3><p>非阻塞 IO 多路复用。自己完成了一个非常轻量级的对 <code>select</code>、<code>epoll</code>、<code>evport</code>、<code>kqueue</code> 这些通用的接口的实现，代码优雅，可读性强</p>
<hr>
<h2 id="☞-线程模型"><a href="#☞-线程模型" class="headerlink" title="☞ 线程模型"></a>☞ 线程模型</h2><h3 id="Memcached-5"><a href="#Memcached-5" class="headerlink" title="Memcached"></a>Memcached</h3><p>多线程</p>
<p>优点：</p>
<ul>
<li>可以发挥多核的优势</li>
</ul>
<p>缺点：</p>
<ul>
<li>处理逻辑复杂</li>
<li>需要考虑线程与线程之间的同步与互斥，上下文切换和锁竞争会导致额外的性能消耗</li>
</ul>
<h3 id="Redis-5"><a href="#Redis-5" class="headerlink" title="Redis"></a>Redis</h3><p>单线程</p>
<p>优点：</p>
<ul>
<li>处理逻辑简单</li>
<li>避免了不必要的上下文切换和竞争条件</li>
<li>容易实现更加丰富的功能</li>
</ul>
<p>缺点</p>
<ul>
<li>无法发挥多核的优势</li>
<li>耗时的操作会造成严重的性能问题（如：redis 提供了一些简单的计算功能，比如排序、聚合等，对于这些操作，单线程模型施加会严重影响整体吞吐量，CPU 计算过程中，整个 IO 调度都是被阻塞的）</li>
</ul>
<blockquote>
<p><a href="https://github.com/JohnSully/KeyDB" target="_blank" rel="noopener">KeyDB</a> 是从 Redis fork 出来的分支，专注于多线程、内存效率和高吞吐量；此外 redis 6.0 也引入了多线程 IO 特性</p>
</blockquote>
<hr>
<h2 id="☞-持久化"><a href="#☞-持久化" class="headerlink" title="☞ 持久化"></a>☞ 持久化</h2><h3 id="Memcached-6"><a href="#Memcached-6" class="headerlink" title="Memcached"></a>Memcached</h3><p>无</p>
<h3 id="Redis-6"><a href="#Redis-6" class="headerlink" title="Redis"></a>Redis</h3><p>RDB, AOF</p>
<hr>
<h2 id="☞-虚拟内存"><a href="#☞-虚拟内存" class="headerlink" title="☞ 虚拟内存"></a>☞ 虚拟内存</h2><h3 id="Memcached-7"><a href="#Memcached-7" class="headerlink" title="Memcached"></a>Memcached</h3><p>memcache 会把所有的数据存储在物理内存里</p>
<h3 id="Redis-7"><a href="#Redis-7" class="headerlink" title="Redis"></a>Redis</h3><p>redis 有自己的 VM 机制，理论上能够存储比物理内存更多的数据，当数据超量时，会引发 swap，把冷数据刷到磁盘上。<strong>需要注意的是，从 2.6 版本开始，redis 已经废弃了 VM 机制。</strong></p>
<blockquote>
<p>参考资料：<br><a href="https://redis.io/topics/internals-vm" target="_blank" rel="noopener">https://redis.io/topics/internals-vm</a></p>
</blockquote>
<hr>
<h2 id="☞-高可用"><a href="#☞-高可用" class="headerlink" title="☞ 高可用"></a>☞ 高可用</h2><h3 id="Memcached-8"><a href="#Memcached-8" class="headerlink" title="Memcached"></a>Memcached</h3><p>要想要实现高可用，需要进行二次开发，例如客户端的双读双写，或者服务端的集群同步</p>
<h3 id="Redis-8"><a href="#Redis-8" class="headerlink" title="Redis"></a>Redis</h3><p>支持集群部署、主从复制、读写分离、数据分片等特性</p>
<blockquote>
<p>参考资料：<br>  <a href="https://redis.io/topics/cluster-tutorial" target="_blank" rel="noopener">https://redis.io/topics/cluster-tutorial</a><br>  <a href="https://yq.aliyun.com/articles/626532" target="_blank" rel="noopener">https://yq.aliyun.com/articles/626532</a></p>
</blockquote>
]]></content>
      <categories>
        <category>缓存</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>memcached</tag>
      </tags>
  </entry>
  <entry>
    <title>通过Python绘制NBA球员投篮图表</title>
    <url>/2015/08/29/create-NBA-shot-chart-in-pathon/</url>
    <content><![CDATA[<p>喜欢看NBA的同学都见过官方绘制的球员投篮图表，这些图表能够非常直观地反映某个球员的投篮分布图以及投篮热图等。当然，借助NBA官方提供的数据，我们也可以自己绘制这些图表。</p>
<p>只要有数据，能够绘这种图的工具有很多，鉴于最近在学习Python，而且刚好也有一位大牛写了一篇相关的文章<a href="http://savvastjortjoglou.com/nba-shot-sharts.html" target="_blank" rel="noopener">“How to Create NBA Shot Charts in Python”</a>，借鉴这篇文章，我也使用Python折腾了一把。</p>
<a id="more"></a>

<h3 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h3><ul>
<li><p>操作系统</p>
<p>  CentOS 6.7(32-bit)</p>
</li>
<li><p>Python版本</p>
<p>  2.7.10</p>
</li>
</ul>
<h3 id="第三方模块"><a href="#第三方模块" class="headerlink" title="第三方模块"></a>第三方模块</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br></pre></td></tr></table></figure>

<h3 id="绘制篮球场"><a href="#绘制篮球场" class="headerlink" title="绘制篮球场"></a>绘制篮球场</h3><p>绘制投篮图表时，我们需要以篮球场地作为参考标准，所以我们先要清楚的了解篮球场的尺寸（详见<a href="http://www.sportscourtdimensions.com/wp-content/uploads/2015/02/nba_court_dimensions_h.png" target="_blank" rel="noopener">1</a>和<a href="http://www.sportsknowhow.com/basketball/dimensions/nba-basketball-court-dimensions.html" target="_blank" rel="noopener">2</a>），然后使用Matplotlib Patches绘制<code>圆形</code>，<code>矩形</code>和<code>圆弧</code>，并组合成一个篮球场。绘制篮球场的函数实现如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.patches <span class="keyword">import</span> Circle, Rectangle, Arc</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw_court</span><span class="params">(ax=None, color=<span class="string">'gray'</span>, lw=<span class="number">1</span>, outer_lines=False)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Returns an axes with a basketball court drawn onto to it.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    This function draws a court based on the x and y-axis values that the NBA</span></span><br><span class="line"><span class="string">    stats API provides for the shot chart data.  For example, the NBA stat API</span></span><br><span class="line"><span class="string">    represents the center of the hoop at the (0,0) coordinate.  Twenty-two feet</span></span><br><span class="line"><span class="string">    from the left of the center of the hoop in is represented by the (-220,0)</span></span><br><span class="line"><span class="string">    coordinates.  So one foot equals +/-10 units on the x and y-axis.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    TODO: explain the parameters</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> ax <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        ax = plt.gca()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Create the various parts of an NBA basketball court</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Create the basketball hoop</span></span><br><span class="line">    hoop = Circle((<span class="number">0</span>, <span class="number">0</span>), radius=<span class="number">7.5</span>, linewidth=lw, color=color, fill=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Create backboard</span></span><br><span class="line">    backboard = Rectangle((<span class="number">-30</span>, <span class="number">-7.5</span>), <span class="number">60</span>, <span class="number">-1</span>, linewidth=lw, color=color)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># The paint</span></span><br><span class="line">    <span class="comment"># Create the outer box 0f the paint, width=16ft, height=19ft</span></span><br><span class="line">    outer_box = Rectangle((<span class="number">-80</span>, <span class="number">-47.5</span>), <span class="number">160</span>, <span class="number">190</span>, linewidth=lw, color=color, fill=<span class="literal">False</span>)</span><br><span class="line">    <span class="comment"># Create the inner box of the paint, widt=12ft, height=19ft</span></span><br><span class="line">    inner_box = Rectangle((<span class="number">-60</span>, <span class="number">-47.5</span>), <span class="number">120</span>, <span class="number">190</span>, linewidth=lw, color=color, fill=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Create free throw top arc</span></span><br><span class="line">    top_free_throw = Arc((<span class="number">0</span>, <span class="number">142.5</span>), <span class="number">120</span>, <span class="number">120</span>, theta1=<span class="number">0</span>, theta2=<span class="number">180</span>, linewidth=lw, color=color, fill=<span class="literal">False</span>)</span><br><span class="line">    <span class="comment"># Create free throw bottom arc</span></span><br><span class="line">    bottom_free_throw = Arc((<span class="number">0</span>, <span class="number">142.5</span>), <span class="number">120</span>, <span class="number">120</span>, theta1=<span class="number">180</span>, theta2=<span class="number">0</span>, linewidth=lw, color=color, linestyle=<span class="string">'dashed'</span>)</span><br><span class="line">    <span class="comment"># Restricted Zone, it is an arc with 4ft radius from center of the hoop</span></span><br><span class="line">    restricted = Arc((<span class="number">0</span>, <span class="number">0</span>), <span class="number">80</span>, <span class="number">80</span>, theta1=<span class="number">0</span>, theta2=<span class="number">180</span>, linewidth=lw, color=color)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Three point line</span></span><br><span class="line">    <span class="comment"># Create the right side 3pt lines, it's 14ft long before it arcs</span></span><br><span class="line">    corner_three_a = Rectangle((<span class="number">-220</span>, <span class="number">-47.5</span>), <span class="number">0</span>, <span class="number">140</span>, linewidth=lw, color=color)</span><br><span class="line">    <span class="comment"># Create the right side 3pt lines, it's 14ft long before it arcs</span></span><br><span class="line">    corner_three_b = Rectangle((<span class="number">220</span>, <span class="number">-47.5</span>), <span class="number">0</span>, <span class="number">140</span>, linewidth=lw, color=color)</span><br><span class="line">    <span class="comment"># 3pt arc - center of arc will be the hoop, arc is 23'9" away from hoop</span></span><br><span class="line">    three_arc = Arc((<span class="number">0</span>, <span class="number">0</span>), <span class="number">475</span>, <span class="number">475</span>, theta1=<span class="number">22</span>, theta2=<span class="number">158</span>, linewidth=lw, color=color)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Center Court</span></span><br><span class="line">    center_outer_arc = Arc((<span class="number">0</span>, <span class="number">422.5</span>), <span class="number">120</span>, <span class="number">120</span>, theta1=<span class="number">180</span>, theta2=<span class="number">0</span>, linewidth=lw, color=color)</span><br><span class="line">    center_inner_arc = Arc((<span class="number">0</span>, <span class="number">422.5</span>), <span class="number">40</span>, <span class="number">40</span>, theta1=<span class="number">180</span>, theta2=<span class="number">0</span>, linewidth=lw, color=color)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># List of the court elements to be plotted onto the axes</span></span><br><span class="line">    court_elements = [hoop, backboard, outer_box, inner_box, top_free_throw,</span><br><span class="line">                      bottom_free_throw, restricted, corner_three_a,</span><br><span class="line">                      corner_three_b, three_arc, center_outer_arc,</span><br><span class="line">                      center_inner_arc]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> outer_lines:</span><br><span class="line">        <span class="comment"># Draw the half court line, baseline and side out bound lines</span></span><br><span class="line">        outer_lines = Rectangle((<span class="number">-250</span>, <span class="number">-47.5</span>), <span class="number">500</span>, <span class="number">470</span>, linewidth=lw, color=color, fill=<span class="literal">False</span>)</span><br><span class="line">        court_elements.append(outer_lines)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Add the court elements onto the axes</span></span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> court_elements:</span><br><span class="line">    	ax.add_patch(element)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ax</span><br></pre></td></tr></table></figure>

<p>现在测试一下效果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ns.set_style(<span class="string">'white'</span>)</span><br><span class="line">sns.set_color_codes()</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">12</span>,<span class="number">11</span>))</span><br><span class="line"></span><br><span class="line">draw_court()</span><br><span class="line">plt.xlim(<span class="number">-250</span>,<span class="number">250</span>)</span><br><span class="line">plt.ylim(<span class="number">422.5</span>, <span class="number">-47.5</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>效果如下：<br><img src="/images/draw_court.png" alt="draw_court" width="760px" /></p>
<h3 id="绘制投篮分布图"><a href="#绘制投篮分布图" class="headerlink" title="绘制投篮分布图"></a>绘制投篮分布图</h3><h4 id="获取投篮数据"><a href="#获取投篮数据" class="headerlink" title="获取投篮数据"></a>获取投篮数据</h4><p>获取最权威数据的途径当然是nba官网<a href="http://stats.nba.com/" target="_blank" rel="noopener">stats.nba.com</a>。NBA官网并没有提供相关的API，不过我们可以通过requests库从官方获取包含我们需要信息的JSON文件，具体类实现如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shots</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Shots is a wrapper around the NBA stats API that can access the shot chart</span></span><br><span class="line"><span class="string">    data.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, player_id, league_id=<span class="string">"00"</span>, season=<span class="string">"2014-15"</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 season_type=<span class="string">"Regular Season"</span>, team_id=<span class="number">0</span>, game_id=<span class="string">""</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 outcome=<span class="string">""</span>, location=<span class="string">""</span>, month=<span class="number">0</span>, season_segment=<span class="string">""</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 date_from=<span class="string">""</span>, date_to=<span class="string">""</span>, opp_team_id=<span class="number">0</span>, vs_conference=<span class="string">""</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 vs_division=<span class="string">""</span>, position=<span class="string">""</span>, rookie_year=<span class="string">""</span>, game_segment=<span class="string">""</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 period=<span class="number">0</span>, last_n_games=<span class="number">0</span>, clutch_time=<span class="string">""</span>, ahead_behind=<span class="string">""</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 point_diff=<span class="string">""</span>, range_type=<span class="string">""</span>, start_period=<span class="string">""</span>, end_period=<span class="string">""</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 start_range=<span class="string">""</span>, end_range=<span class="string">""</span>, context_filter=<span class="string">""</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 context_measure=<span class="string">"FGA"</span>)</span>:</span></span><br><span class="line"></span><br><span class="line">        self.player_id = player_id</span><br><span class="line"></span><br><span class="line">        self.base_url = <span class="string">"http://stats.nba.com/stats/shotchartdetail?"</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># <span class="doctag">TODO:</span> Figure out what all these parameters mean for NBA stats api</span></span><br><span class="line">        <span class="comment">#       Need to figure out and include CFID and CFPARAMS, they are</span></span><br><span class="line">        <span class="comment">#       associated w/ContextFilter somehow</span></span><br><span class="line">        self.url_paramaters = &#123;</span><br><span class="line">                                <span class="string">"LeagueID"</span>: league_id,</span><br><span class="line">                                <span class="string">"Season"</span>: season,</span><br><span class="line">                                <span class="string">"SeasonType"</span>: season_type,</span><br><span class="line">                                <span class="string">"TeamID"</span>: team_id,</span><br><span class="line">                                <span class="string">"PlayerID"</span>: player_id,</span><br><span class="line">                                <span class="string">"GameID"</span>: game_id,</span><br><span class="line">                                <span class="string">"Outcome"</span>: outcome,</span><br><span class="line">                                <span class="string">"Location"</span>: location,</span><br><span class="line">                                <span class="string">"Month"</span>: month,</span><br><span class="line">                                <span class="string">"SeasonSegment"</span>: season_segment,</span><br><span class="line">                                <span class="string">"DateFrom"</span>: date_from,</span><br><span class="line">                                <span class="string">"DateTo"</span>: date_to,</span><br><span class="line">                                <span class="string">"OpponentTeamID"</span>: opp_team_id,</span><br><span class="line">                                <span class="string">"VsConference"</span>: vs_conference,</span><br><span class="line">                                <span class="string">"VsDivision"</span>: vs_division,</span><br><span class="line">                                <span class="string">"Position"</span>: position,</span><br><span class="line">                                <span class="string">"RookieYear"</span>: rookie_year,</span><br><span class="line">                                <span class="string">"GameSegment"</span>: game_segment,</span><br><span class="line">                                <span class="string">"Period"</span>: period,</span><br><span class="line">                                <span class="string">"LastNGames"</span>: last_n_games,</span><br><span class="line">                                <span class="string">"ClutchTime"</span>: clutch_time,</span><br><span class="line">                                <span class="string">"AheadBehind"</span>: ahead_behind,</span><br><span class="line">                                <span class="string">"PointDiff"</span>: point_diff,</span><br><span class="line">                                <span class="string">"RangeType"</span>: range_type,</span><br><span class="line">                                <span class="string">"StartPeriod"</span>: start_period,</span><br><span class="line">                                <span class="string">"EndPeriod"</span>: end_period,</span><br><span class="line">                                <span class="string">"StartRange"</span>: start_range,</span><br><span class="line">                                <span class="string">"EndRange"</span>: end_range,</span><br><span class="line">                                <span class="string">"ContextFilter"</span>: context_filter, <span class="comment"># unsure of what this does</span></span><br><span class="line">                                <span class="string">"ContextMeasure"</span>: context_measure</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">        self.response = requests.get(self.base_url, params=self.url_paramaters)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">change_params</span><span class="params">(self, parameters)</span>:</span></span><br><span class="line">        <span class="string">"""Pass in a disctionary of url parameters to change"""</span></span><br><span class="line">        self.url_paramaters.update(parameters)</span><br><span class="line">        self.response = requests.get(self.base_url, params=self.url_paramaters)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_shots</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Returns the shot chart data as a pandas DataFrame."""</span></span><br><span class="line">        shots = self.response.json()[<span class="string">'resultSets'</span>][<span class="number">0</span>][<span class="string">'rowSet'</span>]</span><br><span class="line">        headers = self.response.json()[<span class="string">'resultSets'</span>][<span class="number">0</span>][<span class="string">'headers'</span>]</span><br><span class="line">        <span class="keyword">return</span> pd.DataFrame(shots, columns=headers)</span><br></pre></td></tr></table></figure>

<p>当定义<code>Shots</code>类的一个实例时，必须为参数<code>player_id</code>传入一个值，该数值代表球员的编号，如不知道可以参考：<a href="https://raw.githubusercontent.com/savvastj/nbaShotChartsData/master/player_id.csv" target="_blank" rel="noopener">player_id.csv</a>。本文中以Kobe Bryant在2005-06赛季的数据为例，使用方法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Kobe = Shots(<span class="number">977</span>, season=<span class="string">"2005-06"</span>)</span><br><span class="line">shot_df = Kobe.get_shots()</span><br></pre></td></tr></table></figure>

<h4 id="绘制投篮分布图-1"><a href="#绘制投篮分布图-1" class="headerlink" title="绘制投篮分布图"></a>绘制投篮分布图</h4><p><code>Shorts</code>类的get_shots()方法返回的数据包含了Kobe Bryant在2005-06常规赛期间的所有出手投篮数据，通过如下操作可以提取该数据的头信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.display <span class="keyword">import</span> display</span><br><span class="line"><span class="keyword">with</span> pd.option_context(<span class="string">'display.max_columns'</span>, <span class="literal">None</span>):</span><br><span class="line">    display(shot_df.head())</span><br></pre></td></tr></table></figure>

<p>从结果中可以发现我们需要的数据在LOC_X和LOC_Y 里面，这些坐标值对应每一次出手投篮，然后我们可以把这些坐标绘制到一组表示篮球场的轴上，绘制投篮分布图的函数如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shot_chart</span><span class="params">(x, y, title=<span class="string">""</span>, kind=<span class="string">"scatter"</span>, color=<span class="string">"b"</span>, cmap=None,</span></span></span><br><span class="line"><span class="function"><span class="params">               xlim=<span class="params">(<span class="number">-250</span>, <span class="number">250</span>)</span>, ylim=<span class="params">(<span class="number">422.5</span>, <span class="number">-47.5</span>)</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">               court_color=<span class="string">"gray"</span>, outer_lines=False, court_lw=<span class="number">1</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">               flip_court=False, kde_shade=True, hex_gridsize=None,</span></span></span><br><span class="line"><span class="function"><span class="params">               ax=None, **kwargs)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Returns an Axes object with player shots plotted.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    TODO: explain the parameters</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ax <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        ax = plt.gca()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> cmap <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        cmap = sns.light_palette(color, as_cmap=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> flip_court:</span><br><span class="line">        ax.set_xlim(xlim)</span><br><span class="line">        ax.set_ylim(ylim)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        ax.set_xlim(xlim[::<span class="number">-1</span>])</span><br><span class="line">        ax.set_ylim(ylim[::<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">    ax.tick_params(labelbottom=<span class="string">"off"</span>, labelleft=<span class="string">"off"</span>)</span><br><span class="line">    ax.set_title(title, fontsize=<span class="number">18</span>)</span><br><span class="line"></span><br><span class="line">    draw_court(ax, color=court_color, lw=court_lw, outer_lines=outer_lines)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> kind == <span class="string">"scatter"</span>:</span><br><span class="line">        ax.scatter(x, y, c=color, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> kind == <span class="string">"kde"</span>:</span><br><span class="line">        sns.kdeplot(x, y, shade=kde_shade, cmap=cmap, ax=ax, **kwargs)</span><br><span class="line">        ax.set_xlabel(<span class="string">''</span>)</span><br><span class="line">        ax.set_ylabel(<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> kind == <span class="string">"hex"</span>:</span><br><span class="line">        <span class="keyword">if</span> hex_gridsize <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># Get the number of bins for hexbin using Freedman-Diaconis rule</span></span><br><span class="line">            <span class="comment"># This is idea was taken from seaborn, which got the calculation</span></span><br><span class="line">            <span class="comment"># from http://stats.stackexchange.com/questions/798/</span></span><br><span class="line">            <span class="keyword">from</span> seaborn.distributions <span class="keyword">import</span> _freedman_diaconis_bins</span><br><span class="line">            x_bin = _freedman_diaconis_bins(x)</span><br><span class="line">            y_bin = _freedman_diaconis_bins(y)</span><br><span class="line">            hex_gridsize = int(np.mean([x_bin, y_bin]))</span><br><span class="line"></span><br><span class="line">        ax.hexbin(x, y, gridsize=hex_gridsize, cmap=cmap, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">"kind must be 'scatter', 'kde', or 'hex'."</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ax</span><br></pre></td></tr></table></figure>

<p>使用方法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">shot_chart(shot_df.LOC_X, shot_df.LOC_Y)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/images/Kobe_shot_chart.png" alt="Kobe_shot_chart" width="760px" />

<h4 id="投篮热力图"><a href="#投篮热力图" class="headerlink" title="投篮热力图"></a>投篮热力图</h4><p>Seaborn是Python中基于matplotlib的统计绘图模块，下面的函数是使用searorn中的<a href="http://stanford.edu/~mwaskom/software/seaborn/generated/seaborn.jointplot.html" target="_blank" rel="noopener"><code>Jointplot()</code></a>函数可以让我们以统计学的方式展示投篮分布图：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shot_chart_jointplot</span><span class="params">(x, y, data=None, title=<span class="string">""</span>, kind=<span class="string">"scatter"</span>, color=<span class="string">"b"</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">                         cmap=None, xlim=<span class="params">(<span class="number">-250</span>, <span class="number">250</span>)</span>, ylim=<span class="params">(<span class="number">422.5</span>, <span class="number">-47.5</span>)</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                         space=<span class="number">0</span>, court_color=<span class="string">"gray"</span>, outer_lines=False,</span></span></span><br><span class="line"><span class="function"><span class="params">                         court_lw=<span class="number">1</span>, flip_court=False,</span></span></span><br><span class="line"><span class="function"><span class="params">                         set_size_inches=<span class="params">(<span class="number">12</span>, <span class="number">11</span>)</span>, **kwargs)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Returns a seaborn JointGrid using sns.jointplot</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    TODO: Better documentation</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># If a colormap is not provided, then it is based off of the color</span></span><br><span class="line">    <span class="keyword">if</span> cmap <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        cmap = sns.light_palette(color, as_cmap=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    plot = sns.jointplot(x, y, data=<span class="literal">None</span>, stat_func=<span class="literal">None</span>, kind=kind, space=<span class="number">0</span>, color=cmap(<span class="number">0.1</span>), cmap=cmap, **kwargs)</span><br><span class="line"></span><br><span class="line">    plot.fig.set_size_inches(set_size_inches)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># A joint plot has 3 Axes, the first one called ax_joint </span></span><br><span class="line">    <span class="comment"># is the one we want to draw our court onto and adjust some other settings</span></span><br><span class="line">    ax = plot.ax_joint</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> flip_court:</span><br><span class="line">        ax.set_xlim(xlim)</span><br><span class="line">        ax.set_ylim(ylim)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        ax.set_xlim(xlim[::<span class="number">-1</span>])</span><br><span class="line">        ax.set_ylim(ylim[::<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">    draw_court(ax, color=court_color, lw=court_lw, outer_lines=outer_lines)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Get rid of axis labels and tick marks</span></span><br><span class="line">    ax.set_xlabel(<span class="string">''</span>)</span><br><span class="line">    ax.set_ylabel(<span class="string">''</span>)</span><br><span class="line">    ax.tick_params(labelbottom=<span class="string">'off'</span>, labelleft=<span class="string">'off'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Add a title</span></span><br><span class="line">    ax.set_title(title, y=<span class="number">-0.1</span>, fontsize=<span class="number">18</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> plot</span><br></pre></td></tr></table></figure>

<p>其中，参数kind可以选择不同的显示样式，可选择的有<code>“scatter”，“reg”，“resid”，“kde”，“hex”</code>，参数<code>cmap</code>为matplotlib配色。示例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">shot_chart_jointplot(shot_df.LOC_X, shot_df.LOC_Y, title=<span class="string">"Kobe Bryant FGA \n2005-06 Reg. Season"</span>, kind=<span class="string">"kde"</span>, cmap=plt.cm.YlOrRd_r)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<img src="/images/shot_chart_jointplot.png" alt="shot_chart_jointplot" width="760px" />

<hr>
<h3 id="添加球员头像信息"><a href="#添加球员头像信息" class="headerlink" title="添加球员头像信息"></a>添加球员头像信息</h3><h4 id="获取球员图像"><a href="#获取球员图像" class="headerlink" title="获取球员图像"></a>获取球员图像</h4><p>为了更好的展示，我们可以在投篮热图上加上球员的头像，头像的来源仍然是<a href="http://stats.nba.com/" target="_blank" rel="noopener">stats.nba.com</a>。抓取方式如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_player_img</span><span class="params">(player_id)</span>:</span></span><br><span class="line">    <span class="string">"""Returns the image of the player from stats.nba.com</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    player_id: int</span></span><br><span class="line"><span class="string">        The player ID used to find the image.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    url = <span class="string">"http://stats.nba.com/media/players/230x185/"</span>+str(player_id)+<span class="string">".png"</span></span><br><span class="line">    img_file = str(player_id) + <span class="string">".png"</span></span><br><span class="line">    <span class="keyword">return</span> urllib.urlretrieve(url, img_file)[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<p>先看一下效果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sns.set_style(<span class="string">'white'</span>)</span><br><span class="line">sns.set_color_codes()</span><br><span class="line"></span><br><span class="line">pic = get_player_img(<span class="number">977</span>)</span><br><span class="line">Kobe_img = plt.imread(pic)</span><br><span class="line">plt.imshow(Kobe_img)</span><br></pre></td></tr></table></figure>
<img src="/images/977.png" alt="Kobe" width="180px" />

<h4 id="带球员头像的投篮热力图"><a href="#带球员头像的投篮热力图" class="headerlink" title="带球员头像的投篮热力图"></a>带球员头像的投篮热力图</h4><p>在获取到球员头像后，我们可以通过使用<code>matplotlib.Offset</code>模块中的<code>OffsetImage</code>函数在我们的投篮热力图的右上角加入球员头像，具体实现如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">m matplotlib.offsetbox <span class="keyword">import</span>  OffsetImage</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shot_chart_jointplot_with_player_img</span><span class="params">(x, y, player_img, data=None, title=<span class="string">""</span>, kind=<span class="string">"scatter"</span>, color=<span class="string">"b"</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">                         cmap=None, xlim=<span class="params">(<span class="number">-250</span>, <span class="number">250</span>)</span>, ylim=<span class="params">(<span class="number">422.5</span>, <span class="number">-47.5</span>)</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                         space=<span class="number">0</span>, court_color=<span class="string">"gray"</span>, outer_lines=False,</span></span></span><br><span class="line"><span class="function"><span class="params">                         court_lw=<span class="number">1</span>, flip_court=False,</span></span></span><br><span class="line"><span class="function"><span class="params">                         set_size_inches=<span class="params">(<span class="number">12</span>, <span class="number">11</span>)</span>, **kwargs)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Returns a seaborn JointGrid using sns.jointplot</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    TODO: Better documentation</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># If a colormap is not provided, then it is based off of the color</span></span><br><span class="line">    <span class="keyword">if</span> cmap <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        cmap = sns.light_palette(color, as_cmap=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    plot = sns.jointplot(x, y, data=<span class="literal">None</span>, stat_func=<span class="literal">None</span>, kind=kind, space=<span class="number">0</span>, color=cmap(<span class="number">0.1</span>), cmap=cmap, **kwargs)</span><br><span class="line"></span><br><span class="line">    plot.fig.set_size_inches(set_size_inches)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># A joint plot has 3 Axes, the first one called ax_joint </span></span><br><span class="line">    <span class="comment"># is the one we want to draw our court onto and adjust some other settings</span></span><br><span class="line">    ax = plot.ax_joint</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> flip_court:</span><br><span class="line">        ax.set_xlim(xlim)</span><br><span class="line">        ax.set_ylim(ylim)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        ax.set_xlim(xlim[::<span class="number">-1</span>])</span><br><span class="line">        ax.set_ylim(ylim[::<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">    draw_court(ax, color=court_color, lw=court_lw, outer_lines=outer_lines)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Get rid of axis labels and tick marks</span></span><br><span class="line">    ax.set_xlabel(<span class="string">''</span>)</span><br><span class="line">    ax.set_ylabel(<span class="string">''</span>)</span><br><span class="line">    ax.tick_params(labelbottom=<span class="string">'off'</span>, labelleft=<span class="string">'off'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Add a title</span></span><br><span class="line">    ax.set_title(title, y=<span class="number">-0.1</span>, fontsize=<span class="number">18</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># First create our OffSetImage by passing in our image</span></span><br><span class="line">    <span class="comment"># and set the zoom level to make the image small enough </span></span><br><span class="line">    <span class="comment"># to fit on our plot</span></span><br><span class="line">    img = OffsetImage(player_img, zoom=<span class="number">0.6</span>)</span><br><span class="line">    <span class="comment"># Pass in a tuple of x,y coordinates to set_offset</span></span><br><span class="line">    <span class="comment"># to place the plot where you want, I just played around</span></span><br><span class="line">    <span class="comment"># with the values until I found a spot where I wanted</span></span><br><span class="line">    <span class="comment"># the image to be</span></span><br><span class="line">    img.set_offset((<span class="number">992</span>,<span class="number">914</span>))</span><br><span class="line">    <span class="comment"># add the image</span></span><br><span class="line">    ax.add_artist(img)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> plot</span><br></pre></td></tr></table></figure>
<p>使用示例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">shot_chart_jointplot_with_player_img(shot_df.LOC_X, shot_df.LOC_Y, Kobe_img, title=<span class="string">"Kobe Bryant FGA \n2005-06 Reg. Season"</span>, kind=<span class="string">"kde"</span>, cmap=plt.cm.YlOrRd_r)</span><br><span class="line">plt.savefig(<span class="string">'Kobe_shot_chart_jointplot_with_player_img.png'</span>)</span><br></pre></td></tr></table></figure>

<p>效果如下图：</p>
<img src="/images/Kobe_shot_chart_jointplot_with_player_img.png" alt="Kobe_shot_chart_jointplot_with_player_img" width="760px" />
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>NBA</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP和扩展KMP算法</title>
    <url>/2015/08/04/kmp/</url>
    <content><![CDATA[<p>介绍经典的KMP算法。</p>
<a id="more"></a>

<h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><ul>
<li><p>Leetcode</p>
<p>  <a href="https://leetcode.com/problems/implement-strstr/" target="_blank" rel="noopener">Implement strStr()</a></p>
</li>
<li><p>分析</p>
<p>  KMP算法是一个经典的字符串匹配算法，如给定主串S及模式串T，求出S子串第一次匹配T的地址，如不存在则返回-1。其主要思想是利用字符匹配失败的信息，减少模式串与主串的匹配次数。</p>
<blockquote>
<p>如下图，假设已经比对了<code>s[i-1, i+m-1]</code>（图中黄色部分）和<code>T[0, j+n-1]</code>，在比对<code>S[i+m]</code>和<code>T[j+n]</code>时，发生了字符不匹配。</p>
</blockquote>
<p>  <img src="/images/kmp01.png" alt="kmp01"></p>
<blockquote>
<p>按照传统的做法，需要从头开始比较，即从<code>S[i]</code>和<code>T[0]</code>逐个进行字符匹配，如下图。</p>
</blockquote>
<p>  <img src="/images/kmp02.png" alt="kmp02"></p>
<blockquote>
<p>上面的方法显然不可取，因为我们在之前的比对过程中已经发现<code>s[i-1, i+m-1]=T[0, j+n-1]</code>，我们需要充分利用这些信息来避免重复的工作。</p>
</blockquote>
<blockquote>
<p>在去理解KMP算法之前，我们需要先弄清楚两个概念：</p>
</blockquote>
<ul>
<li><p>前缀：除最后一个字符外，一个字符串的全部头补组合，如hello的前缀有h, he, hel, hell。</p>
</li>
<li><p>后缀：除第一个字符外，一个字符串全部尾部组合，如hello的后缀有ello, llo, lo, o。</p>
</li>
</ul>
<hr>
<blockquote>
<p>如下图，假设<code>T[0, j+n-1]</code>最长公共前缀和后缀为<code>t0</code>和<code>t1</code>，即<code>t0=t1</code>且<code>T[j]!=T[j+n]</code>。在上次的比较中，我们已经得到<code>s=t1</code>，所以t0这部分是不需要再重复比对的，我们只需要从<code>S[i+m]</code>和<code>T[j]</code>开始比较就可以了。</p>
</blockquote>
<p>  <img src="/images/kmp03.png" alt="kmp03"></p>
<blockquote>
<p>如果<code>S[i+m]=T[j]</code>，则继续比对两个字符串的下一个字符，若<code>S[i+m]!=T[j]</code>，我们需要继续通过字符串<code>t0</code>的最长公共前缀和后缀来判断T中需要和<code>S[i+m]</code>进行比较的字符的最大位置。若该位置的字符仍与S[i+m]不相等，则继续以前缀作为子串，寻找T中需要做判断的字符的位置，如此往复，直至该位置的字符和S[i+m]相等或者已经到了T的第一个字符。</p>
</blockquote>
<blockquote>
<p>假设数组<code>next[i]</code>, $0 \leq i&lt;strlen(T)$存放着模式串T的子串T[0, i]的最长前缀和后缀的长度。则编程实现方法如下：</p>
</blockquote>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int strStr(char* S, char* T) &#123;</span><br><span class="line">	int S_len &#x3D; strlen(S);</span><br><span class="line">	int T_len&#x3D;strlen(T);</span><br><span class="line"></span><br><span class="line">	if(T_len&#x3D;&#x3D;0)</span><br><span class="line">		return 0;</span><br><span class="line"></span><br><span class="line">	int *next &#x3D; (int*)malloc(T_len*sizeof(int));</span><br><span class="line"></span><br><span class="line">	getNext(next, T);</span><br><span class="line"></span><br><span class="line">	int i;</span><br><span class="line">	int cursor &#x3D; 0;			&#x2F;&#x2F;T中需要和S[i]进行比较的字符的下标</span><br><span class="line"></span><br><span class="line">	for(i&#x3D;0;i&lt;S_len;i++)&#123;</span><br><span class="line">		while(cursor&gt;0 &amp;&amp; S[i]!&#x3D;T[cursor])</span><br><span class="line">			cursor &#x3D; next[cursor-1];</span><br><span class="line"></span><br><span class="line">		if(S[i]&#x3D;&#x3D;T[cursor])</span><br><span class="line">			cursor++;</span><br><span class="line"></span><br><span class="line">		if(cursor &#x3D;&#x3D; T_len)</span><br><span class="line">			return i+1-T_len;</span><br><span class="line">	&#125;</span><br><span class="line">	return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<ul>
<li><p>next数组</p>
<blockquote>
<p>假设next[0, i-1]已经求出，现在我们需要求<code>next[i]</code>，如下图：</p>
</blockquote>
<p>  <img src="/images/kmp04.png" alt="kmp04"></p>
<blockquote>
<p>此时，需要比较<code>T[i]</code>和<code>T[next[i-1]]</code>是否相等。若相等，则继续比较下一组，即在<code>i+1</code>和<code>next[i-1]+1</code>处的字符。若不等，则比较在<code>i</code>和<code>next[next[i-1]]</code>处的字符是否相等，如下图红色标注的部分。</p>
</blockquote>
<p>  <img src="/images/kmp05.png" alt="kmp05"></p>
<blockquote>
<p>在计算next数组时，还需要注意临界值的判断，即next[0]=0。计算next数组的编程实现如下：</p>
</blockquote>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void getNext(int* next, char* T)&#123;</span><br><span class="line">	int len &#x3D; strlen(T);</span><br><span class="line">	next[0] &#x3D; 0;</span><br><span class="line"></span><br><span class="line">	int i;</span><br><span class="line">	int cursor &#x3D; 0;</span><br><span class="line">	for(i&#x3D;1;i&lt;len;i++)&#123;</span><br><span class="line">		while(cursor&gt;0 &amp;&amp; T[i]!&#x3D;T[cursor])</span><br><span class="line">		cursor &#x3D; next[cursor-1];</span><br><span class="line"></span><br><span class="line">		if(T[i]&#x3D;&#x3D;T[cursor])</span><br><span class="line">			cursor++;</span><br><span class="line"></span><br><span class="line">		next[i] &#x3D; cursor;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<h3 id="扩展KMP"><a href="#扩展KMP" class="headerlink" title="扩展KMP"></a>扩展KMP</h3><p>扩展KMP是求主串S的所有后缀（包括S）与模式串T的所有前缀（包括T）的最长公共元素的长度，即求子串<code>S[i, strlen(S)-1]</code>和<code>T</code>的最长公共前缀（包括自身）的长度，结果记录在extend数组中。例如，对以下两个字符串：</p>
<blockquote>
<p>S=”aaabaa”<br/> T=”aaba”</p>
</blockquote>
<p>根据上述定义，有extend[0]=2, extend[1]=4, extend[2]=1, extend[3]=0, extend[4]=2, extend[5]=1。</p>
<ul>
<li><p>extend数组</p>
</li>
<li><p>next数组</p>
</li>
</ul>
<p>(未完待续)</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>最长回文子串</title>
    <url>/2015/07/28/longest-palindromic-substring/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>最长回文子串 (Longest Palindromic Substring)</p>
<blockquote>
<p>Given a string S, find the longest palindromic substring in S. You may assume that the maximum length of S is 1000, and there exists one unique longest palindromic substring.</p>
</blockquote>
<ul>
<li><a href="https://leetcode.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">leetcode链接</a></li>
</ul>
<a id="more"></a>

<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ul>
<li><p>动态规划</p>
<p>  使用动态规划是以空间换取时间，避免重复的判断。具体思想是在内存中开辟一段大小为len*(len+1)/2 的数组 is_palindrome，用于记录 s 中从 i 到 j (i&lt;j) 的子串是否为回文。</p>
<ul>
<li><p>时间复杂度： $O(n^2)$</p>
</li>
<li><p>空间复杂度： $O(n^2)$</p>
</li>
</ul>
</li>
<li><p>中心扩展</p>
<p>  以字符串 s 的每个字符以及每两个在相邻位置字符相同的子串作为中心，向两边遍历，记录以该字符或字符串为中心的最长回文。</p>
<ul>
<li><p>时间复杂度： $O(n^2)$</p>
</li>
<li><p>空间复杂度： $O(1)$</p>
</li>
</ul>
</li>
</ul>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><ul>
<li><p>动态规划</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pos</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> j*(j+<span class="number">1</span>)/<span class="number">2</span>+i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">longestPalindrome_dp</span><span class="params">(<span class="keyword">char</span>* s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> * res;</span><br><span class="line">	<span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">	<span class="keyword">int</span> max_palindrome_start, max_palindrome_len;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//printf("%d\n", len);</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(len&lt;<span class="number">2</span>)</span><br><span class="line">		<span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> max_size = len*(len+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> *is_palindrome = (<span class="keyword">bool</span> *)<span class="built_in">malloc</span>(max_size*<span class="keyword">sizeof</span>(<span class="keyword">bool</span>));     <span class="comment">//*(is_palindrome + pos(i, j)) 表示s[i...j] (i&lt;j)是不是回文</span></span><br><span class="line">	<span class="built_in">memset</span>(is_palindrome, <span class="number">0</span>, max_size*<span class="keyword">sizeof</span>(<span class="keyword">bool</span>));                 <span class="comment">//初始为false</span></span><br><span class="line"></span><br><span class="line">	max_palindrome_start = <span class="number">0</span>;</span><br><span class="line">	max_palindrome_len   = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> i,j;</span><br><span class="line">	<span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;len; j++)&#123;</span><br><span class="line">		*(is_palindrome + pos(j, j)) = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;j; i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(j==i+<span class="number">1</span>)&#123;</span><br><span class="line">				<span class="keyword">if</span>(s[i]==s[j])</span><br><span class="line">					*(is_palindrome + pos(i, j)) = <span class="literal">true</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="keyword">if</span>( s[i]==s[j] &amp;&amp; (*(is_palindrome + pos(i+<span class="number">1</span>, j<span class="number">-1</span>))) )</span><br><span class="line">					*(is_palindrome + pos(i, j)) = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span>( *(is_palindrome + pos(i, j)) )&#123;</span><br><span class="line">				<span class="keyword">if</span>(max_palindrome_len&lt;(j-i+<span class="number">1</span>))&#123;</span><br><span class="line">					max_palindrome_len = j-i+<span class="number">1</span>;</span><br><span class="line">					max_palindrome_start = i;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//printf("%d\n", max_palindrome_start);</span></span><br><span class="line">	<span class="comment">//printf("%d\n", max_palindrome_len);</span></span><br><span class="line"></span><br><span class="line">	res = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>((max_palindrome_len+<span class="number">1</span>)*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">	<span class="built_in">memset</span>(res, <span class="number">0</span>, (max_palindrome_len+<span class="number">1</span>)*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">	<span class="built_in">strncpy</span>(res, s+max_palindrome_start, max_palindrome_len);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>中心扩展</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">longestPalindrome_ex</span><span class="params">(<span class="keyword">char</span>* s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> * res;</span><br><span class="line">	<span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">	<span class="keyword">int</span> max_palindrome_start, max_palindrome_len;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//printf("%d\n", len);</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(len&lt;<span class="number">2</span>)</span><br><span class="line">		<span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">	max_palindrome_start = <span class="number">0</span>;</span><br><span class="line">	max_palindrome_len   = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> palindrome_len;</span><br><span class="line">		<span class="keyword">int</span> left, right;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//以s[i]为中心</span></span><br><span class="line">		left  = i<span class="number">-1</span>;</span><br><span class="line">		right = i+<span class="number">1</span>;</span><br><span class="line">		palindrome_len   = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span>(left&gt;=<span class="number">0</span>&amp;&amp;right&lt;len)&#123;</span><br><span class="line">			<span class="keyword">if</span>(s[left]==s[right])</span><br><span class="line">				palindrome_len += <span class="number">2</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			left--;</span><br><span class="line">			right++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(max_palindrome_len&lt;palindrome_len)&#123;</span><br><span class="line">			max_palindrome_len = palindrome_len;</span><br><span class="line">			max_palindrome_start = i - palindrome_len/<span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//以s[i]和s[i+1]为中心</span></span><br><span class="line">		<span class="keyword">if</span>(s[i]==s[i+<span class="number">1</span>])&#123;</span><br><span class="line">			left  = i<span class="number">-1</span>;</span><br><span class="line">			right = i+<span class="number">2</span>;</span><br><span class="line">			palindrome_len   = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">while</span>(left&gt;=<span class="number">0</span>&amp;&amp;right&lt;len)&#123;</span><br><span class="line">				<span class="keyword">if</span>(s[left]==s[right])</span><br><span class="line">					palindrome_len += <span class="number">2</span>;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">				left--;</span><br><span class="line">				right++;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span>(max_palindrome_len&lt;palindrome_len)&#123;</span><br><span class="line">				max_palindrome_len = palindrome_len;</span><br><span class="line">				max_palindrome_start = i - palindrome_len/<span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	res = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>((max_palindrome_len+<span class="number">1</span>)*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">	<span class="built_in">memset</span>(res, <span class="number">0</span>, (max_palindrome_len+<span class="number">1</span>)*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">	<span class="built_in">strncpy</span>(res, s+max_palindrome_start, max_palindrome_len);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
</search>
